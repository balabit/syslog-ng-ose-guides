<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter SYSTEM "../../xml-stylesheet/pdf/dtd/docbookx.dtd"
 [  <!ENTITY % entities SYSTEM "../syslog-ng-entities.ent">
 %entities;]> 
<chapter id="chapter-manipulating-messages">
    <title>Manipulating messages</title>
    <!-- FIXME jumplist -->
    <section id="customizing-message-format">
        <title>Customizing message format</title>
        <!-- FIXME jumplist -->
        <section id="concepts_macro">
            <title>Formatting messages, filenames, directories, and tablenames</title>
            <indexterm>
                <primary>formatting messages</primary>
            </indexterm>
            <indexterm>
                <primary>templates</primary>
            </indexterm>
            <indexterm>
                <primary>message templates</primary>
            </indexterm>
            <indexterm>
                <primary>macros</primary>
            </indexterm>
            <para>The &abbrev; application can dynamically create filenames, directories, or names of database tables using macros that help you organize your log messages. Macros refer to a property or a part of the log message, for example, the <parameter>$HOST</parameter> macro refers to the name or IP address of the client that sent the log message, while <parameter>$DAY</parameter> is the day of the month when syslog-ng has received the message. Using these macros in the path of the destination log files allows you for example to collect the logs of every host into separate files for every day.</para>
            <para>A set of macros can be defined as a template object and used in multiple destinations.</para>
            <para>Another use of macros and templates is to customize the format of the syslog message, for example to add elements of the message header to the message text. Note that if a message uses the IETF-syslog format, only the text of the message can be customized, the structure of the header is fixed.</para>
            <itemizedlist>
                <listitem>
                    <para>For details on using templates and macros, see <xref linkend="configuring_macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For a list and description of the macros available in &abbrev;, see <xref linkend="reference_macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For details on using custom macros created with CSV parsers and pattern databases, see <xref linkend="chapter-csv-parser"/> and <xref linkend="patterndb-filters"/>, respectively.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section id="configuring_macros">
        <!-- FIXME a template+makro, parser es rewrite sectionoket egy kozos sectionbe kellene tenni, es az elejen 
        leirni, hogy hogyan viszonyulnak egymashoz: vannak a makrok, parserrel lehet az uzeneteket sajat makrokra bontani, 
        a rewrite meg ezeket tudja atirni-->
        <title>Templates and macros</title>
        <indexterm significance="preferred">
            <primary>templates</primary>
        </indexterm>
        <para>The &abbrev; application allows you to define message templates, and reference them
            from every object that can use a template. Templates can be used for example to create standard
            message formats or filenames. Templates can reference one or more macros (for example date,
            the hostname, and so on). See <xref linkend="reference_macros"/> for a list of macros
            available in &product;. Fields from the structured data (SD) part of messages using the new
            IETF-syslog standard can also be used as macros.</para>
        <para>Template objects have a single option called <parameter>template_escape</parameter>,
            which is disabled by default (<parameter>template_escape(no)</parameter>). This behavior
            is useful when the messages are passed to an application that cannot handle escaped
            characters properly. Enabling template escaping
            (<parameter>template_escape(yes)</parameter>) causes syslog-ng to escape the
                <parameter>'</parameter> and <parameter>"</parameter> characters from the messages.</para>
        <note>
            <para>In versions 2.1 and earlier, the <parameter>template_escape()</parameter> option
                was enabled by default.</para>
        </note>
        <para>Macros can be included by prefixing the macro name with a <parameter>$</parameter> sign, just like in Bourne compatible shells. Although using braces around macro names is not mandatory, and the <parameter>"$MSG"</parameter> and <parameter>"${MSG}"</parameter> formats are equivalent, using the <parameter>"${MSG}"</parameter> format is recommended for clarity. </para>
        <indexterm>
            <primary>macros</primary>
            <secondary>default value</secondary>
        </indexterm>
        <para>Default values for macros can also be specified by appending the
            <parameter>:-</parameter> characters and the default value of the macro. If a message does not contain the field referred to by the macro, or it is empty, the default value will be used when expanding the macro. For example, if a message does not contain a hostname, the following macro can specify a default hostname.</para>
        <synopsis>${HOST:-default_hostname}</synopsis>
        <para id="date_macros">The macros related to the date of the message (for example:
                <parameter>ISODATE</parameter>, <parameter>HOUR</parameter>, etc.) have two further
            versions each: one with the <parameter>S_</parameter> and one with the
            <parameter>R_</parameter> prefix (for example: <parameter>S_DATE</parameter> and
                <parameter>R_DATE</parameter> ). The <parameter>S_DATE</parameter> macro represents
            the date found in the log message, i.e. when the message was sent by the original
            application. <parameter>R_DATE</parameter> is the date when syslog has received the
            message.</para>
        <para>Starting with &abbrev; version 3.2, the <parameter>DATE</parameter> macro equals the <parameter>S_DATE</parameter> macro. In earlier versions the value of <parameter>DATE</parameter> depended on the <parameter>use_time_recvd()</parameter> global option, which was removed from &abbrev;.</para>
        <warning>
            <para>The hostname-related macros (<parameter>FULLHOST</parameter>,
                    <parameter>FULLHOST_FROM</parameter>, <parameter>HOST</parameter>, and
                    <parameter>HOST_FROM</parameter>) do not have any effect if the 
                    <parameter>keep_hostname()</parameter>
                    option is disabled.</para>
        </warning>
        <para>By default, syslog-ng sends messages using the following template: <parameter>$ISODATE
                $HOST $MSGHDR$MSG\n</parameter>. (The <parameter>$MSGHDR$MSG</parameter> part is
            written together because the <parameter>$MSGHDR</parameter> macro includes a trailing
            whitespace.)</para>
        <note>
            <para>Earlier versions of syslog-ng used templates and scripts to send log messages into
                SQL databases. Starting from version 2.1, syslog-ng natively supports direct
                database access using the <parameter>sql()</parameter> destination. See <xref
                    linkend="reference_destination_sql"/> for details.</para>
        </note>
        <indexterm>
            <primary>templates</primary>
            <secondary>defining</secondary>
        </indexterm>
        <example>
            <title>Using templates and macros</title>
            <indexterm>
                <primary>templates</primary>
                <secondary>example</secondary>
            </indexterm>
            <para>The following template (<parameter>t_demo_filetemplate</parameter>) adds the date
                of the message and the name of the host sending the message to the beginning of the
                message text. The template is then used in a file destination: messages sent to this
                destination (<parameter>d_file</parameter>) will use the message format defined in
                the template. </para>
            <synopsis>template t_demo_filetemplate { 
             template("$ISODATE $HOST $MSG\n"); template_escape(no); };          
destination d_file { 
             file("/var/log/messages" template(t_demo_filetemplate)); };</synopsis>
            <para>Templates can also be used inline, if they are used only at a single location. The
                following destination is equivalent with the previous example: </para>
            <synopsis>destination d_file {
                file ("/var/log/messages"
                        template("$ISODATE $HOST $MSG\n") template_escape(no) ); 
                };
            </synopsis>
            <indexterm>
                <primary>macros</primary>
                <secondary>in filenames</secondary>
            </indexterm>
            <para>The following file destination uses macros to daily create separate logfiles for every client host.</para>
            <synopsis>destination d_file {
        file("/var/log/$YEAR.$MONTH.$DAY/$HOST.log");
};</synopsis>
        </example>
        <note>
            <para>Macros can be used to format messages, and also in the name of destination files or database tables. However, they cannot be used in sources as wildcards, for example, to read messages from files or directories that include a date in their name.</para>
        </note>
        </section>
        <section id="reference_macros">
        <title>Macros of &abbrev;</title>
        <indexterm>
            <primary>macros</primary>
            <secondary>reference</secondary>
        </indexterm>
        <para>The following macros are available in &abbrev;.</para>
        <simplesect>
            <title>BSDTAG</title>
                <indexterm type="parameter">
                    <primary>BSDTAG</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$BSDTAG</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Facility/priority information in the format used by the FreeBSD
                syslogd: a priority number followed by a letter that indicates the
                facility. The priority number can range from <parameter>0</parameter> to
                <parameter>7</parameter>. The facility letter can range from
                <parameter>A</parameter> to <parameter>Y</parameter>, where
                <parameter>A</parameter> corresponds to facility number zero
                (LOG_KERN), <parameter>B</parameter> corresponds to facility 1
                (LOG_USER), etc.</para>
        </simplesect>
        <simplesect id="macro_custom">
            <title>Custom macros</title>
                <indexterm type="parameter">
                    <primary>Custom macros</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> CSV parsers and pattern databases can also define macros from the content of the messages, for example, a pattern database rule can extract the username from a login message and create a macro that references the username. For details on using custom macros created with CSV parsers and pattern databases, see <xref linkend="chapter-csv-parser"/> and <xref linkend="patterndb-filters"/>, respectively.</para>
        </simplesect>
        <simplesect id="macro_date">
            <title>DATE, R_DATE, S_DATE</title>
                <indexterm type="parameter">
                    <primary>DATE, R_DATE, S_DATE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$DATE, $R_DATE, $S_DATE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Date of the message using the BSD-syslog style timestamp format
                (month/day/hour/minute/second, each expressed in two digits). This is
                the original syslog time stamp without year information, for example:
                <parameter>Jun 13 15:58:00</parameter>.</para>
        </simplesect>
        <simplesect id="macro_day">
            <title>DAY, R_DAY, S_DAY</title>
                <indexterm type="parameter">
                    <primary>DAY, R_DAY, S_DAY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$DAY, $R_DAY, $S_DAY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The day the message was sent.</para>
        </simplesect>
        <simplesect id="macro_facility">
            <title>FACILITY</title>
                <indexterm type="parameter">
                    <primary>FACILITY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FACILITY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name of the facility (for example, <parameter>kern</parameter>) that sent the message.</para>
        </simplesect>
        <simplesect id="macro_facility_num">
            <title>FACILITY_NUM</title>
                <indexterm type="parameter">
                    <primary>FACILITY_NUM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FACILITY_NUM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The numerical code of the facility (for example, <parameter>0</parameter>) that sent the message.</para>
        </simplesect>
        <simplesect id="macro_fulldate">
            <title>FULLDATE, R_FULLDATE, S_FULLDATE</title>
                <indexterm type="parameter">
                    <primary>FULLDATE, R_FULLDATE, S_FULLDATE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FULLDATE, $R_FULLDATE, $S_FULLDATE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> A nonstandard format for the date of the message using the same
                format as <parameter>DATE</parameter>, but including the year as well,
                for example: <parameter>2006 Jun 13 15:58:00</parameter>.</para>
        </simplesect>
        <simplesect>
            <title>FULLHOST</title>
                <indexterm type="parameter">
                    <primary>FULLHOST</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FULLHOST</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The full FQDN of the host name chain (without trimming chained
                hosts), including the domain name. To use this macro, make sure that the
                <parameter>keep_hostname()</parameter> option is enabled.</para>
        </simplesect>
        <simplesect>
            <title>FULLHOST_FROM</title>
                <indexterm type="parameter">
                    <primary>FULLHOST_FROM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FULLHOST_FROM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> FQDN of the host that sent the message to syslog-ng as resolved by
                syslog-ng using DNS. If the message traverses several hosts, this is the
                last host in the chain. To use this macro, make sure that the <parameter>keep_hostname()</parameter>
                option is enabled.</para>
        </simplesect>
        <simplesect id="macro_hour">
            <title>HOUR, R_HOUR, S_HOUR</title>
                <indexterm type="parameter">
                    <primary>HOUR, R_HOUR, S_HOUR</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$HOUR, $R_HOUR, $S_HOUR</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The hour of day the message was sent.</para>
        </simplesect>
        <simplesect id="macro_host">
            <title>HOST</title>
                <indexterm type="parameter">
                    <primary>HOST</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$HOST</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name of the source host where the message originates from. If the
                message traverses several hosts and the <link linkend="option_chain_hostnames">
                    <parameter>chain_hostnames()</parameter>
                </link> option is on, the first host in the chain is used. To use this
                macro, make sure that the <parameter>keep_hostname()</parameter>
                option is enabled.</para>
        </simplesect>
        <simplesect>
            <title>HOST_FROM</title>
                <indexterm type="parameter">
                    <primary>HOST_FROM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$HOST_FROM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Name of the host that sent the message to syslog-ng, as resolved by
                syslog-ng using DNS. If the message traverses several hosts, this is the
                last host in the chain. To use this macro, make sure that the <parameter>keep_hostname()</parameter>
                option is enabled.</para>
        </simplesect>
        <simplesect id="macro_isodate">
            <title>ISODATE, R_ISODATE, S_ISODATE</title>
                <indexterm type="parameter">
                    <primary>ISODATE, R_ISODATE, S_ISODATE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$ISODATE, $R_ISODATE, $S_ISODATE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Date of the message in the ISO 8601 compatible standard timestamp
                format (yyyy-mm-ddThh:mm:ss+-ZONE), for example:
                <parameter>2006-06-13T15:58:00.123+01:00</parameter>. If possible,
                it is recommended to use <parameter>ISODATE</parameter> for
                timestamping. Note that syslog-ng can produce fractions of a second
                (for example milliseconds) in the timestamp by using the
                <parameter>frac_digits()</parameter> global or per-destination
                option.</para>
        </simplesect>
        <simplesect>
            <title>LEVEL_NUM</title>
                <indexterm type="parameter">
                    <primary>LEVEL_NUM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$LEVEL_NUM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority (also called severity) of the message, represented as a numeric value, for example, <parameter>3</parameter>.</para>
        </simplesect>
        <simplesect id="macro_min">
            <title>MIN, R_MIN, S_MIN</title>
                <indexterm type="parameter">
                    <primary>MIN, R_MIN, S_MIN</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MIN, $R_MIN, $S_MIN</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The minute the message was sent.</para>
        </simplesect>
        <simplesect id="macro_month">
            <title>MONTH, R_MONTH, S_MONTH</title>
                <indexterm type="parameter">
                    <primary>MONTH, R_MONTH, S_MONTH</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH, $R_MONTH, $S_MONTH</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The month the message was sent as a decimal value, prefixed with a
                zero if smaller than 10.</para>
        </simplesect>
        <simplesect id="macro_month_abbrev">
            <title>MONTH_ABBREV, R_MONTH_ABBREV, S_MONTH_ABBREV</title>
                <indexterm type="parameter">
                    <primary>MONTH_ABBREV, R_MONTH_ABBREV, S_MONTH_ABBREV</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH_ABBREV, $R_MONTH_ABBREV, $S_MONTH_ABBREV</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The English abbreviation of the month name (3 letters).</para>
        </simplesect>
        <simplesect id="macro_month_name">
            <title>MONTH_NAME, R_MONTH_NAME, S_MONTH_NAME</title>
                <indexterm type="parameter">
                    <primary>MONTH_NAME, R_MONTH_NAME, S_MONTH_NAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH_NAME, $R_MONTH_NAME, $S_MONTH_NAME</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The English name of the month name.</para>
        </simplesect>
        <simplesect id="macro_month_week">
            <title>MONTH_WEEK, R_MONTH_WEEK, S_MONTH_WEEK</title>
                <indexterm type="parameter">
                    <primary>MONTH_WEEK, R_MONTH_WEEK, S_MONTH_WEEK</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH_WEEK, $R_MONTH_WEEK, $S_MONTH_WEEK</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The number of the week in the given month (0-5). 
                The week with numerical value 1 is the first week 
                containing a Monday. The days of month before the first 
                Monday are considered week 0. For example, if a 31-day 
                month begins on a Sunday, then the 1st of the month is 
                week 0, and the end of the month (the 30th and 31st) is 
                week 5.</para>
        </simplesect>
        <simplesect id="macro_msg">
            <title>MSG or MESSAGE</title>
                <indexterm type="parameter">
                    <primary>MSG or MESSAGE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MSG or $MESSAGE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Text contents of the log message without the program name and pid.
                Note that this has changed in syslog-ng version 3.0; in earlier versions
                this macro included the program name and the pid. In syslog-ng 3.0, the
                <parameter>MSG</parameter> macro became equivalent with the
                <parameter>MSGONLY</parameter> macro. The program name and the pid
                together are available in the <parameter>MSGHDR</parameter>
                macro.</para>
        </simplesect>
        <simplesect>
            <title>MSGHDR</title>
                <indexterm type="parameter">
                    <primary>MSGHDR</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MSGHDR</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name and the pid of the program that sent the log message in
                <parameter>PROGRAM: PID </parameter> format. Includes a trailing
                whitespace. Note that the macro returns an empty value if both the
                program and pid fields of the message are empty.</para>
        </simplesect>
        <simplesect>
            <title>MSGONLY</title>
                <indexterm type="parameter">
                    <primary>MSGONLY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MSGONLY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Message contents without the program name or pid.</para>
        </simplesect>
        <simplesect>
            <title>PID</title>
                <indexterm type="parameter">
                    <primary>PID</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PID</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The PID of the program sending the message.</para>
        </simplesect>
        <simplesect id="macro_pri">
            <title>PRI</title>
                <indexterm type="parameter">
                    <primary>PRI</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PRI</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority and facility encoded as a 2 or 3 digit decimal number as
                it is present in syslog messages.</para>
        </simplesect>
        <simplesect id="macro_priority">
            <title>PRIORITY or LEVEL</title>
                <indexterm type="parameter">
                    <primary>PRIORITY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>LEVEL</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PRIORITY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$LEVEL</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority (also called severity) of the message, for example, <parameter>error</parameter>.</para>
        </simplesect>
        <simplesect>
            <title>PROGRAM</title>
                <indexterm type="parameter">
                    <primary>PROGRAM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PROGRAM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name of the program sending the message. Note that the content of
                the $PROGRAM variable may not be completely trusted as it is provided by
                the client program that constructed the message.</para>
        </simplesect>
        <simplesect id="macro_sdata">
            <title>SDATA, .SDATA.SDID.SDNAME</title>
                <indexterm type="parameter">
                    <primary>.SDATA.SDID.SDNAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>SDATA</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$.SDATA.SDID.SDNAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SDATA</primary>
                </indexterm>
                <indexterm>
                    <primary>STRUCTURED-DATA</primary>
                </indexterm>
                <indexterm>
                    <primary>macros</primary>
                    <secondary>SDATA</secondary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The syslog-ng application automatically parses the STRUCTURED-DATA
                part of IETF-syslog messages, which can be referenced in macros. The <parameter>$SDATA</parameter> macro references the entire STRUCTURED-DATA part of the message, while structured data elements can be referenced using the <parameter>$.SDATA.SDID.SDNAME</parameter> macro.</para>
                <note>
                    <para>When using STRUCTURED-DATA macros, consider the following:</para>
                    <itemizedlist>
                        <listitem>
                            <para>When referencing an element of the structured data, the macro must begin with the dot (.) character. For example, <parameter>$.SDATA.timeQuality.isSynced</parameter>.</para>
                        </listitem>
                        <listitem>
                            <para>The SDID and SDNAME parts of the macro names are case sensitive: <parameter>$.SDATA.timeQuality.isSynced</parameter> is not the same as <parameter>$.SDATA.TIMEQUALITY.ISSYNCED</parameter>.</para>
                        </listitem>
                    </itemizedlist>
                </note>
                <example>
                    <title>Using SDATA macros</title>
                    <para>For example, if a log message contains the following structured data:
                <parameter>[exampleSDID@0 iut="3" eventSource="Application"
                    eventID="1011"][examplePriority@0 class="high"]</parameter> you can
                use macros like: <parameter>${.SDATA.exampleSDID@0.eventSource}</parameter> &mdash; this would return the <parameter>Application</parameter> string in this case.</para>
                </example>
        </simplesect>
        <simplesect id="macro_sec">
            <title>SEC, R_SEC, S_SEC</title>
                <indexterm type="parameter">
                    <primary>SEC, R_SEC, S_SEC</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SEC, $R_SEC, $S_SEC</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The second the message was sent.</para>
        </simplesect>
        <simplesect id="macro_seqnum">
            <title>SEQNUM</title>
                <indexterm type="parameter">
                    <primary>SEQNUM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SEQNUM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The sequence number of the message is a unique identifier of the
                message between the end-points. The syslog-ng client calculates this
                number when processing a new message from a local source; it is not
                calculated for relayed messages. The sequence number increases for every
                message, and is not lost even if syslog-ng is reloaded or restarted. The
                sequence number is a part of every message that uses the new IETF-syslog
                protocol (<parameter>.SDATA.meta.sequenceId</parameter>), and can be
                added to BSD-syslog messages using this macro.</para>
        </simplesect>
        
        <!-- FIXME kellene rola leiras/concept esetleg -->
        
        <simplesect>
            <title>SOURCEIP</title>
                <indexterm type="parameter">
                    <primary>SOURCEIP</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SOURCEIP</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> IP address of the host that sent the message to syslog-ng. (I.e. the
                IP address of the host in the <parameter>FULLHOST_FROM</parameter>
                macro.) Please note that when a message traverses several relays, this
                macro contains the IP of the last relay.</para>
        </simplesect>
        <simplesect id="macro_stamp">
            <title>STAMP, R_STAMP, S_STAMP</title>
                <indexterm type="parameter">
                    <primary>STAMP, R_STAMP, S_STAMP</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$STAMP, $R_STAMP, $S_STAMP</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> A timestamp formatted according to the <link linkend="reference_options">
                <parameter>ts_format()</parameter>
            </link> global or per-destination option.</para>
        </simplesect>
        <simplesect id="macro_tag">
            <title>TAG</title>
                <indexterm type="parameter">
                    <primary>TAG</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TAG</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority and facility encoded as a 2 digit hexadecimal number.</para>
        </simplesect>
        <simplesect id="macro_tags">
            <title>TAGS</title>
                <indexterm type="parameter">
                    <primary>TAGS</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TAGS</primary>
                </indexterm>
                <indexterm>
                    <primary>macros</primary>
                    <secondary>patterndb tags</secondary>
                </indexterm>
                <indexterm>
                    <primary>tags</primary>
                    <secondary>as macro</secondary>
                </indexterm>
            <para><guilabel>Description:</guilabel> A comma-separated list of the tags assigned to the message.</para>
            <note>
                <para>Note that the tags are not part of the log message and are not automatically transferred from a client to the server. For example, if a client uses a pattern database to tag the messages, the tags are not transferred to the server. A way of transferring the tags is to explicitly add them to the log messages using a template and the <parameter>$TAGS</parameter> macro, or to add them to the structured metadata part of messages when using the IETF-syslog message format.</para>
                <para>When sent as structured metadata, it is possible to reference to the list of tags on the central server, and for example, to add them to a database column.</para>
            </note>
        </simplesect>
        <simplesect id="macro_tz">
            <title>TZ, R_TZ, S_TZ</title>
                <indexterm type="parameter">
                    <primary>TZ, R_TZ, S_TZ</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TZ, $R_TZ, $S_TZ</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Equivalent to TZOFFSET, used to mean the time zone name abbreviation
                in syslog-ng 1.6.x.</para>
        </simplesect>
        <simplesect id="macro_tzoffset">
            <title>TZOFFSET, R_TZOFFSET, S_TZOFFSET</title>
                <indexterm type="parameter">
                    <primary>TZOFFSET, R_TZOFFSET, S_TZOFFSET</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TZOFFSET, $R_TZOFFSET, $S_TZOFFSET</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The time-zone as hour offset from GMT; for example:
                <parameter>-07:00</parameter>. In syslog-ng 1.6.x this used to be
                <parameter>-0700</parameter> but as <parameter>ISODATE</parameter>
                requires the colon it was added to <parameter>TZOFFSET</parameter> as
                well.</para>
        </simplesect>
        <simplesect id="macro_unixtime">
            <title>UNIXTIME, R_UNIXTIME, S_UNIXTIME</title>
                <indexterm type="parameter">
                    <primary>UNIXTIME, R_UNIXTIME, S_UNIXTIME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$UNIXTIME, $R_UNIXTIME, $S_UNIXTIME</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Standard unix timestamp, represented as the number of seconds since
                <parameter>1970-01-01T00:00:00</parameter>.</para>
        </simplesect>
        <simplesect id="macro_year">
            <title>YEAR, R_YEAR, S_YEAR</title>
                <indexterm type="parameter">
                    <primary>YEAR, R_YEAR, S_YEAR</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$YEAR, $R_YEAR, $S_YEAR</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The year the message was sent.</para>
        </simplesect>
        <simplesect id="macro_week">
            <title>WEEK, R_WEEK, S_WEEK</title>
                <indexterm type="parameter">
                    <primary>WEEK, R_WEEK, S_WEEK</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK, $R_WEEK, $S_WEEK</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The week number of the year, prefixed with a zero for the first nine
                week of the year. (The first Monday in the year marks the first
                week.)</para>
        </simplesect>
        <simplesect id="macro_week_abbrev">
            <title>WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV</title>
                <indexterm type="parameter">
                    <primary>WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK_ABBREV, $R_WEEK_ABBREV, $S_WEEK_ABBREV</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The 3-letter English abbreviation of the name of the day the message was sent, for example <parameter>Thu</parameter>.</para>
        </simplesect>
        <simplesect id="macro_week_day">
            <title>WEEK_DAY, R_WEEK_DAY, S_WEEK_DAY</title>
                <indexterm type="parameter">
                    <primary>WEEK_DAY, R_WEEK_DAY, S_WEEK_DAY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK_DAY, $R_WEEK_DAY, $S_WEEK_DAY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The day of the week as a numerical value (1-7).</para>
        </simplesect>
        <simplesect id="macro_weekday">
            <title>WEEKDAY, R_WEEKDAY, S_WEEKDAY</title>
                <indexterm type="parameter">
                    <primary>WEEKDAY, R_WEEKDAY, S_WEEKDAY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEKDAY, $R_WEEKDAY, $S_WEEKDAY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> These macros are deprecated, use <link linkend="macro_week_abbrev">WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV</link> instead. The 3-letter name of the day of week the message was sent, for example
                <parameter>Thu</parameter>.</para>
        </simplesect>
        <simplesect id="macro_week_day_name">
            <title>WEEK_DAY_NAME, R_WEEK_DAY_NAME, S_WEEK_DAY_NAME</title>
                <indexterm type="parameter">
                    <primary>WEEK_DAY_NAME, R_WEEK_DAY_NAME, S_WEEK_DAY_NAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK_DAY_NAME, $R_WEEK_DAY_NAME, $S_WEEK_DAY_NAME</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The English name of the day.</para>
        </simplesect>
    </section>
        <section id="template-functions">
            <title>Template functions</title>
            <indexterm>
                <primary>template functions</primary>
            </indexterm>
            <indexterm>
                <primary>templates</primary>
                <secondary>template functions</secondary>
            </indexterm>
            <para>A template function is a transformation: it modifies the way macros or name-value pairs are expanded. Template functions can be used in template definitions, or when macros are used in the configuration of &abbrev;. Template functions use the following syntax:</para>
            <synopsis>$(function-name parameter1 parameter2 parameter3 ...)</synopsis>
            <para>For example, the <parameter>$(echo)</parameter> template function simply returns the value of the macro it receives as a parameter, thus <parameter>$(echo $HOST)</parameter> is equivalent to <parameter>$HOST</parameter></para>.
            <parameter>The parameters of template functions are separated by a whitespace character. If you want to use a longer string or multiple macros as a single parameter, enclose the parameter in double-quotes. For example:</parameter>
            <synopsis>$(echo "$HOST $PROGRAM $PID")</synopsis>
            <para>Template functions can be nested into each other, so the parameter of a template function can be another template function, like:</para>
            <synopsis>$(echo $(echo $HOST))</synopsis>
            <para>For details on using template functions, see the descriptions of the individual template functions in <xref linkend="reference-template-functions"/>.</para>
        </section>
        <section id="reference-template-functions">
            <title>Template functions of &abbrev;</title>
            <para>The following template functions are available in &abbrev;.</para>
            <simplesect id="template-function-echo">
                <title>echo</title>
                    <indexterm type="parameter">
                        <primary>echo</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(echo argument)</synopsis></para>
                <para><guilabel>Description:</guilabel> Returns the value of its argument. using <parameter>$(echo $HOST)</parameter> is equivalent to <parameter>$HOST</parameter>.</para>
            </simplesect>
            <simplesect id="template-function-grep">
                <title>grep</title>
                    <indexterm type="parameter">
                        <primary>grep</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(grep condition value-to-select)</synopsis><!-- FIXME pontositani --></para>
                <para><guilabel>Description:</guilabel> The <parameter>grep</parameter> template function is useful when using a pattern database to correlate related log messages. The <parameter>grep</parameter> template function can be used to filter the messages of the same context when the index of the particular message is not known.</para>
                <example>
                    <title>Using the grep template function</title>
                    <para>The following example selects the message of the context that has a <parameter>username</parameter> name-value pair with the <parameter>root</parameter> value, and returns the value of the <parameter>auth_method</parameter> name-value pair.</para>
                    <synopsis>$(grep ("${username}" == "root") ${auth_method})</synopsis>
                </example>
                <para>It is possible to specify multiple name-value pairs as parameters, separated with commas. If multiple messages match the condition of <parameter>grep</parameter>, these will be returned also separated by commas. This can be used for example to collect the e-mail recipients from postfix messages.</para>
                <!-- FIXME konkret peldat! -->
            </simplesect>
            <simplesect id="template-function-if">
                <title>if</title>
                    <indexterm type="parameter">
                        <primary>if</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(if (&lt;condition&gt;) &lt;true template&gt; &lt;false template&gt;)</synopsis></para>
                <para><guilabel>Description:</guilabel> Returns the value of the <parameter>&lt;true template&gt;</parameter> parameter if the <parameter>&lt;condition&gt;</parameter> is true. If the <parameter>&lt;condition&gt;</parameter> is false, the value of <parameter>&lt;false template&gt;</parameter> is returned.</para>
                <example>
                    <title>Using pattern databases and the if template function</title>
                    <para>The following example returns <parameter>violation</parameter> if the <parameter>username</parameter> name-value pair of a message processed with pattern database is <parameter>root</parameter>, and <parameter>system</parameter> otherwise.</para>
                    <synopsis>$(if ("${username}" == "root") "violation" "system")</synopsis>
                    <para>This can be used to set the class of a message in pattern database rules based on the condition.</para>
                    <synopsis>&lt;value name="username"&gt;$(if ("${username}" == "root") "violation" "system")&lt;/value&gt;</synopsis>
                    <indexterm>
                        <primary>template functions</primary>
                        <secondary>embedding</secondary>
                    </indexterm>
                    <para>Since template functions can be embedded into each other, it is possible to use another template function as the template of the first one. For example, the following expression returns <parameter>root</parameter> if the username is <parameter>root</parameter>, <parameter>admin</parameter> if the username is <parameter>joe</parameter>, and <parameter>normal user</parameter> otherwise.</para>
                    <synopsis>&lt;value name="username"&gt;
        $(if ("${username}" == "root") 
            "root" 
            $(if ("${usracct.username}" == "joe") "admin" "normal user") 
            "normal user")&lt;/value&gt;</synopsis>
                </example>
            </simplesect>
            <simplesect id="template-function-ipv4-to-int">
                <title>ipv4-to-int</title>
                    <indexterm type="parameter">
                        <primary>ipv4-to-int</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(ipv4-to-int parameter)</synopsis></para>
                <para><guilabel>Description:</guilabel> Converts the specified IPv4 address to its numeric representation.</para>
                <!-- FIXME peldat-->
                <note>
                    <para>This template function is available only if the <filename>convertfuncs</filename> module has been loaded. By default, &abbrev; loads every available module.</para>
                    <!-- FIXME link a modulokrol szolo leirasra-->
                </note>
            </simplesect>
        </section>
    </section>
    <section id="modifying-messages">
        <title>Modifying messages</title>
        <indexterm>
            <primary>rewriting messages</primary>
            <secondary>concepts of</secondary>
        </indexterm>
        <indexterm>
            <primary>rewrite rules</primary>
        </indexterm>
        <indexterm>
            <primary>rewriting messages</primary>
        </indexterm>
        <indexterm>
            <primary>sedding messages</primary>
        </indexterm>
        <indexterm>
            <primary>replacing message text</primary>
        </indexterm>
        <para>The syslog-ng application can rewrite parts of the messages using rewrite rules. Rewrite rules are global objects similar to parsers and filters and can be used in log paths. The syslog-ng application has two methods to rewrite parts of the log messages: substituting (setting) a part of the message to a fix value, and a general search-and-replace mode.</para>
        <para>Substitution completely replaces a specific part of the message that is referenced using a built-in or user-defined macro.</para>
        <para>General rewriting searches for a string in the entire message (or only a part of the message specified by a macro) and replaces it with another string. Optionally, this replacement string can be a template that contains macros.</para>
        <para>Rewriting messages
            is often used in conjunction with message parsing <xref linkend="configuring_parsers"/>.</para>
        <para>Rewrite rules are similar to filters: they must be defined in the syslog-ng
            configuration file and used in the log statement.</para>
        <!-- FIXME parsert/rewriteot is lehet inline definialni? -->
        <!-- FIXME options should be restructured to simplesects -->
        <note>
            <para>The order of filters, rewriting rules, and parsers in the log statement is
                important, as they are processed sequentially.
                <!-- FIXME bovebben, peldaval, filterekhez/rewrite sectionbe is -->
            </para>
        </note>
        <para>To create replace a part of the log message, define the string or regular expression
            to replace, the string to replace the original text (macros can be used as well), and
            the field of the message that the rewrite rule should process. Substitution rules can
            operate on any value available via macros, for example HOST, MESSAGE, PROGRAM, or any
            user-defined macros created using parsers (see <xref linkend="chapter-csv-parser"/> and 
    <xref linkend="chapter-patterndb"/> for
            details). The only exceptions are the FACILITY, SEVERITY, TAGS, and the date-related fields, which cannot be rewritten. As of syslog-ng 3.1, it is also possible to rewrite the structured-data fields of
            messages complying to the RFC5424 (IETF-syslog) message format. Substitution rules use the following syntax:</para>
        <synopsis>Declaration:
    rewrite &lt;name_of_the_rule&gt; 
            {
            subst("&lt;string or regular expression to find&gt;", 
                "&lt;replacement string&gt;", value(&lt;field name&gt;), flags()
                );
            };</synopsis>
            <indexterm type="parameter">
                <primary>rewrite()</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>subst()</primary>
            </indexterm>
        <para>The <parameter>type()</parameter> and <parameter>flags()</parameter> options are
            optional. The <parameter>type()</parameter> specifies the type of regular expression to
            use; while the <parameter>flags()</parameter> are the flags of the regular expressions.
            For details on regular expressions, see <xref linkend="regular-expressions"/>.</para>
        <para>A single substitution rule can include multiple substitutions that are applied
            sequentially to the message. Note that rewriting rules must be included in the log
            statement to have any effect.</para>
        <tip>
            <!-- FIXME ez le van irva valahol mashol is, ill. le kellene legyen -->
            <para>For case-insensitive searches, add the <parameter>flags(ignore-case)</parameter>
                option; to replace every occurrence of the string, add
                <parameter>flags(global)</parameter> option.</para>
        </tip>
        <example id="example_rewrite_subst">
            <title>Using substitution rules</title>
            <para>The following example replaces the first occurrence of the string
                <parameter>IP</parameter> in the text of the message with the string
                <parameter>IP-Address</parameter>.</para>
            <synopsis>rewrite r_rewrite_subst{subst("IP", "IP-Address", value("MESSAGE"));};</synopsis>
            <para>To replace every occurrence, use:</para>
            <synopsis>rewrite r_rewrite_subst{subst("IP", "IP-Address", value("MESSAGE"), flags("global"));};</synopsis>
            <para>Multiple substitution rules are applied sequentially; the following rules replace
                the first occurrence of the string <parameter>IP</parameter> with the string
                <parameter>IP-Addresses</parameter>. </para>
            <synopsis>rewrite r_rewrite_subst{subst("IP", "IP-Address", value("MESSAGE")); subst("Address", "Addresses", value("MESSAGE"));};</synopsis>
        </example>
        <indexterm>
            <primary>setting message fields</primary>
        </indexterm>
        <para>To set a field of the message to a specific value, define the string to include in the
            message, and the field where it should be included. Setting a field can operate on any
            value available via macros, for example HOST, MESSAGE, PROGRAM, or any user-defined macros
            created using parsers (see <xref linkend="chapter-csv-parser"/> and <xref linkend="chapter-patterndb"/> for details). The only exceptions are the FACILITY, SEVERITY, TAGS, and the date-related fields, which cannot be rewritten. Note that
            the rewrite operation completely replaces any previous value of that field. Use the following
            syntax:</para>
        <synopsis>Declaration:
            rewrite &lt;name_of_the_rule&gt;
                {set("&lt;string to include&gt;", value(&lt;field name&gt;));};</synopsis>
        <indexterm type="parameter">
            <primary>set()</primary>
        </indexterm>
        <example id="example_rewrite_set">
            <title>Setting message fields to a particular value</title>
            <para>The following example sets the HOST field of the message to
                <parameter>myhost</parameter>. </para>
            <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST"));};</synopsis>
            <para>The following example sets the sequence ID field of the RFC5424-formatted
                (IETF-syslog) messages to a fixed value.</para>
            <synopsis>rewrite r_sd { set("55555" value(".SDATA.meta.sequenceId")); };</synopsis>
            <para>It is also possible to set the value of a field that does not exist yet, and create a new name-value pair that is associated with the message. The following example created the <parameter>MODIFIED</parameter> field and sets its value to <parameter>yes</parameter>. If you use the <parameter>$MODIFIED</parameter> macro in a template or SQL table, its value will be <parameter>yes</parameter> for every message that was processed with this rewrite rule, and empty for every other message.</para>
            <synopsis>rewrite r_rewrite_set{set("yes", value("MODIFIED"));};</synopsis>
        </example>
        <section id="conditional-rewrite">
            <title>Conditional rewrites</title>
            <indexterm type="parameter">
                <primary>condition()</primary>
            </indexterm>
            <indexterm>
                <primary>conditional rewrites</primary>
            </indexterm>
            <indexterm>
                <primary>rewrite if</primary>
            </indexterm>
            <indexterm>
                <primary>rewriting messages</primary>
                <secondary>conditional rewrites</secondary>
            </indexterm>
            <indexterm>
                <primary>filtering rewrites</primary>
            </indexterm>
            <para>Starting with version 3.2, it is possible to apply a rewrite rule to a message only if certain conditions are met. The <parameter>condition()</parameter> option effectively embeds a filter expression into the rewrite rule: the message is modified only if the message passes the filter. If the condition is not met, the message is passed to the next element of the log path (that is, the element following the rewrite rule in the log statement, for example, the destination). Any filter expression normally used in filters can be used as a rewrite condition. Existing filter statements can be referenced using the <parameter>filter()</parameter> function within the condition.</para>
            <tip>
                <para>Using conditions in rewrite rules can simplify your &abbrev; configuration file, as you do not need to create separate log paths to modify certain messages.</para>
            </tip>
            <example id="example-conditional-rewrite">
                <title>Using conditional rewriting</title>
                <para>The following example sets the HOST field of the message to
                <parameter>myhost</parameter> only if the message was sent by the <parameter>myapplication</parameter> program.</para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST") condition(program("myapplication")));};</synopsis>
                <para>The following example is identical to the previous one, except that the condition references an existing filter template.</para>
                <synopsis>filter f_rewritefilter {program("myapplication");};
rewrite r_rewrite_set{set("myhost", value("HOST") condition(filter(f_rewritefilter)));};</synopsis>
            </example>
        </section>
    </section>
    <section id="regular-expressions">
        <title>Regular expressions</title>
        <indexterm significance="preferred">
            <primary>regular expressions</primary>
        </indexterm>
        <indexterm type="parameter">
            <primary>type()</primary>
        </indexterm>
        <para>Filters and substitution rewrite rules can use regular expressions. In regular expressions, the characters <parameter>()[].*?+^$|\</parameter> are used as special symbols. Depending on how you want to use these characters and which quotation mark you use, these characters must be used differently, as summarized below.</para>
        <itemizedlist>
            <listitem>
                <para>Strings between single quotes (<parameter>'string'</parameter>) are
                    treated literally, you do not have to escape special characters. This makes
                    writing and reading regular expressions much more simple: it is recommended
                    to use single quotes when writing regular expressions.</para>
            </listitem>
            <listitem>
                <para>When enclosing strings between double-quotes (<parameter>"string"</parameter>), you have to escape special characters, that is, to precede them with a backslash (<parameter>\</parameter>) character if they are meant literally. For example, the <parameter>\$40</parameter> expression matches the <parameter>$40</parameter> string. Backslashes have to be escaped as well if they are meant literally, for example, the <parameter>\\d</parameter> expression matches the <parameter>\d</parameter> string.</para>
                <tip>
                    <para>If you use single quotes in, you do not need to escape the backslash, for example <parameter>match("\\.")</parameter> is equivalent to <parameter>match('\.')</parameter>.</para>
                </tip>
            </listitem>
            <listitem>
                <para>Enclosing normal strings between double-quotes
                    (<parameter>"string"</parameter>) is not necessary, you can just omit the
                    double-quotes. For example when writing filters,
                    <parameter>match("sometext")</parameter> and
                    <parameter>match(sometext)</parameter> will both match for the
                        <parameter>sometext</parameter> string.</para>
            </listitem>
        </itemizedlist>
        <indexterm>
            <primary>regular expressions</primary>
            <secondary>case-insensitive</secondary>
        </indexterm>
        <indexterm>
            <primary>regular expressions</primary>
            <secondary>escaping</secondary>
        </indexterm>
        <indexterm>
            <primary>escaping special characters</primary>
        </indexterm>
        <para>By default, all regular expressions are case sensitive. To disable the case
            sensitivity of the expression, add the <parameter>flags(ignore-case)</parameter> option
            to the regular expression.</para>
        <synopsis>filter demo_regexp_insensitive { host("system" flags(ignore-case)); };</synopsis>
        <para>The regular expressions can use up to 255 regexp matches (<parameter>${1} ... ${255}</parameter>), but only from the last filter and only if the <parameter>flags("store-matches")</parameter> flag was set for the filter. For case-insensitive searches, use the <parameter>flags("ignore-case")</parameter> option.</para>
        
        <section id="reference_regexp_types">
            <title>Types and options of regular expressions</title>
            <para>By default, syslog-ng uses POSIX-style regular expressions. To use other expression types, add the
                <parameter>type()</parameter> option after the regular expression.</para>
            <para>The &abbrev; application supports the following expression types:</para>
            <itemizedlist>
                <listitem>
                    <para><link linkend="reference_regexp_posix">POSIX regular expressions</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference_regexp_pcre">Perl Compatible Regular Expressions (PCRE)</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference_regexp_string">Literal string searches</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference_regexp_glob">Glob patterns without regular expression support</link></para>
                </listitem>
            </itemizedlist>
        <simplesect id="reference_regexp_posix">
            <title>posix</title>
                <indexterm type="parameter">
                    <primary>posix</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Use POSIX regular expressions. If the <parameter>type()</parameter>
                parameter is not specified, syslog-ng uses POSIX regular expressions by
                default.</para>
                <para>Posix regular expressions have the following flag options:</para>
        <formalpara>
            <title>global:</title>
                <indexterm type="parameter">
                    <primary>global</primary>
                </indexterm>
            <para>Usable only in rewrite rules; match for every occurrence of the
                expression, not only the first one.</para>
        </formalpara>
        <formalpara>
            <title>ignore-case:</title>
                <indexterm type="parameter">
                    <primary>ignore-case</primary>
                </indexterm>
            <para>Disable case-sensitivity.</para>
        </formalpara>
        <!--<row>
            <entry>newline</entry>
            <entry></entry>
            </row>-->
        <formalpara>
            <title>store-matches:</title>
                <indexterm type="parameter">
                    <primary>store-matches</primary>
                </indexterm>
            <para>Store the matches of the regular expression into the <parameter>$1,
                ... $255</parameter> variables. Matches from the last filter
                expression can be referenced in regular expressions.</para>
        </formalpara>
        <formalpara>
            <title>utf8:</title>
                <indexterm type="parameter">
                    <primary>utf8</primary>
                </indexterm>
            <para>Use UTF-8 matching.</para>
        </formalpara>
        <example id="example_regexp_posix">
            <title>Using Posix regular expressions</title>
            <synopsis>filter f_message { message("keyword" flags("utf8" "ignore-case") );</synopsis>
        </example>
        </simplesect>
        <simplesect id="reference_regexp_pcre">
            <title>pcre</title>
                <indexterm type="parameter">
                    <primary>pcre</primary>
                </indexterm>
                <indexterm>
                    <primary>regular expressions</primary>
                    <secondary>pcre</secondary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Use Perl Compatible Regular Expressions (PCRE). PCRE expressions can be used if &abbrev; was compiled with the <parameter>--enable-pcre</parameter> option enabled. Execute
                the <command>syslog-ng -V</command> command to check if your binary 
                supports PCRE regular expressions. Starting with &abbrev; version 3.1, PCRE expressions are supported on every platform.</para>
            <para>PCRE regular expressions have the following flag options:</para>
        <formalpara>
            <title>global:</title>
                <indexterm type="parameter">
                    <primary>global</primary>
                </indexterm>
            <para>Usable only in rewrite rules; match for every occurrence of the
                expression, not only the first one.</para>
        </formalpara>
        <formalpara>
            <title>ignore-case:</title>
                <indexterm type="parameter">
                    <primary>ignore-case</primary>
                </indexterm>
            <para>Disable case-sensitivity.</para>
        </formalpara>
        <!--<row>
            <entry>newline</entry>
            <entry>Process the string until the end of the string, ignoring newline
            characters.</entry>
            </row>-->
        <formalpara>
            <title>nobackref:</title>
                <indexterm type="parameter">
                    <primary>nobackref</primary>
                </indexterm>
            <para>Do not store back references for the matches &mdash; improves
                performance.</para>
        </formalpara>
        <formalpara>
            <title>store-matches:</title>
                <indexterm type="parameter">
                    <primary>store-matches</primary>
                </indexterm>
            <para>Store the matches of the regular expression into the <parameter>$1,
                ... $255</parameter> variables. Named matches (also called named
                subpatterns), for example <parameter>(?&lt;name&gt;...)</parameter>,
                are stored as well. Matches from the last filter expression can be
                referenced in regular expressions.</para>
        </formalpara>
        <formalpara>
            <title>unicode:</title>
                <indexterm type="parameter">
                    <primary>unicode</primary>
                </indexterm>
            <para>Use Unicode support for UTF-8 matches: UTF-8 character sequences are
                handled as single characters.</para>
        </formalpara>
        <formalpara>
            <title>utf8:</title>
                <indexterm type="parameter">
                    <primary>utf8</primary>
                </indexterm>
            <para>An alias for the <parameter>unicode</parameter> flag.</para>
        </formalpara>
        <example id="example_regexp_pcre">
            <title>Using PCRE regular expressions</title>
            <synopsis>rewrite r_rewrite_subst 
        {subst("a*", "?", field("message") type("pcre") flags("utf8" "global"));};</synopsis>
        </example>
        </simplesect>
        <simplesect id="reference_regexp_string">
            <title>string</title>
                <indexterm type="parameter">
                    <primary>string</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Match the strings literally, without regular expression support. By
                default, only identical strings are matched. For partial matches, use
                the <parameter>flags("prefix")</parameter> or the
                <parameter>flags("substring")</parameter> flags.</para>
        </simplesect>
        <simplesect id="reference_regexp_glob">
            <title>glob</title>
            <indexterm type="parameter">
                    <primary>glob</primary>
            </indexterm>
            <indexterm>
                <primary>glob patterns</primary>
            </indexterm>
            <para><guilabel>Description:</guilabel> Use glob patterns (that is, wildcards and character ranges) without regular expression support. The advantage of glob patterns to regular expressions is that globs can be processed much faster. For details on glob patterns, see the <emphasis>glob manual page</emphasis> (<command>man glob</command>).</para>
        </simplesect>
        </section>
        <section id="optimizing-regular-expressions">
            <title>Optimizing regular expressions</title>
            <indexterm>
                <primary>filters</primary>
            </indexterm>
            <indexterm>
                <primary>regular expressions</primary>
            </indexterm>
            <indexterm>
                <primary>optimizing regular expressions</primary>
            </indexterm>
            <indexterm>
                <primary>optimizing syslog-ng performance</primary>
                <secondary>regular expressions</secondary>
            </indexterm>
            <para>The <parameter>host()</parameter>, <parameter>match()</parameter>, and <parameter>program()</parameter> filter functions and some other syslog-ng objects accept regular expressions as parameters. But evaluating
                general regular expressions puts a high load on the CPU, which can cause problems
                when the message traffic is very high. Often the regular expression can be replaced
                with simple filter functions and logical operators. Using simple filters and logical
                operators, the same effect can be achieved at a much lower CPU load.</para>
            <example>
                <title>Optimizing regular expressions in filters</title>
                <para>Suppose you need a filter that matches the following error message logged by
                    the <parameter>xntpd</parameter> NTP daemon:</para>
                <synopsis>xntpd[1567]: time error -1159.777379 is too large (set clock manually);</synopsis>
                <para>The following filter uses regular expressions and matches every instance and
                    variant of this message.</para>
                <synopsis>filter f_demo_regexp {
    program("demo_program") and
    match("time error .* is too large .* set clock manually"); };</synopsis>
                <para>Segmenting the <parameter>match()</parameter> part of this filter into
                    separate <parameter>match()</parameter> functions greatly improves the
                    performance of the filter. </para>
                <synopsis>filter f_demo_optimized_regexp {
    program("demo_program") and
    match("time error") and 
    match("is too large") and 
    match("set clock manually"); };</synopsis>
            </example>
        </section>
    </section>
</chapter>
