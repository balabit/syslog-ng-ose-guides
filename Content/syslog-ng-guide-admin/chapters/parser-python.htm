<?xml version="1.0" encoding="UTF-8"?>

<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><body name="python-parser" oldrole="section">
<h1 name="python-parser" version="5.0" xmlns="http://docbook.org/ns/docbook">The Python Parser</h1>
<MadCap:keyword term="segmenting messages"></MadCap:keyword>
<MadCap:keyword term="python parser"></MadCap:keyword>
<MadCap:keyword term="custom python parser"></MadCap:keyword>
<MadCap:keyword term="parsers:['python']"></MadCap:keyword>
<p oldrole="para">The Python Log Parser (available in <MadCap:variable name="General.abbrev"></MadCap:variable> version <MadCap:conditionaltext MadCap:conditions="ose">3.10</MadCap:conditionaltext><MadCap:conditionaltext MadCap:conditions="pe">7.0.2</MadCap:conditionaltext> and later) allows you to write your own parser in Python. Practically, that way you can process the log message (or parts of the log message) any way you need. For example, you can import external Python modules to process the messages, query databases to enrich the messages with additional data, and many other things.</p>
<MadCap:snippetBlock src="../../shared/chunk/python-blocks.htm"></MadCap:snippetBlock>
<h6 oldrole="formalpara">Declaration:</h6>

<p oldrole="para">Python parsers consist of two parts. The first is a <MadCap:variable name="General.abbrev"></MadCap:variable> parser object that you use in your <MadCap:variable name="General.abbrev"></MadCap:variable> configuration, for example, in the log path. This parser references a Python class, which is the second part of the Python parsers. The Python class processes the log messages it receives, and can do virtually anything that you can code in Python.</p>
<pre class="Code" oldrole="synopsis">parser &lt;name_of_the_python_parser&gt;{
  python(
    class("&lt;name_of_the_python_class_executed_by_the_parser&gt;")
  );
};

python {
import re
class MyParser(object):
    def init(self, options):
        '''Optional. This method is executed when syslog-ng is started or reloaded.'''
        return True
    def deinit(self):
        '''Optional. This method is executed when syslog-ng is stopped or reloaded.'''
        return True
    def parse(self, msg):
        '''Required. This method receives and processes the log message.'''
        return True
};</pre>

<h6 name="python-parser-methods" oldrole="simplesect">Methods of the python() parser</h6>
<h6 oldrole="formalpara">The <span class="Code" oldrole="parameter">init (self, options)</span> method (optional)</h6>

<p oldrole="para">The <MadCap:variable name="General.abbrev"></MadCap:variable> application initializes Python objects only when it is started or reloaded. That means it keeps the state of internal variables while <MadCap:variable name="General.abbrev"></MadCap:variable> is running. The <span class="Code" oldrole="parameter">init</span> method is executed as part of the initialization. You can perform any initialization steps that are necessary for your parser to work. For example, if you want to perform a lookup from a file or a database, you can open the file or connect to the database here, or you can initialize a counter that you will increase in the <span class="Code" oldrole="parameter">parse()</span> method.</p>
<p oldrole="para">The return value of the <span class="Code" oldrole="parameter">init()</span> method must be <span class="Code" oldrole="userinput">True</span>. If it returns <span class="Code" oldrole="userinput">False</span>, or raises an exception, <MadCap:variable name="General.abbrev"></MadCap:variable> will not start.</p>
<p oldrole="para"><span class="Code" oldrole="userinput">options</span>: This optional argument contains the contents of the <span class="Code" oldrole="parameter">options()</span> parameter of the parser object as a Python dict.</p>
<pre class="Code" oldrole="synopsis">parser my_python_parser{
  python(
    class("MyParser")
    options("regex", "seq: (?P&lt;seq&gt;\\d+), thread: (?P&lt;thread&gt;\\d+), runid: (?P&lt;runid&gt;\\d+), stamp: (?P&lt;stamp&gt;[^ ]+) (?P&lt;padding&gt;.*$)")
  );
};
class MyParser(object):
    def init(self, options):
        pattern = options["regex"]
        self.regex = re.compile(pattern)
        self.counter = 0
        return True</pre>
<h6 oldrole="formalpara">The <span class="Code" oldrole="parameter">parse(self, log_message)</span> method</h6>

<p oldrole="para">The <span class="Code" oldrole="parameter">parse()</span> method processes the log messages it receives, and can do virtually anything that you can code in Python. This method is required, otherwise <MadCap:variable name="General.abbrev"></MadCap:variable> will not start.</p>
<p oldrole="para">The return value of the <span class="Code" oldrole="parameter">parse()</span> method must be <span class="Code" oldrole="userinput">True</span>. If it returns <span class="Code" oldrole="userinput">False</span>, or raises an exception, <MadCap:variable name="General.abbrev"></MadCap:variable> will drop the message.</p>
<MadCap:snippetBlock src="../../shared/chunk/python-blocks-nvpairs.htm"></MadCap:snippetBlock>
<h6 oldrole="formalpara">The <span class="Code" oldrole="parameter">deinit(self)</span> method (optional)</h6>

<p oldrole="para">This method is executed when <MadCap:variable name="General.abbrev"></MadCap:variable> is stopped or reloaded.</p>
<MadCap:snippetBlock src="../../shared/wnt/warning-python-parser-deinit.htm"></MadCap:snippetBlock>


<h6 name="python-parser-example" oldrole="simplesect">Example: Parse loggen logs</h6>
<p oldrole="para">The following sample code parses the messages of the <b oldrole="command">loggen</b> tool (for details, see <MadCap:xref href="#loggen.1"></MadCap:xref>). The following is a sample loggen message:</p>
<pre class="Code" oldrole="synopsis">&lt;38&gt;2017-04-05T12:16:46 localhost prg00000[1234]: seq: 0000000000, thread: 0000, runid: 1491387406, stamp: 2017-04-05T12:16:46 PADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADDPADD</pre>
<p oldrole="para">The <MadCap:variable name="General.abbrev"></MadCap:variable> parser object references the LoggenParser class and passes a set of regular expressions to parse the loggen messages. The <span class="Code" oldrole="userinput">init()</span> method of the LoggenParser class compiles these expressions into a pattern. The <span class="Code" oldrole="userinput">parse</span> method uses these patterns to extract the fields of the message into name-value pairs. The destination template of the <MadCap:variable name="General.abbrev"></MadCap:variable> log statement uses the extracted fields to format the output message.</p>
<!-- FIXME calloutosra megcsinalni a konfigmagyarazatot? -->
<pre class="Code" oldrole="synopsis">@version: <MadCap:variable name="Version.techversion"></MadCap:variable>
@include "scl.conf"
parser my_python_parser{
  python(
    class("LoggenParser")
    options("regex", "seq: (?P&lt;seq&gt;\\d+), thread: (?P&lt;thread&gt;\\d+), runid: (?P&lt;runid&gt;\\d+), stamp: (?P&lt;stamp&gt;[^ ]+) (?P&lt;padding&gt;.*$)")
  );
};
log {
  source { tcp(port(5555)); };
  parser(my_python_parser);
  destination {  file("/tmp/regexparser.log.txt" template("seq: $seq thread: $thread runid: $runid stamp: $stamp my_counter: $MY_COUNTER"));};
};
python {
import re
class LoggenParser(object):
    def init(self, options):
        pattern = options["regex"]
        self.regex = re.compile(pattern)
        self.counter = 0
        return True
    def deinit(self):
        return True
    def parse(self, log_message):
        match = self.regex.match(log_message['MESSAGE'])
        if match:
            for key, value in match.groupdict().items():
                log_message[key] = value
            log_message['MY_COUNTER'] = self.counter
            self.counter += 1
            return True
        return False
};</pre>


<h6 name="python-parser-example-windows-logs" oldrole="simplesect">Example: Parse Windows eventlogs in Python - performance</h6>
<p oldrole="para">The following example uses regular expressions to process Windows log messages received in XML format from the <MadCap:variable name="General.agent"></MadCap:variable> application. The parser extracts different fields from messages received from the Security and the Application eventlog containers. Using the following configuration file, <MadCap:variable name="General.abbrev"></MadCap:variable> could process about 25000 real-life Windows log messages per second.</p>
<pre class="Code" oldrole="synopsis">@version: <MadCap:variable name="Version.techversion"></MadCap:variable>
options {
    keep-hostname(yes);
    keep-timestamp(no);
    stats-level(2);
    use-dns(no);
};
source s_network_aa5fdf25c39d4017a8e504cdb641b477 {
    network(flags(no-parse)
        ip(0.0.0.0)
        log-fetch-limit(1000)
        log-iw-size(100000)
        max-connections(100)
        port(514));
};
parser p_python_parser_79c31da44bb64de6b5de84be4ae15a15 {
    python(options("regex_for_security", ".* Security ID:  (?P&lt;security_id&gt;\\S+)   Account Name:  (?P&lt;account_name&gt;\\S+)   Account Domain:  (?P&lt;account_domain&gt;\\S+)   Logon ID:  (?P&lt;logon_id&gt;\\S+).*Process Name: (?P&lt;process_name&gt;\\S+).*EventID (?P&lt;event_id&gt;\\d+)", "regex_others", "(.*)EventID (?P&lt;event_id&gt;\\d+)")
class("EventlogParser"));
};
destination d_file_78363e1dd90c4ebcbb0ee1eff5a2e310 {
    file("/var/testdb_working_dir/fcd713a2-d48e-4025-9192-ec4a9852cafa.$HOST"
        flush-lines(1000)
        log-fifo-size(200000));
};
log {
    source(s_network_aa5fdf25c39d4017a8e504cdb641b477);
    parser(p_python_parser_79c31da44bb64de6b5de84be4ae15a15);
    destination(d_file_78363e1dd90c4ebcbb0ee1eff5a2e310);

    flags(flow-control);
};

python {
import re
class EventlogParser(object):
    def init(self, options):
        self.regex_security = re.compile(options["regex_for_security"])
        self.regex_others = re.compile(options["regex_others"])
        return True
    def deinit(self):
        return True
    def parse(self, log_message):
        security_match = self.regex_security.match(log_message['MESSAGE'])
        if security_match:
            for key, value in security_match.groupdict().items():
                log_message[key] = value
        else:
            others_match = self.regex_others.match(log_message['MESSAGE'])
            if others_match:
                for key, value in others_match.groupdict().items():
                    log_message[key] = value
        return True
};</pre>

<!--
FIXME whois lookupos pelda webszerver logokra?
-->
</body></html>
