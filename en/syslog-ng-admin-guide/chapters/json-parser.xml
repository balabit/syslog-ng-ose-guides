<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section 
 [  <!ENTITY % entities SYSTEM "../syslog-ng-entities.ent">
 %entities;]>

	<section xml:id="json-parser" condition="ose" xmlns="http://docbook.org/ns/docbook" version="5.0">
		<title>The JSON parser</title>
		<indexterm>
			<primary>segmenting messages</primary>
		</indexterm>
		<indexterm>
			<primary>JSON parsers</primary>
		</indexterm>
		<indexterm>
			<primary>splitting messages</primary>
		</indexterm>
		<para>JavaScript Object Notation (JSON) is a text-based open standard designed  for human-readable data interchange. It is used primarily to transmit data between a server and web application, serving as an alternative to XML. It is described in <ulink url="http://tools.ietf.org/html/rfc4627">RFC 4627</ulink>. The syslog-ng application can separate parts of JSON-encoded log messages to name-value pairs, using json-c.</para>
		<note>
			<para>The JSON parser currently supports only integer, double and string values when interpreting JSON structures. As syslog-ng does not handle different data types internally, the JSON parser converts all JSON data to string values. In case of boolean types, the value is converted to 'TRUE' or 'FALSE' as their string representation.</para>
            <para>The JSON parser discards messages if it cannot parse them as JSON messages, so it acts as a JSON-filter as well.</para>
		</note>
		<para>To create a parser, define the parser name, the parser itself. Defining the prefix and the marker are optional.</para>
		<synopsis>Declaration:
    parser parser_name {
        json-parser(
        marker()
        prefix()
    );
};</synopsis>
		<example>
			<title>Using a JSON parser</title>
			<para>In the following example, the source is a JSON encoded log message. The syslog parser is disabled, so that the syslog-ng does not parse the message: <parameter>flags(no-parse)</parameter>. The json-parser inserts "<parameter>.json.</parameter>" before all extracted name-value pairs. The destination is a file, that uses the JSON template function. Here, the dot-nv-pairs are written, that include name-value pairs beginning with a dot ("<parameter>.</parameter>"). The log line connects the source, the destination and the parser.</para>
			<synopsis>source s_json {
    tcp(port(21514) flags(no-parse));
};

destination d_json {
    file("/tmp/test.json"
        template("$(format-json --scope dot-nv-pairs)\n"));
};

parser p_json {
    json-parser (prefix(".json."));
};

log {
    source(s_json);
    parser(p_json);
    destination(d_json);
};</synopsis>
		</example>
		<simplesect xml:id="json-parser-marker">
			<title>marker</title>
			<indexterm type="parameter">
				<primary>marker</primary>
			</indexterm>
			<informaltable frame="topbot" colsep="0" rowsep="0">
				<tgroup cols="2">
					<colspec colnum="1" colwidth="50pt"/>
					<tbody>
						<row>
							<entry>Synopsis:
								<?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
							<entry>marker()</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para><guilabel>Description:</guilabel> Use a marker in case of mixed log messages, to identify JSON encoded messages for the parser.</para>
            <para>Some logging implementations require a marker to be set before the JSON payload. The JSON parser is able to find these markers and parse the message only if it is present.</para>
            <example>
                <title>Using the marker option in JSON parser</title>
                <para>This json parser parses log messages which use the "@cee:" marker in front of the json payload. It inserts ".cee." in front of the name of name-value pairs, so later on it is easier to find name-value pairs that were parsed using this parser.</para>
                <synopsis>parser {
    json-parser(
        marker("@cee:")
        prefix(".cee.")
    );
};</synopsis>
            </example>
		</simplesect>
		<simplesect xml:id="jdon-parser-prefix">
			<title>prefix</title>
			<indexterm type="parameter">
				<primary>prefix</primary>
			</indexterm>
			<informaltable frame="topbot" colsep="0" rowsep="0">
				<tgroup cols="2">
					<colspec colnum="1" colwidth="50pt"/>
					<tbody>
						<row>
							<entry>Synopsis:
								<?dbhtml bgcolor="#D4D6EB" ?><?dbfo bgcolor="#D4D6EB" ?></entry>
							<entry>prefix()</entry>
						</row>
					</tbody>
				</tgroup>
			</informaltable>
			<para><guilabel>Description:</guilabel> The prefix inserts a prefix before the name part of the name-value pairs to facilitate further processing.</para>
		</simplesect>
	</section>
