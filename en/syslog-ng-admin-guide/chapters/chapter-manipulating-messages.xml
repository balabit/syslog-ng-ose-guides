<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter SYSTEM "../../xml-stylesheet/pdf/dtd/docbookx.dtd"
 [  <!ENTITY % entities SYSTEM "../syslog-ng-entities.ent">
 %entities;]>
<chapter id="chapter-manipulating-messages">
    <title>Manipulating messages</title>
    <para>This chapter explains the methods that you can use to customize, reformat, and modify log messages using &product;.</para>
    <itemizedlist>
        <listitem>
            <para><xref linkend="customizing-message-format"/> explains how to use templates and macros to change the format of log messages, or the names of logfiles and database tables.</para>
        </listitem>
        <listitem>
            <para><xref linkend="modifying-messages"/> describes how to use rewrite rules to search and replace certain parts of the message content.</para>
        </listitem>
        <listitem>
            <para><xref linkend="regular-expressions"/> lists the different types of regular expressions that can be used in various &abbrev; objects like filters and rewrite rules.</para>
        </listitem>
    </itemizedlist>
    <section id="customizing-message-format">
        <title>Customizing message format</title>
        <para>The following sections describe how to customize the names of logfiles, and also how to use templates, macros, and template functions.</para>
        <itemizedlist>
            <listitem>
                <para><xref linkend="concepts_macro"/> explains how macros work.</para>
            </listitem>
            <listitem>
                <para><xref linkend="modifying-messages"/> describes how to use macros and templates to format log messages or change the names of logfiles and database tables.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference_macros"/> lists the different types of macros available in &abbrev;.</para>
            </listitem>
            <listitem>
                <para><xref linkend="template-functions"/> explains what template functions are and how to use them.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-template-functions"/> lists the template functions available in &abbrev;.</para>
            </listitem>
        </itemizedlist>
        <section id="concepts_macro">
            <title>Formatting messages, filenames, directories, and tablenames</title>
            <indexterm>
                <primary>formatting messages</primary>
            </indexterm>
            <indexterm>
                <primary>templates</primary>
            </indexterm>
            <indexterm>
                <primary>message templates</primary>
            </indexterm>
            <indexterm>
                <primary>macros</primary>
            </indexterm>
            <para>The &abbrev; application can dynamically create filenames, directories, or names of database tables using macros that help you organize your log messages. Macros refer to a property or a part of the log message, for example, the <parameter>$HOST</parameter> macro refers to the name or IP address of the client that sent the log message, while <parameter>$DAY</parameter> is the day of the month when syslog-ng has received the message. Using these macros in the path of the destination log files allows you for example to collect the logs of every host into separate files for every day.</para>
            <para>A set of macros can be defined as a template object and used in multiple destinations.</para>
            <para>Another use of macros and templates is to customize the format of the syslog message, for example to add elements of the message header to the message text. Note that if a message uses the IETF-syslog format, only the text of the message can be customized, the structure of the header is fixed.</para>
            <itemizedlist>
                <listitem>
                    <para>For details on using templates and macros, see <xref linkend="configuring_macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For a list and description of the macros available in &abbrev;, see <xref linkend="reference_macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For details on using custom macros created with CSV parsers and pattern databases, see <xref linkend="chapter-parsers"/> and <xref linkend="patterndb-filters"/>, respectively.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section id="configuring_macros">
        <!-- FIXME a template+makro, parser es rewrite sectionoket egy kozos sectionbe kellene tenni, es az elejen
        leirni, hogy hogyan viszonyulnak egymashoz: vannak a makrok, parserrel lehet az uzeneteket sajat makrokra bontani,
        a rewrite meg ezeket tudja atirni-->
        <title>Templates and macros</title>
        <indexterm significance="preferred">
            <primary>templates</primary>
        </indexterm>
        <para>The &abbrev; application allows you to define message templates, and reference them
            from every object that can use a template. Templates can be used for example to create standard
            message formats or filenames. Templates can reference one or more macros (for example date,
            the hostname, and so on). For a list of macros
            available in &product;, see <xref linkend="reference_macros"/>. Fields from the structured data (SD) part of messages using the new
            IETF-syslog standard can also be used as macros.</para>
        <para>Template objects have a single option called <parameter>template_escape</parameter>,
            which is disabled by default (<parameter>template_escape(no)</parameter>). This behavior
            is useful when the messages are passed to an application that cannot handle escaped
            characters properly. Enabling template escaping
            (<parameter>template_escape(yes)</parameter>) causes syslog-ng to escape the
                <parameter>'</parameter>, <parameter>"</parameter>, and backspace characters from the messages.</para>
        <note>
            <para>In versions 2.1 and earlier, the <parameter>template_escape()</parameter> option
                was enabled by default.</para>
        </note>
        <para>Macros can be included by prefixing the macro name with a <parameter>$</parameter> sign, just like in Bourne compatible shells. Although using braces around macro names is not mandatory, and the <parameter>"$MSG"</parameter> and <parameter>"${MSG}"</parameter> formats are equivalent, using the <parameter>"${MSG}"</parameter> format is recommended for clarity. </para>
        <indexterm>
            <primary>macros</primary>
            <secondary>default value</secondary>
        </indexterm>
        <para>Default values for macros can also be specified by appending the
            <parameter>:-</parameter> characters and the default value of the macro. If a message does not contain the field referred to by the macro, or it is empty, the default value will be used when expanding the macro. For example, if a message does not contain a hostname, the following macro can specify a default hostname.</para>
        <synopsis>${HOST:-default_hostname}</synopsis>
        <warning>
            <para>The hostname-related macros (<parameter>FULLHOST</parameter>,
                    <parameter>FULLHOST_FROM</parameter>, <parameter>HOST</parameter>, and
                    <parameter>HOST_FROM</parameter>) do not have any effect if the
                    <parameter>keep_hostname()</parameter>
                    option is disabled.</para>
        </warning>
        <para>By default, syslog-ng sends messages using the following template: <parameter>$ISODATE
                $HOST $MSGHDR$MSG\n</parameter>. (The <parameter>$MSGHDR$MSG</parameter> part is
            written together because the <parameter>$MSGHDR</parameter> macro includes a trailing
            whitespace.)</para>
        <note>
            <para>Earlier versions of syslog-ng used templates and scripts to send log messages into
                SQL databases. Starting from version 2.1, syslog-ng natively supports direct
                database access using the <parameter>sql()</parameter> destination. For details, see <xref
                    linkend="reference_destination_sql"/>.</para>
        </note>
        <indexterm>
            <primary>templates</primary>
            <secondary>defining</secondary>
        </indexterm>
        <example>
            <title>Using templates and macros</title>
            <indexterm>
                <primary>templates</primary>
                <secondary>example</secondary>
            </indexterm>
            <para>The following template (<parameter>t_demo_filetemplate</parameter>) adds the date
                of the message and the name of the host sending the message to the beginning of the
                message text. The template is then used in a file destination: messages sent to this
                destination (<parameter>d_file</parameter>) will use the message format defined in
                the template. </para>
            <synopsis>template t_demo_filetemplate {
             template("$ISODATE $HOST $MSG\n"); template_escape(no); };
destination d_file {
             file("/var/log/messages" template(t_demo_filetemplate)); };</synopsis>
            <para>Templates can also be used inline, if they are used only at a single location. The
                following destination is equivalent with the previous example: </para>
            <synopsis>destination d_file {
                file ("/var/log/messages"
                        template("$ISODATE $HOST $MSG\n") template_escape(no) );
                };
            </synopsis>
            <indexterm>
                <primary>macros</primary>
                <secondary>in filenames</secondary>
            </indexterm>
            <para>The following file destination uses macros to daily create separate logfiles for every client host.</para>
            <synopsis>destination d_file {
        file("/var/log/$YEAR.$MONTH.$DAY/$HOST.log");
};</synopsis>
        </example>
        <note>
            <para>Macros can be used to format messages, and also in the name of destination files or database tables. However, they cannot be used in sources as wildcards, for example, to read messages from files or directories that include a date in their name.</para>
        </note>
        </section>
        <section id="date_macros">
            <title>Date-related macros</title>
            <indexterm>
                <primary>macros</primary>
                <secondary>date-related</secondary>
            </indexterm>
            <para>The macros related to the date of the message (for example: <parameter>ISODATE</parameter>, <parameter>HOUR</parameter>, and so on) have two variants each:</para>
            <itemizedlist>
                <listitem>
                    <para><parameter>S_</parameter> prefix, for example, <parameter>S_DATE</parameter>: The <parameter>S_DATE</parameter> macro represents the date found in the log message, that is, when the message was sent by the original application.</para>
                </listitem>
                <listitem>
                    <para><parameter>R_</parameter> prefix, for example, <parameter>R_DATE</parameter>: <parameter>R_DATE</parameter> is the date when &abbrev; has received the message.</para>
                </listitem>
            </itemizedlist>
            <para>Starting with &abbrev; version <phrase condition="ose">3.2</phrase><phrase condition="pe">4.1</phrase>, the <parameter>DATE</parameter> macro equals the <parameter>S_DATE</parameter> macro. In earlier versions the value of <parameter>DATE</parameter> depended on the <parameter>use_time_recvd()</parameter> global option, which was removed from &abbrev;.</para>
        </section>
        <section id="macros-hard-vs-soft">
            <title>Hard vs. soft macros</title>
            <indexterm>
                <primary>macros</primary>
                <secondary>hard and soft macros</secondary>
            </indexterm>
            <indexterm>
                <primary>hard macros</primary>
            </indexterm>
            <indexterm>
                <primary>soft macros</primary>
            </indexterm>
            <para>Hard macros contain data that is directly derived from the log message, for example, the $MONTH macro derives its value from the timestamp. Hard macros are read-only. Soft macros (sometimes also called name-value pairs) are either built-in macros automatically generated from the log message (for example, $HOST), or custom user-created macros generated by using the syslog-ng pattern database or a CSV-parser. In contrast to hard macros, soft macros are writable and can be modified within &abbrev;, for example, using rewrite rules.</para>
            <para>Hard and soft macros are rather similar and often treated as equivalent. Macros are most commonly used in filters and templates, which does not modify the value of the macro, so both soft and hard macros can be used. However, it is not possible to change the values of hard macros in rewrite rules or via any other means.</para>
            <para>The following macros in &abbrev; are hard macros and cannot be modified: <parameter>BSDTAG</parameter>, <parameter>CONTEXT_ID</parameter>, <parameter>DATE</parameter>, <parameter>DAY</parameter>, <parameter>FACILITY_NUM</parameter>, <parameter>FACILITY</parameter>, <parameter>FULLDATE</parameter>, <parameter>HOUR</parameter>, <parameter>ISODATE</parameter>, <parameter>LEVEL_NUM</parameter>, <parameter>LEVEL</parameter>, <parameter>MIN</parameter>, <parameter>MONTH_ABBREV</parameter>, <parameter>MONTH_NAME</parameter>, <parameter>MONTH</parameter>, <parameter>MONTH_WEEK</parameter>, <parameter></parameter>, <parameter>PRIORITY</parameter>, <parameter>PRI</parameter>, <parameter>SDATA</parameter>, <parameter>SEC</parameter>, <parameter>SEQNUM</parameter>, <parameter>SOURCEIP</parameter>, <parameter>STAMP</parameter>, <parameter>TAG</parameter>, <parameter>TAGS</parameter>, <parameter>TZOFFSET</parameter>, <parameter>TZ</parameter>, <parameter>UNIXTIME</parameter>, <parameter>WEEK_DAY_ABBREV</parameter>, <parameter>WEEK_DAY_NAME</parameter>, <parameter>WEEK_DAY</parameter>, <parameter>WEEK</parameter>, <parameter>YEAR_DAY</parameter>, <parameter>YEAR</parameter>.</para>
            <para>The following macros can be modified:<parameter>FULLHOST_FROM</parameter>, <parameter>FULLHOST</parameter>, <parameter>HOST_FROM</parameter>, <parameter>HOST</parameter>, <parameter>LEGACY_MSGHDR</parameter>, <parameter>MESSAGE</parameter>, <parameter>MSG</parameter>,<parameter>MSGID</parameter>, <parameter>MSGONLY</parameter>, <parameter>PID</parameter>, <parameter>PROGRAM</parameter>, <parameter>SOURCE</parameter>. Custom values created using rewrite rules or parsers can be modified as well, just like stored matches of regular expressions ($0 ... $255).</para>
        </section>
        <section id="reference_macros">
        <title>Macros of &abbrev;</title>
        <indexterm>
            <primary>macros</primary>
            <secondary>reference</secondary>
        </indexterm>
        <para>The following macros are available in &abbrev;.</para>
        <simplesect>
            <title>BSDTAG</title>
                <indexterm type="parameter">
                    <primary>BSDTAG</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$BSDTAG</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Facility/priority information in the format used by the FreeBSD
                syslogd: a priority number followed by a letter that indicates the
                facility. The priority number can range from <parameter>0</parameter> to
                <parameter>7</parameter>. The facility letter can range from
                <parameter>A</parameter> to <parameter>Y</parameter>, where
                <parameter>A</parameter> corresponds to facility number zero
                (LOG_KERN), <parameter>B</parameter> corresponds to facility 1
                (LOG_USER), and so on.</para>
        </simplesect>
        <simplesect id="macro_custom">
            <title>Custom macros</title>
                <indexterm type="parameter">
                    <primary>Custom macros</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> CSV parsers and pattern databases can also define macros from the content of the messages, for example, a pattern database rule can extract the username from a login message and create a macro that references the username. For details on using custom macros created with CSV parsers and pattern databases, see <xref linkend="chapter-parsers"/> and <xref linkend="patterndb-filters"/>, respectively.</para>
        </simplesect>
        <simplesect id="macro_date">
            <title>DATE, R_DATE, S_DATE</title>
                <indexterm type="parameter">
                    <primary>DATE, R_DATE, S_DATE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$DATE, $R_DATE, $S_DATE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Date of the message using the BSD-syslog style timestamp format
                (month/day/hour/minute/second, each expressed in two digits). This is
                the original syslog time stamp without year information, for example:
                <parameter>Jun 13 15:58:00</parameter>.</para>
        </simplesect>
        <simplesect id="macro_day">
            <title>DAY, R_DAY, S_DAY</title>
                <indexterm type="parameter">
                    <primary>DAY, R_DAY, S_DAY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$DAY, $R_DAY, $S_DAY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The day the message was sent.</para>
        </simplesect>
        <simplesect id="macro_facility">
            <title>FACILITY</title>
                <indexterm type="parameter">
                    <primary>FACILITY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FACILITY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name of the facility (for example, <parameter>kern</parameter>) that sent the message.</para>
        </simplesect>
        <simplesect id="macro_facility_num">
            <title>FACILITY_NUM</title>
                <indexterm type="parameter">
                    <primary>FACILITY_NUM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FACILITY_NUM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The numerical code of the facility (for example, <parameter>0</parameter>) that sent the message.</para>
        </simplesect>
        <simplesect id="macro_fulldate">
            <title>FULLDATE, R_FULLDATE, S_FULLDATE</title>
                <indexterm type="parameter">
                    <primary>FULLDATE, R_FULLDATE, S_FULLDATE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FULLDATE, $R_FULLDATE, $S_FULLDATE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> A nonstandard format for the date of the message using the same
                format as <parameter>DATE</parameter>, but including the year as well,
                for example: <parameter>2006 Jun 13 15:58:00</parameter>.</para>
        </simplesect>
        <simplesect>
            <title>FULLHOST</title>
                <indexterm type="parameter">
                    <primary>FULLHOST</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FULLHOST</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The full FQDN of the host name chain (without trimming chained
                hosts), including the domain name. To use this macro, make sure that the
                <parameter>keep_hostname()</parameter> option is enabled.</para>
        </simplesect>
        <simplesect>
            <title>FULLHOST_FROM</title>
                <indexterm type="parameter">
                    <primary>FULLHOST_FROM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$FULLHOST_FROM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> FQDN of the host that sent the message to syslog-ng as resolved by
                syslog-ng using DNS. If the message traverses several hosts, this is the
                last host in the chain. To use this macro, make sure that the <parameter>keep_hostname()</parameter>
                option is enabled.</para>
                <para>The &abbrev; application uses the following procedure to determine the value of the <parameter>$FULLHOST_FROM</parameter> macro:</para>
                <orderedlist>
                    <listitem>
                        <para>The &abbrev; application takes the IP address of the host sending the message.</para>
                    </listitem>
                    <listitem>
                        <para>If the <parameter>use_dns()</parameter> option is enabled, &abbrev; attempts to resolve the IP address to a hostname. If it succeeds, the returned hostname will be the value of the <parameter>$FULLHOST_FROM</parameter> macro.</para>
                    </listitem>
                    <listitem>
                        <para>If the <parameter>use_dns()</parameter> option is disabled, or the address resolution fails, the <parameter>$FULLHOST_FROM</parameter> macro will return the IP address of the sender host.</para>
                    </listitem>
                </orderedlist>
        </simplesect>
        <simplesect id="macro_hour">
            <title>HOUR, R_HOUR, S_HOUR</title>
                <indexterm type="parameter">
                    <primary>HOUR, R_HOUR, S_HOUR</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$HOUR, $R_HOUR, $S_HOUR</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The hour of day the message was sent.</para>
        </simplesect>
        <simplesect id="macro_host">
            <title>HOST</title>
                <indexterm type="parameter">
                    <primary>HOST</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$HOST</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name of the source host where the message originates from.</para>
            <itemizedlist>
                <listitem>
                    <para>If the message traverses several hosts and the <link linkend="option_chain_hostnames"> <parameter>chain_hostnames()</parameter></link> option is on, the first host in the chain is used.</para>
                </listitem>
                <listitem>
                    <para>If the <parameter>keep_hostname()</parameter> option is disabled (<parameter>keep_hostname(no)</parameter>), the value of the $HOST macro will be the DNS hostname of the host that sent the message to &abbrev; (that is, the DNS hostname of the last hop). In this case the $HOST and $HOST_FROM macros will have the same value.</para>
                </listitem>
                <listitem>
                    <para>If the <parameter>keep_hostname()</parameter> option is enabled (<parameter>keep_hostname(yes)</parameter>), the value of the $HOST macro will be the hostname retrieved from the log message. That way the name of the original sender host can be used, even if there are log relays between the sender and the server.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect>
            <title>HOST_FROM</title>
                <indexterm type="parameter">
                    <primary>HOST_FROM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$HOST_FROM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Name of the host that sent the message to syslog-ng, as resolved by
                syslog-ng using DNS. If the message traverses several hosts, this is the
                last host in the chain. To use this macro, make sure that the <parameter>keep_hostname()</parameter>
                option is enabled.</para>
        </simplesect>
        <simplesect id="macro_isodate">
            <title>ISODATE, R_ISODATE, S_ISODATE</title>
                <indexterm type="parameter">
                    <primary>ISODATE, R_ISODATE, S_ISODATE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$ISODATE, $R_ISODATE, $S_ISODATE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Date of the message in the ISO 8601 compatible standard timestamp
                format (yyyy-mm-ddThh:mm:ss+-ZONE), for example:
                <parameter>2006-06-13T15:58:00.123+01:00</parameter>. If possible,
                it is recommended to use <parameter>ISODATE</parameter> for
                timestamping. Note that syslog-ng can produce fractions of a second
                (for example milliseconds) in the timestamp by using the
                <parameter>frac_digits()</parameter> global or per-destination
                option.</para>
        </simplesect>
        <simplesect>
            <title>LEVEL_NUM</title>
                <indexterm type="parameter">
                    <primary>LEVEL_NUM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$LEVEL_NUM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority (also called severity) of the message, represented as a numeric value, for example, <parameter>3</parameter>. For the textual representation of this value, use the <parameter>$LEVEL</parameter> macro. See <xref linkend="macro_priority"/> for details.</para>
        </simplesect>
        <simplesect id="macro_min">
            <title>MIN, R_MIN, S_MIN</title>
                <indexterm type="parameter">
                    <primary>MIN, R_MIN, S_MIN</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MIN, $R_MIN, $S_MIN</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The minute the message was sent.</para>
        </simplesect>
        <simplesect id="macro_month">
            <title>MONTH, R_MONTH, S_MONTH</title>
                <indexterm type="parameter">
                    <primary>MONTH, R_MONTH, S_MONTH</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH, $R_MONTH, $S_MONTH</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The month the message was sent as a decimal value, prefixed with a
                zero if smaller than 10.</para>
        </simplesect>
        <simplesect id="macro_month_abbrev">
            <title>MONTH_ABBREV, R_MONTH_ABBREV, S_MONTH_ABBREV</title>
                <indexterm type="parameter">
                    <primary>MONTH_ABBREV, R_MONTH_ABBREV, S_MONTH_ABBREV</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH_ABBREV, $R_MONTH_ABBREV, $S_MONTH_ABBREV</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The English abbreviation of the month name (3 letters).</para>
        </simplesect>
        <simplesect id="macro_month_name">
            <title>MONTH_NAME, R_MONTH_NAME, S_MONTH_NAME</title>
                <indexterm type="parameter">
                    <primary>MONTH_NAME, R_MONTH_NAME, S_MONTH_NAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH_NAME, $R_MONTH_NAME, $S_MONTH_NAME</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The English name of the month name.</para>
        </simplesect>
        <simplesect id="macro_month_week">
            <title>MONTH_WEEK, R_MONTH_WEEK, S_MONTH_WEEK</title>
                <indexterm type="parameter">
                    <primary>MONTH_WEEK, R_MONTH_WEEK, S_MONTH_WEEK</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MONTH_WEEK, $R_MONTH_WEEK, $S_MONTH_WEEK</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The number of the week in the given month (0-5).
                The week with numerical value 1 is the first week
                containing a Monday. The days of month before the first
                Monday are considered week 0. For example, if a 31-day
                month begins on a Sunday, then the 1st of the month is
                week 0, and the end of the month (the 30th and 31st) is
                week 5.</para>
        </simplesect>
        <simplesect id="macro_msg">
            <title>MSG or MESSAGE</title>
                <indexterm type="parameter">
                    <primary>MSG or MESSAGE</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MSG or $MESSAGE</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Text contents of the log message without the program name and pid.
                Note that this has changed in syslog-ng version 3.0; in earlier versions
                this macro included the program name and the pid. In syslog-ng 3.0, the
                <parameter>MSG</parameter> macro became equivalent with the
                <parameter>MSGONLY</parameter> macro. The program name and the pid
                together are available in the <parameter>MSGHDR</parameter>
                macro.</para>
        </simplesect>
        <simplesect>
            <title>MSGHDR</title>
                <indexterm type="parameter">
                    <primary>MSGHDR</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MSGHDR</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name and the pid of the program that sent the log message in
            	<parameter>PROGRAM[PID]:</parameter> format. Includes a trailing
                whitespace. Note that the macro returns an empty value if both the
                program and pid fields of the message are empty.</para>
        </simplesect>
        <simplesect id="macro_msgid">
            <title>MSGID</title>
                <indexterm type="parameter">
                    <primary>MSGID</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MSGID</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> A string specifying the type of the message in IETF-syslog (RFC5424-formatted) messages. For example, a firewall might use the MSGID "TCPIN" for incoming TCP traffic and the MSGID "TCPOUT" for outgoing TCP traffic. By default, &abbrev; does not specify this value, but uses a dash (-) character instead. If an incoming message includes the MSGID value, it is retained and relayed without modification.</para>
        </simplesect>
        <simplesect>
            <title>MSGONLY</title>
                <indexterm type="parameter">
                    <primary>MSGONLY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$MSGONLY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Message contents without the program name or pid.</para>
        </simplesect>
        <simplesect>
            <title>PID</title>
                <indexterm type="parameter">
                    <primary>PID</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PID</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The PID of the program sending the message.</para>
        </simplesect>
        <simplesect id="macro_pri">
            <title>PRI</title>
                <indexterm type="parameter">
                    <primary>PRI</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PRI</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority and facility encoded as a 2 or 3 digit decimal number as
                it is present in syslog messages.</para>
        </simplesect>
        <simplesect id="macro_priority">
            <title>PRIORITY or LEVEL</title>
                <indexterm type="parameter">
                    <primary>PRIORITY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>LEVEL</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PRIORITY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$LEVEL</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority (also called severity) of the message, for example, <parameter>error</parameter>. For the textual representation of this value, use the <parameter>$LEVEL</parameter> macro. See <xref linkend="macro_priority"/> for details.</para>
        </simplesect>
        <simplesect>
            <title>PROGRAM</title>
                <indexterm type="parameter">
                    <primary>PROGRAM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$PROGRAM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The name of the program sending the message. Note that the content of
                the $PROGRAM variable may not be completely trusted as it is provided by
                the client program that constructed the message.</para>
        </simplesect>
        <simplesect id="macro_sdata">
            <title>SDATA, .SDATA.SDID.SDNAME</title>
                <indexterm type="parameter">
                    <primary>.SDATA.SDID.SDNAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>SDATA</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$.SDATA.SDID.SDNAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SDATA</primary>
                </indexterm>
                <indexterm>
                    <primary>STRUCTURED-DATA</primary>
                </indexterm>
                <indexterm>
                    <primary>macros</primary>
                    <secondary>SDATA</secondary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The syslog-ng application automatically parses the STRUCTURED-DATA
                part of IETF-syslog messages, which can be referenced in macros. The <parameter>$SDATA</parameter> macro references the entire STRUCTURED-DATA part of the message, while structured data elements can be referenced using the <parameter>$.SDATA.SDID.SDNAME</parameter> macro.</para>
                <note>
                    <para>When using STRUCTURED-DATA macros, consider the following:</para>
                    <itemizedlist>
                        <listitem>
                            <para>When referencing an element of the structured data, the macro must begin with the dot (.) character. For example, <parameter>$.SDATA.timeQuality.isSynced</parameter>.</para>
                        </listitem>
                        <listitem>
                            <para>The SDID and SDNAME parts of the macro names are case sensitive: <parameter>$.SDATA.timeQuality.isSynced</parameter> is not the same as <parameter>$.SDATA.TIMEQUALITY.ISSYNCED</parameter>.</para>
                        </listitem>
                    </itemizedlist>
                </note>
                <example>
                    <title>Using SDATA macros</title>
                    <para>For example, if a log message contains the following structured data:
                <parameter>[exampleSDID@0 iut="3" eventSource="Application"
                    eventID="1011"][examplePriority@0 class="high"]</parameter> you can
                use macros like: <parameter>${.SDATA.exampleSDID@0.eventSource}</parameter> &mdash; this would return the <parameter>Application</parameter> string in this case.</para>
                </example>
        </simplesect>
        <simplesect id="macro_sec">
            <title>SEC, R_SEC, S_SEC</title>
                <indexterm type="parameter">
                    <primary>SEC, R_SEC, S_SEC</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SEC, $R_SEC, $S_SEC</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The second the message was sent.</para>
        </simplesect>
        <simplesect id="macro_seqnum">
            <title>SEQNUM</title>
                <indexterm type="parameter">
                    <primary>SEQNUM</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SEQNUM</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The sequence number of the message is a unique identifier of the
                message between the end-points. The syslog-ng client calculates this
                number when processing a new message from a local source; it is not
                calculated for relayed messages. The sequence number increases for every
                message, and is not lost even if syslog-ng is reloaded. The sequence number starts again from 0 when &abbrev; is restarted. The
                sequence number is a part of every message that uses the new IETF-syslog
                protocol (<parameter>.SDATA.meta.sequenceId</parameter>), and can be
                added to BSD-syslog messages using this macro.</para>
        </simplesect>

        <!-- FIXME kellene rola leiras/concept esetleg -->

        <simplesect>
            <title>SOURCEIP</title>
                <indexterm type="parameter">
                    <primary>SOURCEIP</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$SOURCEIP</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> IP address of the host that sent the message to syslog-ng. (That is, the
                IP address of the host in the <parameter>FULLHOST_FROM</parameter>
                macro.) Please note that when a message traverses several relays, this
                macro contains the IP of the last relay.</para>
        </simplesect>
        <simplesect id="macro_stamp">
            <title>STAMP, R_STAMP, S_STAMP</title>
                <indexterm type="parameter">
                    <primary>STAMP, R_STAMP, S_STAMP</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$STAMP, $R_STAMP, $S_STAMP</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> A timestamp formatted according to the <link linkend="reference_options">
                <parameter>ts_format()</parameter>
            </link> global or per-destination option.</para>
        </simplesect>
        <simplesect id="macro_tag">
            <title>TAG</title>
                <indexterm type="parameter">
                    <primary>TAG</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TAG</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The priority and facility encoded as a 2 digit hexadecimal number.</para>
        </simplesect>
        <simplesect id="macro_tags">
            <title>TAGS</title>
                <indexterm type="parameter">
                    <primary>TAGS</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TAGS</primary>
                </indexterm>
                <indexterm>
                    <primary>macros</primary>
                    <secondary>patterndb tags</secondary>
                </indexterm>
                <indexterm>
                    <primary>tags</primary>
                    <secondary>as macro</secondary>
                </indexterm>
            <para><guilabel>Description:</guilabel> A comma-separated list of the tags assigned to the message.</para>
            <note>
                <para>Note that the tags are not part of the log message and are not automatically transferred from a client to the server. For example, if a client uses a pattern database to tag the messages, the tags are not transferred to the server. A way of transferring the tags is to explicitly add them to the log messages using a template and the <parameter>$TAGS</parameter> macro, or to add them to the structured metadata part of messages when using the IETF-syslog message format.</para>
                <para>When sent as structured metadata, it is possible to reference to the list of tags on the central server, and for example, to add them to a database column.</para>
            </note>
        </simplesect>
        <simplesect id="macro_tz">
            <title>TZ, R_TZ, S_TZ</title>
                <indexterm type="parameter">
                    <primary>TZ, R_TZ, S_TZ</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TZ, $R_TZ, $S_TZ</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Equivalent to TZOFFSET, used to mean the time zone name abbreviation
                in syslog-ng 1.6.x.</para>
        </simplesect>
        <simplesect id="macro_tzoffset">
            <title>TZOFFSET, R_TZOFFSET, S_TZOFFSET</title>
                <indexterm type="parameter">
                    <primary>TZOFFSET, R_TZOFFSET, S_TZOFFSET</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$TZOFFSET, $R_TZOFFSET, $S_TZOFFSET</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The time-zone as hour offset from GMT; for example:
                <parameter>-07:00</parameter>. In syslog-ng 1.6.x this used to be
                <parameter>-0700</parameter> but as <parameter>ISODATE</parameter>
                requires the colon it was added to <parameter>TZOFFSET</parameter> as
                well.</para>
        </simplesect>
        <simplesect id="macro_unixtime">
            <title>UNIXTIME, R_UNIXTIME, S_UNIXTIME</title>
                <indexterm type="parameter">
                    <primary>UNIXTIME, R_UNIXTIME, S_UNIXTIME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$UNIXTIME, $R_UNIXTIME, $S_UNIXTIME</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Standard unix timestamp, represented as the number of seconds since
                <parameter>1970-01-01T00:00:00</parameter>.</para>
        </simplesect>
        <simplesect id="macro_year">
            <title>YEAR, R_YEAR, S_YEAR</title>
                <indexterm type="parameter">
                    <primary>YEAR, R_YEAR, S_YEAR</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$YEAR, $R_YEAR, $S_YEAR</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The year the message was sent.</para>
        </simplesect>
        <simplesect id="macro_week">
            <title>WEEK, R_WEEK, S_WEEK</title>
                <indexterm type="parameter">
                    <primary>WEEK, R_WEEK, S_WEEK</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK, $R_WEEK, $S_WEEK</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The week number of the year, prefixed with a zero for the first nine
                week of the year. (The first Monday in the year marks the first
                week.)</para>
        </simplesect>
        <simplesect id="macro_week_abbrev">
            <title>WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV</title>
                <indexterm type="parameter">
                    <primary>WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK_ABBREV, $R_WEEK_ABBREV, $S_WEEK_ABBREV</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The 3-letter English abbreviation of the name of the day the message was sent, for example <parameter>Thu</parameter>.</para>
        </simplesect>
        <simplesect id="macro_week_day">
            <title>WEEK_DAY, R_WEEK_DAY, S_WEEK_DAY</title>
                <indexterm type="parameter">
                    <primary>WEEK_DAY, R_WEEK_DAY, S_WEEK_DAY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK_DAY, $R_WEEK_DAY, $S_WEEK_DAY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The day of the week as a numerical value (1-7).</para>
        </simplesect>
        <simplesect id="macro_weekday">
            <title>WEEKDAY, R_WEEKDAY, S_WEEKDAY</title>
                <indexterm type="parameter">
                    <primary>WEEKDAY, R_WEEKDAY, S_WEEKDAY</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEKDAY, $R_WEEKDAY, $S_WEEKDAY</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> These macros are deprecated, use <link linkend="macro_week_abbrev">WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV</link> instead. The 3-letter name of the day of week the message was sent, for example
                <parameter>Thu</parameter>.</para>
        </simplesect>
        <simplesect id="macro_week_day_name">
            <title>WEEK_DAY_NAME, R_WEEK_DAY_NAME, S_WEEK_DAY_NAME</title>
                <indexterm type="parameter">
                    <primary>WEEK_DAY_NAME, R_WEEK_DAY_NAME, S_WEEK_DAY_NAME</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>$WEEK_DAY_NAME, $R_WEEK_DAY_NAME, $S_WEEK_DAY_NAME</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> The English name of the day.</para>
        </simplesect>
    </section>
        <section id="template-functions">
            <title>Using template functions</title>
            <indexterm>
                <primary>template functions</primary>
            </indexterm>
            <indexterm>
                <primary>templates</primary>
                <secondary>template functions</secondary>
            </indexterm>
            <para>A template function is a transformation: it modifies the way macros or name-value pairs are expanded. Template functions can be used in template definitions, or when macros are used in the configuration of &abbrev;. Template functions use the following syntax:</para>
            <synopsis>$(function-name parameter1 parameter2 parameter3 ...)</synopsis>
            <para>For example, the <parameter>$(echo)</parameter> template function simply returns the value of the macro it receives as a parameter, thus <parameter>$(echo $HOST)</parameter> is equivalent to <parameter>$HOST</parameter>.</para>
            <para>The parameters of template functions are separated by a whitespace character. If you want to use a longer string or multiple macros as a single parameter, enclose the parameter in double-quotes or apostrophes. For example:</para>
            <synopsis>$(echo "$HOST $PROGRAM $PID")</synopsis>
            <para>Template functions can be nested into each other, so the parameter of a template function can be another template function, like:</para>
            <synopsis>$(echo $(echo $HOST))</synopsis>
            <para>For details on using template functions, see the descriptions of the individual template functions in <xref linkend="reference-template-functions"/>.</para>
        </section>
        <section id="reference-template-functions">
            <title>Template functions of &abbrev;</title>
            <para>The following template functions are available in &abbrev;.</para>
            <simplesect id="template-function-echo">
                <title>echo</title>
                    <indexterm type="parameter">
                        <primary>echo</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(echo argument)</synopsis></para>
                <para><guilabel>Description:</guilabel> Returns the value of its argument. using <parameter>$(echo $HOST)</parameter> is equivalent to <parameter>$HOST</parameter>.</para>
            </simplesect>
            <simplesect id="template-function-format-json" condition="ose">
                <title>format-json</title>
                    <indexterm type="parameter">
                        <primary>format-json</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(format-json parameters)</synopsis></para>
                <para><guilabel>Description:</guilabel> The <parameter>format-json</parameter> template function receives value-pairs as parameters and converts them into JavaScript Object Notation (JSON) format. Including the template function in a message template allows you to store selected information about a log message (that is, its content, macros, or other metadata) in JSON format.</para>
                <para>For details on selecting value-pairs in &abbrev; and for possibilities to specify which information to convert to JSON format, see <xref linkend="concepts-value-pairs"/>. Note that the syntax of <parameter>format-json</parameter> is different from the syntax of <parameter>value-pairs()</parameter>: <parameter>format-json</parameter> uses a syntax similar to command lines.</para>
                <example>
                    <title>Using the format-json template function</title>
                    <para>The following example selects every available information about the log message, except for the date-related macros (<parameter>R_*</parameter> and <parameter>S_*</parameter>), selects the <parameter>.SDATA.meta.sequenceId</parameter> macro, and defines a new value-pair called <parameter>MSGHDR</parameter> that contains the program name and PID of the application that sent the log message.</para>
                    <synopsis>$(format-json --scope syslog,all_macros,selected_macros \
  --exclude R_* --exclude S_* --key .SDATA.meta.sequenceId \
  --pair MSGHDR="$PROGRAM[$PID]: ")</synopsis>
                    <para>The following example shows how to use this template function to store log messages in JSON format:</para>
                    <synopsis>destination d_json {
  file("/var/log/messages.json" template("$(format_json --scope selected_macros --scope nv_pairs)"));
};</synopsis>
                </example>
            </simplesect>
            <simplesect id="template-function-grep">
                <title>grep</title>
                    <indexterm type="parameter">
                        <primary>grep</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(grep condition value-to-select)</synopsis><!-- FIXME pontositani --></para>
                <para><guilabel>Description:</guilabel> The <parameter>grep</parameter> template function is useful when using a pattern database to correlate related log messages. The <parameter>grep</parameter> template function can be used to filter the messages of the same context when the index of the particular message is not known.</para>
                <example>
                    <title>Using the grep template function</title>
                    <para>The following example selects the message of the context that has a <parameter>username</parameter> name-value pair with the <parameter>root</parameter> value, and returns the value of the <parameter>auth_method</parameter> name-value pair.</para>
                    <synopsis>$(grep ("${username}" == "root") ${auth_method})</synopsis>
                </example>
                <para>It is possible to specify multiple name-value pairs as parameters, separated with commas. If multiple messages match the condition of <parameter>grep</parameter>, these will be returned also separated by commas. This can be used for example to collect the e-mail recipients from postfix messages.</para>
                <!-- FIXME konkret peldat! -->
            </simplesect>
            <simplesect id="template-function-if">
                <title>if</title>
                    <indexterm type="parameter">
                        <primary>if</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(if (&lt;condition&gt;) &lt;true template&gt; &lt;false template&gt;)</synopsis></para>
                <para><guilabel>Description:</guilabel> Returns the value of the <parameter>&lt;true template&gt;</parameter> parameter if the <parameter>&lt;condition&gt;</parameter> is true. If the <parameter>&lt;condition&gt;</parameter> is false, the value of <parameter>&lt;false template&gt;</parameter> is returned.</para>
                <example>
                    <title>Using pattern databases and the if template function</title>
                    <para>The following example returns <parameter>violation</parameter> if the <parameter>username</parameter> name-value pair of a message processed with pattern database is <parameter>root</parameter>, and <parameter>system</parameter> otherwise.</para>
                    <synopsis>$(if ("${username}" == "root") "violation" "system")</synopsis>
                    <para>This can be used to set the class of a message in pattern database rules based on the condition.</para>
                    <synopsis>&lt;value name="username"&gt;$(if ("${username}" == "root") "violation" "system")&lt;/value&gt;</synopsis>
                    <indexterm>
                        <primary>template functions</primary>
                        <secondary>embedding</secondary>
                    </indexterm>
                    <para>Since template functions can be embedded into each other, it is possible to use another template function as the template of the first one. For example, the following expression returns <parameter>root</parameter> if the username is <parameter>root</parameter>, <parameter>admin</parameter> if the username is <parameter>joe</parameter>, and <parameter>normal user</parameter> otherwise.</para>
                    <synopsis>&lt;value name="username"&gt;
        $(if ("${username}" == "root")
            "root"
            $(if ("${username}" == "joe") "admin" "normal user")
            "normal user")&lt;/value&gt;</synopsis>
                </example>
            </simplesect>
            <simplesect id="template-function-indent-multi-line">
                <title>indent-multi-line</title>
                    <indexterm type="parameter">
                        <primary>indent-multi-line</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(indent-multi-line parameter)</synopsis></para>
                <para><guilabel>Description:</guilabel> This template function makes it possible to write multi-line log messages into a file. The first line is written like a regular message, subsequent lines are indented with a tab, in compliance with RFC822.</para>
                <example>
                    <title>Using the indent-multi-line template function</title>
                    <para>The following example writes multi-line messages into a text file.</para>
                    <synopsis>destination d_file {
                file ("/var/log/messages"
                        template("${ISODATE} ${HOST} $(indent-multi-line ${MESSAGE})\n") );
};</synopsis>
                </example>
            </simplesect>
            <simplesect id="template-function-ipv4-to-int">
                <title>ipv4-to-int</title>
                    <indexterm type="parameter">
                        <primary>ipv4-to-int</primary>
                    </indexterm>
                <para><guilabel>Syntax:</guilabel> <synopsis>$(ipv4-to-int parameter)</synopsis></para>
                <para><guilabel>Description:</guilabel> Converts the specified IPv4 address to its numeric representation. The numerical value of an IPv4 address is calculated by treating the IP address as a 4-byte hexadecimal value. For example, the 192.168.1.1 address equals to: 192=C0, 168=A8, 1=01, 1=01, or C0A80101, which is 3232235777 in decimal representation.</para>
                <note>
                    <para>This template function is available only if the <filename>convertfuncs</filename> module has been loaded. By default, &abbrev; loads every available module.</para>
                    <!-- FIXME link a modulokrol szolo leirasra-->
                </note>
            </simplesect>
        </section>
    </section>
    <section id="modifying-messages">
        <title>Modifying messages</title>
        <indexterm>
            <primary>rewriting messages</primary>
            <secondary>concepts of</secondary>
        </indexterm>
        <indexterm>
            <primary>rewrite rules</primary>
        </indexterm>
        <indexterm>
            <primary>rewriting messages</primary>
        </indexterm>
        <indexterm>
            <primary>sedding messages</primary>
        </indexterm>
        <indexterm>
            <primary>replacing message text</primary>
        </indexterm>
        <para>The syslog-ng application can rewrite parts of the messages using rewrite rules. Rewrite rules are global objects similar to parsers and filters and can be used in log paths. The syslog-ng application has two methods to rewrite parts of the log messages: substituting (setting) a part of the message to a fix value, and a general search-and-replace mode.</para>
        <para>Substitution completely replaces a specific part of the message that is referenced using a built-in or user-defined macro.</para>
        <para>General rewriting searches for a string in the entire message (or only a part of the message specified by a macro) and replaces it with another string. Optionally, this replacement string can be a template that contains macros.</para>
        <para>Rewriting messages
            is often used in conjunction with message parsing <xref linkend="csv-parser"/>.</para>
        <para>Rewrite rules are similar to filters: they must be defined in the syslog-ng
            configuration file and used in the log statement.</para>
        <!-- FIXME parsert/rewriteot is lehet inline definialni? -->
        <!-- FIXME options should be restructured to simplesects -->
        <note>
            <para>The order of filters, rewriting rules, and parsers in the log statement is
                important, as they are processed sequentially.
                <!-- FIXME bovebben, peldaval, filterekhez/rewrite sectionbe is -->
            </para>
        </note>
        <section id="rewrite-replace">
            <title>Replacing message parts</title>
            <indexterm type="parameter">
                <primary>rewrite()</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>subst()</primary>
            </indexterm>
            <para>To replace a part of the log message, you have to:</para>
            <itemizedlist>
                <listitem>
                    <para>define a string or regular expression to find the text to replace</para>
                </listitem>
                <listitem>
                    <para>define a string to replace the original text (macros can be used as well)</para>
                </listitem>
                <listitem>
                    <para>select the field of the message that the rewrite rule should process</para>
                </listitem>
            </itemizedlist>
            <para>Substitution rules can operate on any value available via macros, for example HOST, MESSAGE, PROGRAM, or any user-defined macros created using parsers (for details, see <xref linkend="chapter-parsers"/> and <xref linkend="chapter-patterndb"/>). The only exceptions are the FACILITY, SEVERITY, TAGS, and the date-related fields, which cannot be rewritten. You can also rewrite the structured-data fields of messages complying to the RFC5424 (IETF-syslog) message format. Substitution rules use the following syntax:</para>
            <synopsis>Declaration:
rewrite &lt;name_of_the_rule&gt; {
    subst("&lt;string or regular expression to find&gt;",
        "&lt;replacement string&gt;", value(&lt;field name&gt;), flags() );
};</synopsis>
            <para>The <parameter>type()</parameter> and <parameter>flags()</parameter> options are optional. The <parameter>type()</parameter> specifies the type of regular expression to use; while the <parameter>flags()</parameter> are the flags of the regular expressions. For details on regular expressions, see <xref linkend="regular-expressions"/>.</para>
            <para>A single substitution rule can include multiple substitutions that are applied sequentially to the message. Note that rewriting rules must be included in the log statement to have any effect.</para>
            <tip>
                <para>For case-insensitive searches, add the <parameter>flags(ignore-case)</parameter> option; to replace every occurrence of the string, add <parameter>flags(global)</parameter> option.</para>
            </tip>
            <example id="example_rewrite_subst">
                <title>Using substitution rules</title>
                <para>The following example replaces th <parameter>IP</parameter> in the text of the message with the string <parameter>IP-Address</parameter>.</para>
                <synopsis>rewrite r_rewrite_subst{subst("IP", "IP-Address", value("MESSAGE"));};</synopsis>
                <para>To replace every occurrence, use:</para>
                <synopsis>rewrite r_rewrite_subst{
    subst("IP", "IP-Address", value("MESSAGE"), flags("global"));
};</synopsis>
                <para>Multiple substitution rules are applied sequentially; the following rules replace the first occurrence of the string <parameter>IP</parameter> with the string <parameter>IP-Addresses</parameter>.</para>
                <synopsis>rewrite r_rewrite_subst{
    subst("IP", "IP-Address", value("MESSAGE"));
    subst("Address", "Addresses", value("MESSAGE"));
};</synopsis>
            </example>
        </section>
        <section id="rewrite-set">
            <title>Setting message fields to specific values</title>
            <indexterm>
                <primary>setting message fields</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>set()</primary>
            </indexterm>
            <para>To set a field of the message to a specific value, you have to:</para>
            <itemizedlist>
                <listitem>
                    <para>define the string to include in the message, and</para>
                </listitem>
                <listitem>
                    <para>select the field where it should be included.</para>
                </listitem>
            </itemizedlist>
            <para>You can set the any value available via macros, for example HOST, MESSAGE, PROGRAM, or any user-defined macros created using parsers (for details, see <xref linkend="chapter-parsers"/> and <xref linkend="chapter-patterndb"/>). The only exceptions are the FACILITY, SEVERITY, TAGS, and the date-related fields, which cannot be rewritten. Note that the rewrite operation completely replaces any previous value of that field. Use the following syntax:</para>
            <synopsis>Declaration:
rewrite &lt;name_of_the_rule&gt; {
    set("&lt;string to include&gt;", value(&lt;field name&gt;));
};</synopsis>
            <example id="example_rewrite_set">
                <title>Setting message fields to a particular value</title>
                <para>The following example sets the HOST field of the message to
                    <parameter>myhost</parameter>. </para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST"));};</synopsis>
                <para>The following example sets the sequence ID field of the RFC5424-formatted
                    (IETF-syslog) messages to a fixed value.</para>
                <synopsis>rewrite r_sd {
    set("55555" value(".SDATA.meta.sequenceId"));
};</synopsis>
                <para>It is also possible to set the value of a field that does not exist yet, and create a new name-value pair that is associated with the message. The following example created the <parameter>MODIFIED</parameter> field and sets its value to <parameter>yes</parameter>. If you use the <parameter>$MODIFIED</parameter> macro in a template or SQL table, its value will be <parameter>yes</parameter> for every message that was processed with this rewrite rule, and empty for every other message.</para>
                <synopsis>rewrite r_rewrite_set {
    set("yes", value("MODIFIED"));
};</synopsis>
            </example>
        </section>
        <section id="conditional-rewrite">
            <title>Conditional rewrites</title>
            <indexterm type="parameter">
                <primary>condition()</primary>
            </indexterm>
            <indexterm>
                <primary>conditional rewrites</primary>
            </indexterm>
            <indexterm>
                <primary>rewrite if</primary>
            </indexterm>
            <indexterm>
                <primary>rewriting messages</primary>
                <secondary>conditional rewrites</secondary>
            </indexterm>
            <indexterm>
                <primary>filtering rewrites</primary>
            </indexterm>
            <para>Starting with <phrase condition="pe">4.1</phrase><phrase condition="ose">3.2</phrase>, it is possible to apply a rewrite rule to a message only if certain conditions are met. The <parameter>condition()</parameter> option effectively embeds a filter expression into the rewrite rule: the message is modified only if the message passes the filter. If the condition is not met, the message is passed to the next element of the log path (that is, the element following the rewrite rule in the log statement, for example, the destination). Any filter expression normally used in filters can be used as a rewrite condition. Existing filter statements can be referenced using the <parameter>filter()</parameter> function within the condition.</para>
            <tip>
                <para>Using conditions in rewrite rules can simplify your &abbrev; configuration file, as you do not need to create separate log paths to modify certain messages.</para>
            </tip>
            <example id="example-conditional-rewrite">
                <title>Using conditional rewriting</title>
                <para>The following example sets the HOST field of the message to
                <parameter>myhost</parameter> only if the message was sent by the <parameter>myapplication</parameter> program.</para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST") condition(program("myapplication")));};</synopsis>
                <para>The following example is identical to the previous one, except that the condition references an existing filter template.</para>
                <synopsis>filter f_rewritefilter {program("myapplication");};
rewrite r_rewrite_set{set("myhost", value("HOST") condition(filter(f_rewritefilter)));};</synopsis>
            </example>
        </section>
    </section>
    <section id="regular-expressions">
        <title>Regular expressions</title>
        <indexterm significance="preferred">
            <primary>regular expressions</primary>
        </indexterm>
        <indexterm type="parameter">
            <primary>type()</primary>
        </indexterm>
        <para>Filters and substitution rewrite rules can use regular expressions. In regular expressions, the characters <parameter>()[].*?+^$|\</parameter> are used as special symbols. Depending on how you want to use these characters and which quotation mark you use, these characters must be used differently, as summarized below.</para>
        <itemizedlist>
            <listitem>
                <para>Strings between single quotes (<parameter>'string'</parameter>) are
                    treated literally and are not interpreted at all, you do not have to escape special characters. For example the output of <parameter>'\x41'</parameter> is <parameter>\x41</parameter> (characters as follows: backslash, <parameter>x</parameter>(letter), <parameter>4</parameter>(number), <parameter>1</parameter>(number)). This makes
                    writing and reading regular expressions much more simple: it is recommended
                    to use single quotes when writing regular expressions.</para>
            </listitem>
            <listitem>
                <para>When enclosing strings between double-quotes (<parameter>"string"</parameter>), the string is interpreted and you have to escape special characters, that is, to precede them with a backslash (<parameter>\</parameter>) character if they are meant literally. For example the output of the <parameter>"\x41"</parameter> is simply the letter <parameter>a</parameter>. Therefore special characters like <parameter>\</parameter>(backslash) <parameter>"</parameter>(quotation mark) must be escaped (<parameter>\\</parameter> and <parameter>\"</parameter>). The following expressions are interpreted: <parameter>\a</parameter>; <parameter>\n</parameter>; <parameter>\r</parameter>; <parameter>\t</parameter>; <parameter>\v</parameter>. For example, the <parameter>\$40</parameter> expression matches the <parameter>$40</parameter> string. Backslashes have to be escaped as well if they are meant literally, for example, the <parameter>\\d</parameter> expression matches the <parameter>\d</parameter> string.</para>
                <tip>
                    <para>If you use single quotes in, you do not need to escape the backslash, for example <parameter>match("\\.")</parameter> is equivalent to <parameter>match('\.')</parameter>.</para>
                </tip>
            </listitem>
            <listitem>
                <para>Enclosing alphanumeric strings between double-quotes
                    (<parameter>"string"</parameter>) is not necessary, you can just omit the
                    double-quotes. For example when writing filters,
                    <parameter>match("sometext")</parameter> and
                    <parameter>match(sometext)</parameter> will both match for the
                        <parameter>sometext</parameter> string.</para>
                 <note>
					<para>Only strings containing alphanumerical characters can be used without quotes or double quotes. If the string contains whitespace or any special characters (<parameter>()[].*?+^$|\</parameter> or <parameter>;:#</parameter>), you must use quotes or double quotes.</para>
                    <para>When using the <parameter>;:#</parameter> characters, you must use quotes or double quotes, but escaping them is not required.</para>
				</note>
            </listitem>
        </itemizedlist>
        <indexterm>
            <primary>regular expressions</primary>
            <secondary>case-insensitive</secondary>
        </indexterm>
        <indexterm>
            <primary>regular expressions</primary>
            <secondary>escaping</secondary>
        </indexterm>
        <indexterm>
            <primary>escaping special characters</primary>
        </indexterm>
        <para>By default, all regular expressions are case sensitive. To disable the case
            sensitivity of the expression, add the <parameter>flags(ignore-case)</parameter> option
            to the regular expression.</para>
        <synopsis>filter demo_regexp_insensitive { host("system" flags(ignore-case)); };</synopsis>
        <para>The regular expressions can use up to 255 regexp matches (<parameter>${1} ... ${255}</parameter>), but only from the last filter and only if the <parameter>flags("store-matches")</parameter> flag was set for the filter. For case-insensitive searches, use the <parameter>flags("ignore-case")</parameter> option.</para>

        <section id="reference_regexp_types">
            <title>Types and options of regular expressions</title>
            <para>By default, syslog-ng uses POSIX-style regular expressions. To use other expression types, add the
                <parameter>type()</parameter> option after the regular expression.</para>
            <para>The &abbrev; application supports the following expression types:</para>
            <itemizedlist>
                <listitem>
                    <para><link linkend="reference_regexp_posix">POSIX regular expressions</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference_regexp_pcre">Perl Compatible Regular Expressions (PCRE)</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference_regexp_string">Literal string searches</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference_regexp_glob">Glob patterns without regular expression support</link></para>
                </listitem>
            </itemizedlist>
        <simplesect id="reference_regexp_posix">
            <title>posix</title>
                <indexterm type="parameter">
                    <primary>posix</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Use POSIX regular expressions. If the <parameter>type()</parameter>
                parameter is not specified, syslog-ng uses POSIX regular expressions by
                default.</para>
                <para>Posix regular expressions have the following flag options:</para>
        <formalpara>
            <title>global:</title>
                <indexterm type="parameter">
                    <primary>global</primary>
                </indexterm>
            <para>Usable only in rewrite rules; match for every occurrence of the
                expression, not only the first one.</para>
        </formalpara>
        <formalpara>
            <title>ignore-case:</title>
                <indexterm type="parameter">
                    <primary>ignore-case</primary>
                </indexterm>
            <para>Disable case-sensitivity.</para>
        </formalpara>
        <!--<row>
            <entry>newline</entry>
            <entry></entry>
            </row>-->
        <formalpara>
            <title>store-matches:</title>
                <indexterm type="parameter">
                    <primary>store-matches</primary>
                </indexterm>
            <para>Store the matches of the regular expression into the <parameter>$1,
                ... $255</parameter> variables. Matches from the last filter
                expression can be referenced in regular expressions.</para>
        </formalpara>
        <formalpara>
            <title>utf8:</title>
                <indexterm type="parameter">
                    <primary>utf8</primary>
                </indexterm>
            <para>Use UTF-8 matching.</para>
        </formalpara>
        <example id="example_regexp_posix">
            <title>Using Posix regular expressions</title>
            <synopsis>filter f_message { message("keyword" flags("utf8" "ignore-case") );</synopsis>
        </example>
        </simplesect>
        <simplesect id="reference_regexp_pcre">
            <title>pcre</title>
                <indexterm type="parameter">
                    <primary>pcre</primary>
                </indexterm>
                <indexterm>
                    <primary>regular expressions</primary>
                    <secondary>pcre</secondary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Use Perl Compatible Regular Expressions (PCRE).<phrase condition="ose"> PCRE expressions can be used if &abbrev; was compiled with the <parameter>--enable-pcre</parameter> option enabled. Execute
                the <command>syslog-ng -V</command> command to check if your binary
                supports PCRE regular expressions.</phrase> Starting with &abbrev; version 3.1, PCRE expressions are supported on every platform.</para>
            <para>PCRE regular expressions have the following flag options:</para>
        <formalpara>
            <title>global:</title>
                <indexterm type="parameter">
                    <primary>global</primary>
                </indexterm>
            <para>Usable only in rewrite rules; match for every occurrence of the
                expression, not only the first one.</para>
        </formalpara>
        <formalpara>
            <title>ignore-case:</title>
                <indexterm type="parameter">
                    <primary>ignore-case</primary>
                </indexterm>
            <para>Disable case-sensitivity.</para>
        </formalpara>
        <!--<row>
            <entry>newline</entry>
            <entry>Process the string until the end of the string, ignoring newline
            characters.</entry>
            </row>-->
        <formalpara>
            <title>nobackref:</title>
                <indexterm type="parameter">
                    <primary>nobackref</primary>
                </indexterm>
            <para>Do not store back references for the matches &mdash; improves
                performance.</para>
        </formalpara>
        <formalpara>
            <title>store-matches:</title>
                <indexterm type="parameter">
                    <primary>store-matches</primary>
                </indexterm>
            <para>Store the matches of the regular expression into the <parameter>$1,
                ... $255</parameter> variables. Named matches (also called named
                subpatterns), for example <parameter>(?&lt;name&gt;...)</parameter>,
                are stored as well. Matches from the last filter expression can be
                referenced in regular expressions.</para>
        </formalpara>
        <formalpara>
            <title>unicode:</title>
                <indexterm type="parameter">
                    <primary>unicode</primary>
                </indexterm>
            <para>Use Unicode support for UTF-8 matches: UTF-8 character sequences are
                handled as single characters.</para>
        </formalpara>
        <formalpara>
            <title>utf8:</title>
                <indexterm type="parameter">
                    <primary>utf8</primary>
                </indexterm>
            <para>An alias for the <parameter>unicode</parameter> flag.</para>
        </formalpara>
        <example id="example_regexp_pcre">
            <title>Using PCRE regular expressions</title>
            <synopsis>rewrite r_rewrite_subst
        {subst("a*", "?", value("MESSAGE") type("pcre") flags("utf8" "global"));};</synopsis>
        </example>
        </simplesect>
        <simplesect id="reference_regexp_string">
            <title>string</title>
                <indexterm type="parameter">
                    <primary>string</primary>
                </indexterm>
            <para><guilabel>Description:</guilabel> Match the strings literally, without regular expression support. By
                default, only identical strings are matched. For partial matches, use
                the <parameter>flags("prefix")</parameter> or the
                <parameter>flags("substring")</parameter> flags.</para>
        </simplesect>
        <simplesect id="reference_regexp_glob">
            <title>glob</title>
            <indexterm type="parameter">
                    <primary>glob</primary>
            </indexterm>
            <indexterm>
                <primary>glob patterns</primary>
            </indexterm>
            <para><guilabel>Description:</guilabel> Match the strings against a pattern containing '*' and '?' wildcards, without regular expression and character range support. The advantage of glob patterns to regular expressions is that globs can be processed much faster.</para>
            <variablelist>
                <varlistentry>
                    <term>
                        <command>*</command>
                    </term>
                    <listitem>
                        <para>matches an arbitrary string, including an empty string</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <command>?</command>
                    </term>
                    <listitem>
                        <para>matches an arbitrary character</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <note>
                <itemizedlist>
                    <listitem>
                        <para>The wildcards can match the <parameter>/</parameter> character.</para>
                    </listitem>
                    <listitem>
                        <para>You cannot use the <parameter>*</parameter> and <parameter>?</parameter> literally in the pattern.</para>
                    </listitem>
                </itemizedlist>
            </note>
        </simplesect>
        </section>
        <section id="optimizing-regular-expressions">
            <title>Optimizing regular expressions</title>
            <indexterm>
                <primary>filters</primary>
            </indexterm>
            <indexterm>
                <primary>regular expressions</primary>
            </indexterm>
            <indexterm>
                <primary>optimizing regular expressions</primary>
            </indexterm>
            <indexterm>
                <primary>optimizing syslog-ng performance</primary>
                <secondary>regular expressions</secondary>
            </indexterm>
            <para>The <parameter>host()</parameter>, <parameter>match()</parameter>, and <parameter>program()</parameter> filter functions and some other syslog-ng objects accept regular expressions as parameters. But evaluating
                general regular expressions puts a high load on the CPU, which can cause problems
                when the message traffic is very high. Often the regular expression can be replaced
                with simple filter functions and logical operators. Using simple filters and logical
                operators, the same effect can be achieved at a much lower CPU load.</para>
            <example>
                <title>Optimizing regular expressions in filters</title>
                <para>Suppose you need a filter that matches the following error message logged by
                    the <parameter>xntpd</parameter> NTP daemon:</para>
                <synopsis>xntpd[1567]: time error -1159.777379 is too large (set clock manually);</synopsis>
                <para>The following filter uses regular expressions and matches every instance and
                    variant of this message.</para>
                <synopsis>filter f_demo_regexp {
    program("demo_program") and
    match("time error .* is too large .* set clock manually"); };</synopsis>
                <para>Segmenting the <parameter>match()</parameter> part of this filter into
                    separate <parameter>match()</parameter> functions greatly improves the
                    performance of the filter. </para>
                <synopsis>filter f_demo_optimized_regexp {
    program("demo_program") and
    match("time error") and
    match("is too large") and
    match("set clock manually"); };</synopsis>
            </example>
        </section>
    </section>
</chapter>
