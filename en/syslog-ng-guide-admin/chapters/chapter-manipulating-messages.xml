<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
 [  <!ENTITY % entities SYSTEM "../../common/syslog-ng-entities.ent">
 %entities;]>
<chapter xml:id="chapter-manipulating-messages" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Manipulating messages</title>
    <para>This chapter explains the methods that you can use to customize, reformat, and modify log messages using &product;.</para>
    <itemizedlist>
        <listitem>
            <para><xref linkend="customizing-message-format"/> explains how to use templates and macros to change the format of log messages, or the names of logfiles and database tables.</para>
        </listitem>
        <listitem>
            <para><xref linkend="modifying-messages"/> describes how to use rewrite rules to search and replace certain parts of the message content.</para>
        </listitem>
        <listitem>
            <para><xref linkend="regular-expressions"/> lists the different types of regular expressions that can be used in various &abbrev; objects like filters and rewrite rules.</para>
        </listitem>
    </itemizedlist>
    <section xml:id="customizing-message-format">
        <title>Customizing message format</title>
        <para>The following sections describe how to customize the names of logfiles, and also how to use templates, macros, and template functions.</para>
        <itemizedlist>
            <listitem>
                <para><xref linkend="concepts-macro"/> explains how macros work.</para>
            </listitem>
            <listitem>
                <para><xref linkend="modifying-messages"/> describes how to use macros and templates to format log messages or change the names of logfiles and database tables.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-macros"/> lists the different types of macros available in &abbrev;.</para>
            </listitem>
            <listitem>
                <para><xref linkend="template-functions"/> explains what template functions are and how to use them.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-template-functions"/> lists the template functions available in &abbrev;.</para>
            </listitem>
        </itemizedlist>
        <section xml:id="concepts-macro">
            <title>Formatting messages, filenames, directories, and tablenames</title>
            <indexterm>
                <primary>formatting messages</primary>
            </indexterm>
            <indexterm>
                <primary>templates</primary>
            </indexterm>
            <indexterm>
                <primary>message templates</primary>
            </indexterm>
            <indexterm>
                <primary>macros</primary>
            </indexterm>
            <para>The &abbrev; application can dynamically create filenames, directories, or names of database tables using macros that help you organize your log messages. Macros refer to a property or a part of the log message, for example, the <parameter>${HOST}</parameter> macro refers to the name or IP address of the client that sent the log message, while <parameter>${DAY}</parameter> is the day of the month when syslog-ng has received the message. Using these macros in the path of the destination log files allows you for example to collect the logs of every host into separate files for every day.</para>
            <para>A set of macros can be defined as a template object and used in multiple destinations.</para>
            <para>Another use of macros and templates is to customize the format of the syslog message, for example, to add elements of the message header to the message text.</para>
            <xi:include href="../../common/wnt/note-formatting-messages.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <itemizedlist>
                <listitem>
                    <para>For details on using templates and macros, see <xref linkend="configuring-macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For a list and description of the macros available in &abbrev;, see <xref linkend="reference-macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For details on using custom macros created with CSV parsers and pattern databases, see <xref linkend="chapter-parsers"/> and <xref linkend="patterndb-filters"/>, respectively.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section xml:id="configuring-macros">
            <title>Templates and macros</title>
<!-- FIXME a template+makro, parser es rewrite sectionoket egy kozos sectionbe kellene tenni, es az elejen
        leirni, hogy hogyan viszonyulnak egymashoz: vannak a makrok, parserrel lehet az uzeneteket sajat makrokra bontani,
        a rewrite meg ezeket tudja atirni-->
            <indexterm significance="preferred">
                <primary>templates</primary>
            </indexterm>
            <para>The &abbrev; application allows you to define message templates, and reference them from every object that can use a template. Templates can be used for example to create standard message formats or filenames. Templates can reference one or more macros (for example date, the hostname, and so on). For a list of macros available in &product;, see <xref linkend="reference-macros"/>.<phrase condition="pe"> For the macros of the syslog-ng Agent for Windows application, see<olink targetdoc="syslog-ng-windows-agent-guide-admin" targetptr="chapter-format"/>.</phrase> Fields from the structured data (SD) part of messages using the new IETF-syslog standard can also be used as macros.</para>
            <para>Template objects have a single option called <parameter>template-escape()</parameter>, which is disabled by default (<userinput>template-escape(no)</userinput>). This behavior is useful when the messages are passed to an application that cannot handle escaped characters properly. Enabling template escaping (<userinput>template-escape(yes)</userinput>) causes syslog-ng to escape the <userinput>'</userinput>, <userinput>"</userinput>, and backslash characters from the messages.</para>
            <note>
                <para>In versions 2.1 and earlier, the <parameter>template-escape()</parameter> option was enabled by default.</para>
            </note>
            <para>Macros can be included by prefixing the macro name with a <userinput>$</userinput> sign, just like in Bourne compatible shells. Although using braces around macro names is not mandatory, and the <userinput>"$MSG"</userinput> and <userinput>"${MSG}"</userinput> formats are equivalent, using the <userinput>"${MSG}"</userinput> format is recommended for clarity.</para>
            <indexterm>
                <primary>templates</primary>
                <secondary>literal $</secondary>
            </indexterm>
            <indexterm>
                <primary>templates</primary>
                <secondary>escaping</secondary>
            </indexterm>
            <para>To use a literal <userinput>$</userinput> character in a template, you have to escape it. In &abbrev; versions <phrase condition="pe">4.0-4.2</phrase><phrase condition="ose">3.4 and earlier</phrase>, use a backslash (<userinput>\$</userinput>). In version <phrase condition="pe">5.0</phrase><phrase condition="ose">3.5</phrase> and later, use <userinput>$$</userinput>.</para>
            <xi:include href="../../common/wnt/note-escape-at.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <indexterm>
                <primary>macros</primary>
                <secondary>default value</secondary>
            </indexterm>
            <para>Default values for macros can also be specified by appending the <userinput>:-</userinput> characters and the default value of the macro. If a message does not contain the field referred to by the macro, or it is empty, the default value will be used when expanding the macro. For example, if a message does not contain a hostname, the following macro can specify a default hostname.</para>
            <synopsis>${HOST:-default_hostname}</synopsis>
            <note condition="pe">
                <para>For the macros of the &agent; application, see<olink targetdoc="syslog-ng-windows-agent-guide-admin" targetptr="chapter-format"/>.</para>
            </note>
            <warning>
                <para>The hostname-related macros (<parameter>${FULLHOST}</parameter>, <parameter>${FULLHOST_FROM}</parameter>, <parameter>${HOST}</parameter>, and <parameter>${HOST_FROM}</parameter>) do not have any effect if the <parameter>keep-hostname()</parameter> option is disabled.</para>
            </warning>
            <para>By default, syslog-ng sends messages using the following template: <userinput>${ISODATE} ${HOST} ${MSGHDR}${MSG}\n</userinput>. (The <userinput>${MSGHDR}${MSG}</userinput> part is written together because the <parameter>${MSGHDR}</parameter> macro includes a trailing whitespace.)</para>
            <note>
                <para>Earlier versions of syslog-ng used templates and scripts to send log messages into SQL databases. Starting from version 2.1, syslog-ng natively supports direct database access using the <parameter>sql()</parameter> destination. For details, see <xref linkend="reference-destination-sql"/>.</para>
            </note>
            <indexterm>
                <primary>templates</primary>
                <secondary>defining</secondary>
            </indexterm>
            <example>
                <title>Using templates and macros</title>
                <indexterm>
                    <primary>templates</primary>
                    <secondary>example</secondary>
                </indexterm>
                <para>The following template (<userinput>t_demo_filetemplate</userinput>) adds the date of the message and the name of the host sending the message to the beginning of the message text. The template is then used in a file destination: messages sent to this destination (<userinput>d_file</userinput>) will use the message format defined in the template.</para>
                <synopsis>template t_demo_filetemplate {
             template("${ISODATE} ${HOST} ${MSG}\n"); template-escape(no); };
destination d_file {
             file("/var/log/messages" template(t_demo_filetemplate)); };</synopsis>
                <para>Templates can also be used inline, if they are used only at a single location. The following destination is equivalent with the previous example:</para>
                <synopsis>destination d_file {
                file ("/var/log/messages"
                        template("${ISODATE} ${HOST} ${MSG}\n") template-escape(no) );
                };
            </synopsis>
                <indexterm>
                    <primary>macros</primary>
                    <secondary>in filenames</secondary>
                </indexterm>
                <para>The following file destination uses macros to daily create separate logfiles for every client host.</para>
                <synopsis>destination d_file {
        file("/var/log/${YEAR}.${MONTH}.${DAY}/${HOST}.log");
};</synopsis>
            </example>
            <note>
                <para>Macros can be used to format messages, and also in the name of destination files or database tables. However, they cannot be used in sources as wildcards, for example, to read messages from files or directories that include a date in their name.</para>
            </note>
        </section>
        <section xml:id="date-macros">
            <title>Date-related macros</title>
            <indexterm>
                <primary>macros</primary>
                <secondary>date-related</secondary>
            </indexterm>
            <para>The macros related to the date of the message (for example: <parameter>${ISODATE}</parameter>, <parameter>${HOUR}</parameter>, and so on) have three further variants each:</para>
            <itemizedlist>
                <listitem>
                    <para><userinput>S_</userinput> prefix, for example, <parameter>${S_DATE}</parameter>: The <parameter>${S_DATE}</parameter> macro represents the date found in the log message, that is, when the message was sent by the original application.</para>
                </listitem>
                <listitem>
                    <para><userinput>R_</userinput> prefix, for example, <parameter>${R_DATE}</parameter>: <parameter>${R_DATE}</parameter> is the date when &abbrev; has received the message.</para>
                </listitem>
                <listitem>
                    <para><parameter>C_</parameter> prefix, for example, <parameter>C_DATE</parameter>: <parameter>C_DATE</parameter> is the current date, that is when &abbrev; processes the message and resolves the macro.</para>
                </listitem>
            </itemizedlist>
            <para>Starting with &abbrev; version <phrase condition="ose">3.2</phrase><phrase condition="pe">4.1</phrase>, the <parameter>${DATE}</parameter> macro equals the <parameter>${S_DATE}</parameter> macro. In earlier versions the value of <parameter>${DATE}</parameter> depended on the <parameter>use-time-recvd()</parameter> global option, which was removed from &abbrev;.</para>
        </section>
        <section xml:id="macros-hard-vs-soft">
            <title>Hard vs. soft macros</title>
            <indexterm>
                <primary>macros</primary>
                <secondary>hard and soft macros</secondary>
            </indexterm>
            <indexterm>
                <primary>hard macros</primary>
            </indexterm>
            <indexterm>
                <primary>soft macros</primary>
            </indexterm>
            <para>Hard macros contain data that is directly derived from the log message, for example, the ${MONTH} macro derives its value from the timestamp. Hard macros are read-only. Soft macros (sometimes also called name-value pairs) are either built-in macros automatically generated from the log message (for example, ${HOST}), or custom user-created macros generated by using the syslog-ng pattern database or a CSV-parser. In contrast to hard macros, soft macros are writable and can be modified within &abbrev;, for example, using rewrite rules.</para>
            <para>Hard and soft macros are rather similar and often treated as equivalent. Macros are most commonly used in filters and templates, which does not modify the value of the macro, so both soft and hard macros can be used. However, it is not possible to change the values of hard macros in rewrite rules or via any other means.</para>
            <para>The following macros in &abbrev; are hard macros and cannot be modified: <parameter>BSDTAG</parameter>, <parameter>CONTEXT_ID</parameter>, <parameter>DATE</parameter>, <parameter>DAY</parameter>, <parameter>FACILITY_NUM</parameter>, <parameter>FACILITY</parameter>, <parameter>FULLDATE</parameter>, <parameter>HOUR</parameter>, <parameter>ISODATE</parameter>, <parameter>LEVEL_NUM</parameter>, <parameter>LEVEL</parameter>, <parameter>MIN</parameter>, <parameter>MONTH_ABBREV</parameter>, <parameter>MONTH_NAME</parameter>, <parameter>MONTH</parameter>, <parameter>MONTH_WEEK</parameter>, <parameter></parameter>, <parameter>PRIORITY</parameter>, <parameter>PRI</parameter>, <parameter>SDATA</parameter>, <parameter>SEC</parameter>, <parameter>SEQNUM</parameter>, <parameter>SOURCEIP</parameter>, <parameter>STAMP</parameter>, <parameter>TAG</parameter>, <parameter>TAGS</parameter>, <parameter>TZOFFSET</parameter>, <parameter>TZ</parameter>, <parameter>UNIXTIME</parameter>, <parameter>WEEK_DAY_ABBREV</parameter>, <parameter>WEEK_DAY_NAME</parameter>, <parameter>WEEK_DAY</parameter>, <parameter>WEEK</parameter>, <parameter>YEAR_DAY</parameter>, <parameter>YEAR</parameter>.</para>
            <para>The following macros can be modified:<parameter>FULLHOST_FROM</parameter>, <parameter>FULLHOST</parameter>, <parameter>HOST_FROM</parameter>, <parameter>HOST</parameter>, <parameter>LEGACY_MSGHDR</parameter>, <parameter>MESSAGE</parameter>, <parameter>MSG</parameter>,<parameter>MSGID</parameter>, <parameter>MSGONLY</parameter>, <parameter>PID</parameter>, <parameter>PROGRAM</parameter>, <parameter>SOURCE</parameter>. Custom values created using rewrite rules or parsers can be modified as well, just like stored matches of regular expressions ($0 ... $255).</para>
        </section>
        <xi:include href="reference-macros.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="template-functions">
            <title>Using template functions</title>
            <indexterm>
                <primary>template functions</primary>
            </indexterm>
            <indexterm>
                <primary>templates</primary>
                <secondary>template functions</secondary>
            </indexterm>
            <para>A template function is a transformation: it modifies the way macros or name-value pairs are expanded. Template functions can be used in template definitions, or when macros are used in the configuration of &abbrev;. Template functions use the following syntax:</para>
            <synopsis>$(function-name parameter1 parameter2 parameter3 ...)</synopsis>
            <para>For example, the <parameter>$(echo)</parameter> template function simply returns the value of the macro it receives as a parameter, thus <userinput>$(echo ${HOST})</userinput> is equivalent to <parameter>${HOST}</parameter>.</para>
            <para>The parameters of template functions are separated by a whitespace character. If you want to use a longer string or multiple macros as a single parameter, enclose the parameter in double-quotes or apostrophes. For example:</para>
            <synopsis>$(echo "${HOST} ${PROGRAM} ${PID}")</synopsis>
            <para>Template functions can be nested into each other, so the parameter of a template function can be another template function, like:</para>
            <synopsis>$(echo $(echo ${HOST}))</synopsis>
            <para>For details on using template functions, see the descriptions of the individual template functions in <xref linkend="reference-template-functions"/>.</para>
        </section>
        <xi:include href="reference-template-functions.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="on-the-wire-format">
            <title>Modifying the on-the-wire message format</title>
            <para>Macros, templates, and template functions allow you to fully customize the format of the message. This flexibility makes it possible to use &abbrev; in some unexpected way if needed, for example, to emulate simple, plain-text protocols. The following example<footnote>
                <para>This example is a summary of a blog post by <link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="http://benwilber.net/realtime-pixel-tracking-nginx-syslog-ng-redis/">Ben Wilder</link>.</para>
            </footnote>shows you how to send LPUSH commands to a Redis server.</para>
            <note condition="ose">
                <para>The purpose of this example is to demonstrate the flexibility of &abbrev;. A dedicated Redis destination is available in &abbrev; version 3.5. For details, see <xref linkend="configuring-destinations-redis"/>.</para>
            </note>
            <para>The following template is a valid LPUSH command in accordance with the <link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="http://redis.io/topics/protocol/">Redis protocol</link>, and puts the $MESSAGE into a separate list for every $PROGRAM:</para>
            <synopsis>template t_redis_lpush {
    template("*3\r\n$$5\r\nLPUSH\r\n$$$(length ${PROGRAM})\r\n${PROGRAM}\r\n$$$(length ${MESSAGE})\r\n${MESSAGE}\r\n");
};</synopsis>
            <para>If you use this template in a <userinput>tcp()</userinput> destination, &abbrev; formats the message according to the template, and sends it to the Redis server.</para>
            <synopsis>destination d_redis_tcp {
    tcp("127.0.0.1" port(6379) template(t_redis_lpush));
};</synopsis>
        </section>
    </section>
    <section xml:id="modifying-messages">
        <title>Modifying messages</title>
        <indexterm>
            <primary>rewriting messages</primary>
            <secondary>concepts of</secondary>
        </indexterm>
        <indexterm>
            <primary>rewrite rules</primary>
        </indexterm>
        <indexterm>
            <primary>rewriting messages</primary>
        </indexterm>
        <indexterm>
            <primary>sedding messages</primary>
        </indexterm>
        <indexterm>
            <primary>replacing message text</primary>
        </indexterm>
        <para>The syslog-ng application can rewrite parts of the messages using rewrite rules. Rewrite rules are global objects similar to parsers and filters and can be used in log paths. The syslog-ng application has two methods to rewrite parts of the log messages: substituting (setting) a part of the message to a fix value, and a general search-and-replace mode.</para>
        <para>Substitution completely replaces a specific part of the message that is referenced using a built-in or user-defined macro.</para>
        <para>General rewriting searches for a string in the entire message (or only a part of the message specified by a macro) and replaces it with another string. Optionally, this replacement string can be a template that contains macros.</para>
        <para>Rewriting messages is often used in conjunction with message parsing <xref linkend="csv-parser"/>.</para>
        <para>Rewrite rules are similar to filters: they must be defined in the syslog-ng configuration file and used in the log statement.</para>
<!-- FIXME parsert/rewriteot is lehet inline definialni? -->
<!-- FIXME options should be restructured to simplesects -->
        <note>
            <para>The order of filters, rewriting rules, and parsers in the log statement is important, as they are processed sequentially.<!-- FIXME bovebben, peldaval, filterekhez/rewrite sectionbe is --></para>
        </note>
        <section xml:id="rewrite-replace">
            <title>Replacing message parts</title>
            <indexterm type="parameter">
                <primary>rewrite()</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>subst()</primary>
            </indexterm>
            <para>To replace a part of the log message, you have to:</para>
            <itemizedlist>
                <listitem>
                    <para>define a string or regular expression to find the text to replace</para>
                </listitem>
                <listitem>
                    <para>define a string to replace the original text (macros can be used as well)</para>
                </listitem>
                <listitem>
                    <para>select the field of the message that the rewrite rule should process</para>
                </listitem>
            </itemizedlist>
            <para>Substitution rules can operate on any value available via macros, for example HOST, MESSAGE, PROGRAM, or any user-defined macros created using parsers (for details, see <xref linkend="chapter-parsers"/> and <xref linkend="chapter-patterndb"/>). The only exceptions are the FACILITY, SEVERITY, TAGS, and the date-related fields, which cannot be rewritten. You can also rewrite the structured-data fields of messages complying to the RFC5424 (IETF-syslog) message format. Substitution rules use the following syntax:</para>
            <synopsis>Declaration:
rewrite &lt;name_of_the_rule&gt; {
    subst("&lt;string or regular expression to find&gt;",
        "&lt;replacement string&gt;", value(&lt;field name&gt;), flags() );
};</synopsis>
            <para>The <parameter>type()</parameter> and <parameter>flags()</parameter> options are optional. The <parameter>type()</parameter> specifies the type of regular expression to use; while the <parameter>flags()</parameter> are the flags of the regular expressions. For details on regular expressions, see <xref linkend="regular-expressions"/>.</para>
            <para>A single substitution rule can include multiple substitutions that are applied sequentially to the message. Note that rewriting rules must be included in the log statement to have any effect.</para>
            <tip>
                <para>For case-insensitive searches, add the <userinput>flags(ignore-case)</userinput> option; to replace every occurrence of the string, add <userinput>flags(global)</userinput> option.</para>
            </tip>
            <example xml:id="example-rewrite-subst">
                <title>Using substitution rules</title>
                <para>The following example replaces the <userinput>IP</userinput> in the text of the message with the string <userinput>IP-Address</userinput>.</para>
                <synopsis>rewrite r_rewrite_subst{subst("IP", "IP-Address", value("MESSAGE"));};</synopsis>
                <para>To replace every occurrence, use:</para>
                <synopsis>rewrite r_rewrite_subst{
    subst("IP", "IP-Address", value("MESSAGE"), flags("global"));
};</synopsis>
                <para>Multiple substitution rules are applied sequentially; the following rules replace the first occurrence of the string <userinput>IP</userinput> with the string <userinput>IP-Addresses</userinput>.</para>
                <synopsis>rewrite r_rewrite_subst{
    subst("IP", "IP-Address", value("MESSAGE"));
    subst("Address", "Addresses", value("MESSAGE"));
};</synopsis>
            </example>
        </section>
        <section xml:id="rewrite-set">
            <title>Setting message fields to specific values</title>
            <indexterm>
                <primary>setting message fields</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>set()</primary>
            </indexterm>
            <para>To set a field of the message to a specific value, you have to:</para>
            <itemizedlist>
                <listitem>
                    <para>define the string to include in the message, and</para>
                </listitem>
                <listitem>
                    <para>select the field where it should be included.</para>
                </listitem>
            </itemizedlist>
            <para>You can set the any value available via macros, for example HOST, MESSAGE, PROGRAM, or any user-defined macros created using parsers (for details, see <xref linkend="chapter-parsers"/> and <xref linkend="chapter-patterndb"/>). The only exceptions are the FACILITY, SEVERITY, TAGS, and the date-related fields, which cannot be rewritten. Note that the rewrite operation completely replaces any previous value of that field. Use the following syntax:</para>
            <synopsis>Declaration:
rewrite &lt;name_of_the_rule&gt; {
    set("&lt;string to include&gt;", value(&lt;field name&gt;));
};</synopsis>
            <example xml:id="example-rewrite-set">
                <title>Setting message fields to a particular value</title>
                <para>The following example sets the HOST field of the message to <userinput>myhost</userinput>.</para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST"));};</synopsis>
                <para>For details on rewriting SDATA fields, see <xref linkend="custom-sdata-fields"/>.</para>
            </example>
        </section>
        <section xml:id="custom-sdata-fields">
            <title>Creating custom SDATA fields</title>
            <indexterm>
                <primary>setting message fields</primary>
            </indexterm>
            <indexterm>
                <primary>creating SDATA fields</primary>
            </indexterm>
            <indexterm>
                <primary>modifying SDATA</primary>
            </indexterm>
            <para>If you use RFC5424-formatted (IETF-syslog) messages, you can also create custom fields in the SDATA part of the message (For details on the SDATA message part, see <xref linkend="ietfsyslog-structureddata"/>). According to RFC5424, the name of the field (its SD-ID) must not contain the <userinput>@</userinput> character for reserved SD-IDs. Custom SDATA fields must be in the following format: <userinput>name@&lt;private enterprise number&gt;</userinput>, for example, <userinput>mySDATA-field@18372.4</userinput>. (18372.4 is the private enterprise number of BalaBit IT Security, the developer of &abbrev;.)</para>
            <example>
                <title>Rewriting custom SDATA fields</title>
                <para>The following example sets the sequence ID field of the RFC5424-formatted (IETF-syslog) messages to a fixed value. This field is a predefined SDATA field with a reserved SD-ID, therefore its name does not contain the <userinput>@</userinput> character.</para>
                <synopsis>rewrite r_sd {
    set("55555" value(".SDATA.meta.sequenceId"));
};</synopsis>
                <para>It is also possible to set the value of a field that does not exist yet, and create a new, custom name-value pair that is associated with the message. The following example creates the <userinput>MODIFIED@18372.4</userinput> field and sets its value to <userinput>yes</userinput>. If you use the <userinput>${MODIFIED@18372.4}</userinput> macro in a template or SQL table, its value will be <userinput>yes</userinput> for every message that was processed with this rewrite rule, and empty for every other message.</para>
                <synopsis>rewrite r_rewrite_set {
    set("yes", value("MODIFIED@18372.4"));
};</synopsis>
            </example>
        </section>
        <section xml:id="conditional-rewrite">
            <title>Conditional rewrites</title>
            <indexterm type="parameter">
                <primary>condition()</primary>
            </indexterm>
            <indexterm>
                <primary>conditional rewrites</primary>
            </indexterm>
            <indexterm>
                <primary>rewrite if</primary>
            </indexterm>
            <indexterm>
                <primary>rewriting messages</primary>
                <secondary>conditional rewrites</secondary>
            </indexterm>
            <indexterm>
                <primary>filtering rewrites</primary>
            </indexterm>
            <para>Starting with <phrase condition="pe">4 F1</phrase><phrase condition="ose">3.2</phrase>, it is possible to apply a rewrite rule to a message only if certain conditions are met. The <parameter>condition()</parameter> option effectively embeds a filter expression into the rewrite rule: the message is modified only if the message passes the filter. If the condition is not met, the message is passed to the next element of the log path (that is, the element following the rewrite rule in the log statement, for example, the destination). Any filter expression normally used in filters can be used as a rewrite condition. Existing filter statements can be referenced using the <parameter>filter()</parameter> function within the condition.</para>
            <tip>
                <para>Using conditions in rewrite rules can simplify your &abbrev; configuration file, as you do not need to create separate log paths to modify certain messages.</para>
            </tip>
            <example xml:id="example-conditional-rewrite">
                <title>Using conditional rewriting</title>
                <para>The following example sets the HOST field of the message to <userinput>myhost</userinput> only if the message was sent by the <userinput>myapplication</userinput> program.</para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST") condition(program("myapplication")));};</synopsis>
                <para>The following example is identical to the previous one, except that the condition references an existing filter template.</para>
                <synopsis>filter f_rewritefilter {program("myapplication");};
rewrite r_rewrite_set{set("myhost", value("HOST") condition(filter(f_rewritefilter)));};</synopsis>
            </example>
        </section>
        <section xml:id="rewrite-tags" condition="ose">
            <title>Adding and deleting tags</title>
            <indexterm type="parameter">
                <primary>set-tag()</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>clear-tag()</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>rewrite()</primary>
            </indexterm>
            <indexterm>
                <primary>manipulating tags</primary>
                <see>modifying tags</see>
            </indexterm>
            <indexterm>
                <primary>modifying tags</primary>
            </indexterm>
            <para>To add or delete a tag, you can use rewrite rules. To add a tag, use the following syntax:</para>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    set-tag("&lt;tag-to-add&gt;");
};</synopsis>
            <para>To delete a tag, use the following syntax:</para>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    clear-tag("&lt;tag-to-delete&gt;");
};</synopsis>
            <para>You cannot use macros in the tags.</para>
        </section>
        <xi:include href="anonymizing-credit-card-numbers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </section>
    <section xml:id="regular-expressions">
        <title>Regular expressions</title>
        <indexterm significance="preferred">
            <primary>regular expressions</primary>
        </indexterm>
        <indexterm type="parameter">
            <primary>type()</primary>
        </indexterm>
        <para>Filters and substitution rewrite rules can use regular expressions. In regular expressions, the characters <userinput>()[].*?+^$|\</userinput> are used as special symbols. Depending on how you want to use these characters and which quotation mark you use, these characters must be used differently, as summarized below.</para>
        <itemizedlist>
            <listitem>
                <para>Strings between single quotes (<userinput>'string'</userinput>) are treated literally and are not interpreted at all, you do not have to escape special characters. For example the output of <userinput>'\x41'</userinput> is <userinput>\x41</userinput> (characters as follows: backslash, <userinput>x</userinput>(letter), <userinput>4</userinput>(number), <userinput>1</userinput>(number)). This makes writing and reading regular expressions much more simple: it is recommended to use single quotes when writing regular expressions.</para>
            </listitem>
            <listitem>
                <para>When enclosing strings between double-quotes (<userinput>"string"</userinput>), the string is interpreted and you have to escape special characters, that is, to precede them with a backslash (<userinput>\</userinput>) character if they are meant literally. For example the output of the <userinput>"\x41"</userinput> is simply the letter <userinput>a</userinput>. Therefore special characters like <userinput>\</userinput>(backslash) <userinput>"</userinput>(quotation mark) must be escaped (<userinput>\\</userinput> and <userinput>\"</userinput>). The following expressions are interpreted: <userinput>\a</userinput>; <userinput>\n</userinput>; <userinput>\r</userinput>; <userinput>\t</userinput>; <userinput>\v</userinput>. For example, the <userinput>\$40</userinput> expression matches the <userinput>$40</userinput> string. Backslashes have to be escaped as well if they are meant literally, for example, the <userinput>\\d</userinput> expression matches the <userinput>\d</userinput> string.</para>
                <tip>
                    <para>If you use single quotes in, you do not need to escape the backslash, for example <userinput>match("\\.")</userinput> is equivalent to <userinput>match('\.')</userinput>.</para>
                </tip>
            </listitem>
            <listitem>
                <para>Enclosing alphanumeric strings between double-quotes (<userinput>"string"</userinput>) is not necessary, you can just omit the double-quotes. For example when writing filters, <userinput>match("sometext")</userinput> and <userinput>match(sometext)</userinput> will both match for the <userinput>sometext</userinput> string.</para>
                <note>
                    <para>Only strings containing alphanumerical characters can be used without quotes or double quotes. If the string contains whitespace or any special characters (<userinput>()[].*?+^$|\</userinput> or <userinput>;:#</userinput>), you must use quotes or double quotes.</para>
                    <para>When using the <userinput>;:#</userinput> characters, you must use quotes or double quotes, but escaping them is not required.</para>
                </note>
            </listitem>
        </itemizedlist>
        <indexterm>
            <primary>regular expressions</primary>
            <secondary>case-insensitive</secondary>
        </indexterm>
        <indexterm>
            <primary>regular expressions</primary>
            <secondary>escaping</secondary>
        </indexterm>
        <indexterm>
            <primary>escaping special characters</primary>
        </indexterm>
        <para>By default, all regular expressions are case sensitive. To disable the case sensitivity of the expression, add the <userinput>flags(ignore-case)</userinput> option to the regular expression.</para>
        <synopsis>filter demo_regexp_insensitive { host("system" flags(ignore-case)); };</synopsis>
        <para>The regular expressions can use up to 255 regexp matches (<userinput>${1} ... ${255}</userinput>), but only from the last filter and only if the <userinput>flags("store-matches")</userinput> flag was set for the filter. For case-insensitive searches, use the <userinput>flags("ignore-case")</userinput> option.</para>
        <section xml:id="reference-regexp-types">
            <title>Types and options of regular expressions</title>
            <para>By default, syslog-ng uses POSIX-style regular expressions. To use other expression types, add the <parameter>type()</parameter> option after the regular expression.</para>
            <para>The &abbrev; application supports the following expression types:</para>
            <itemizedlist>
                <listitem>
                    <para><link linkend="reference-regexp-posix">POSIX regular expressions</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference-regexp-pcre">Perl Compatible Regular Expressions (PCRE)</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference-regexp-string">Literal string searches</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference-regexp-glob">Glob patterns without regular expression support</link></para>
                </listitem>
            </itemizedlist>
            <simplesect xml:id="reference-regexp-posix">
                <title>posix</title>
                <indexterm type="parameter">
                    <primary>posix</primary>
                </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Use POSIX regular expressions. If the <parameter>type()</parameter> parameter is not specified, syslog-ng uses POSIX regular expressions by default.</para>
                <para>Posix regular expressions have the following flag options:</para>
                <formalpara>
                    <title>global:</title>
                    <indexterm type="parameter">
                        <primary>global</primary>
                    </indexterm>
                    <para>Usable only in rewrite rules; match for every occurrence of the expression, not only the first one.</para>
                </formalpara>
                <formalpara>
                    <title>ignore-case:</title>
                    <indexterm type="parameter">
                        <primary>ignore-case</primary>
                    </indexterm>
                    <para>Disable case-sensitivity.</para>
                </formalpara>
<!--<row>
            <entry>newline</entry>
            <entry></entry>
            </row>-->
                <formalpara>
                    <title>store-matches:</title>
                    <indexterm type="parameter">
                        <primary>store-matches</primary>
                    </indexterm>
                    <para>Store the matches of the regular expression into the <userinput>$1, ... $255</userinput> variables. Matches from the last filter expression can be referenced in regular expressions.</para>
                </formalpara>
                <formalpara>
                    <title>utf8:</title>
                    <indexterm type="parameter">
                        <primary>utf8</primary>
                    </indexterm>
                    <para>Use UTF-8 matching.</para>
                </formalpara>
                <example xml:id="example-regexp-posix">
                    <title>Using Posix regular expressions</title>
                    <synopsis>filter f_message { message("keyword" flags("utf8" "ignore-case") ); };</synopsis>
                </example>
            </simplesect>
            <simplesect xml:id="reference-regexp-pcre">
                <title>pcre</title>
                <indexterm type="parameter">
                    <primary>pcre</primary>
                </indexterm>
                <indexterm>
                    <primary>regular expressions</primary>
                    <secondary>pcre</secondary>
                </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Use Perl Compatible Regular Expressions (PCRE).<phrase condition="pe"> Starting with &abbrev; version 3.1, PCRE expressions are supported on every platform.</phrase><phrase condition="ose"> PCRE expressions can be used if &abbrev; was compiled with the <parameter>--enable-pcre</parameter> option enabled. Execute the <command>syslog-ng -V</command> command to check if your binary supports PCRE regular expressions.</phrase></para>
                <para>PCRE regular expressions have the following flag options:</para>
                <formalpara>
                    <title>global:</title>
                    <indexterm type="parameter">
                        <primary>global</primary>
                    </indexterm>
                    <para>Usable only in rewrite rules; match for every occurrence of the expression, not only the first one.</para>
                </formalpara>
                <formalpara>
                    <title>ignore-case:</title>
                    <indexterm type="parameter">
                        <primary>ignore-case</primary>
                    </indexterm>
                    <para>Disable case-sensitivity.</para>
                </formalpara>
                <formalpara>
                    <title>store-matches:</title>
                    <indexterm type="parameter">
                        <primary>store-matches</primary>
                    </indexterm>
                    <para>Store the matches of the regular expression into the <userinput>$1, ... $255</userinput> variables. Named matches (also called named subpatterns), for example <userinput>(?&lt;name&gt;...)</userinput>, are stored as well. Matches from the last filter expression can be referenced in regular expressions.</para>
                </formalpara>
                <formalpara>
                    <title>unicode:</title>
                    <indexterm type="parameter">
                        <primary>unicode</primary>
                    </indexterm>
                    <para>Use Unicode support for UTF-8 matches: UTF-8 character sequences are handled as single characters.</para>
                </formalpara>
                <formalpara>
                    <title>utf8:</title>
                    <indexterm type="parameter">
                        <primary>utf8</primary>
                    </indexterm>
                    <para>An alias for the <parameter>unicode</parameter> flag.</para>
                </formalpara>
                <example xml:id="example-regexp-pcre">
                    <title>Using PCRE regular expressions</title>
                    <synopsis>rewrite r_rewrite_subst
        {subst("a*", "?", value("MESSAGE") type("pcre") flags("utf8" "global"));  };</synopsis>
                </example>
            </simplesect>
            <simplesect xml:id="reference-regexp-string">
                <title>string</title>
                <indexterm type="parameter">
                    <primary>string</primary>
                </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Match the strings literally, without regular expression support. By default, only identical strings are matched. For partial matches, use the <userinput>flags("prefix")</userinput> or the <userinput>flags("substring")</userinput> flags.</para>
            </simplesect>
            <simplesect xml:id="reference-regexp-glob">
                <title>glob</title>
                <indexterm type="parameter">
                    <primary>glob</primary>
                </indexterm>
                <indexterm>
                    <primary>glob patterns</primary>
                </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Match the strings against a pattern containing '*' and '?' wildcards, without regular expression and character range support. The advantage of glob patterns to regular expressions is that globs can be processed much faster.</para>
                <variablelist>
                    <varlistentry>
                        <term><command>*</command>
                        </term>
                        <listitem>
                            <para>matches an arbitrary string, including an empty string</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><command>?</command>
                        </term>
                        <listitem>
                            <para>matches an arbitrary character</para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <note>
                    <itemizedlist>
                        <listitem>
                            <para>The wildcards can match the <userinput>/</userinput> character.</para>
                        </listitem>
                        <listitem>
                            <para>You cannot use the <userinput>*</userinput> and <userinput>?</userinput> literally in the pattern.</para>
                        </listitem>
                    </itemizedlist>
                </note>
            </simplesect>
        </section>
        <section xml:id="optimizing-regular-expressions">
            <title>Optimizing regular expressions</title>
            <indexterm>
                <primary>filters</primary>
            </indexterm>
            <indexterm>
                <primary>regular expressions</primary>
            </indexterm>
            <indexterm>
                <primary>optimizing regular expressions</primary>
            </indexterm>
            <indexterm>
                <primary>optimizing syslog-ng performance</primary>
                <secondary>regular expressions</secondary>
            </indexterm>
            <para>The <parameter>host()</parameter>, <parameter>match()</parameter>, and <parameter>program()</parameter> filter functions and some other syslog-ng objects accept regular expressions as parameters. But evaluating general regular expressions puts a high load on the CPU, which can cause problems when the message traffic is very high. Often the regular expression can be replaced with simple filter functions and logical operators. Using simple filters and logical operators, the same effect can be achieved at a much lower CPU load.</para>
            <example>
                <title>Optimizing regular expressions in filters</title>
                <para>Suppose you need a filter that matches the following error message logged by the <userinput>xntpd</userinput> NTP daemon:</para>
                <synopsis>xntpd[1567]: time error -1159.777379 is too large (set clock manually);</synopsis>
                <para>The following filter uses regular expressions and matches every instance and variant of this message.</para>
                <synopsis>filter f_demo_regexp {
    program("demo_program") and
    match("time error .* is too large .* set clock manually"); };</synopsis>
                <para>Segmenting the <parameter>match()</parameter> part of this filter into separate <parameter>match()</parameter> functions greatly improves the performance of the filter.</para>
                <synopsis>filter f_demo_optimized_regexp {
    program("demo_program") and
    match("time error") and
    match("is too large") and
    match("set clock manually"); };</synopsis>
            </example>
        </section>
    </section>
</chapter>
