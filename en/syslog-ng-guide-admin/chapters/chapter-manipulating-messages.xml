<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
 [  <!ENTITY % entities SYSTEM "../../common/syslog-ng-entities.ent">
 %entities;]>
<chapter xml:id="chapter-manipulating-messages" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Manipulating messages</title>
    <para>This chapter explains the methods that you can use to customize, reformat, and modify log messages using &product;.</para>
    <itemizedlist>
        <listitem>
            <para><xref linkend="customizing-message-format"/> explains how to use templates and macros to change the format of log messages, or the names of logfiles and database tables.</para>
        </listitem>
        <listitem>
            <para><xref linkend="modifying-messages"/> describes how to use rewrite rules to search and replace certain parts of the message content.</para>
        </listitem>
        <listitem>
            <para><xref linkend="regular-expressions"/> lists the different types of regular expressions that can be used in various &abbrev; objects like filters and rewrite rules.</para>
        </listitem>
    </itemizedlist>
    <section xml:id="customizing-message-format">
        <title>Customizing message format using macros and templates</title>
        <para>The following sections describe how to customize the names of logfiles, and also how to use templates, macros, and template functions.</para>
        <itemizedlist>
            <listitem>
                <para><xref linkend="concepts-macro"/> explains how macros work.</para>
            </listitem>
            <listitem>
                <para><xref linkend="modifying-messages"/> describes how to use macros and templates to format log messages or change the names of logfiles and database tables.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-macros"/> lists the different types of macros available in &abbrev;.</para>
            </listitem>
            <listitem>
                <para><xref linkend="template-functions"/> explains what template functions are and how to use them.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-template-functions"/> lists the template functions available in &abbrev;.</para>
            </listitem>
        </itemizedlist>
        <section xml:id="concepts-macro">
            <title>Formatting messages, filenames, directories, and tablenames</title>
            <indexterm> <primary>formatting messages</primary> </indexterm>
            <indexterm> <primary>templates</primary> </indexterm>
            <indexterm> <primary>message templates</primary> </indexterm>
            <indexterm> <primary>macros</primary> </indexterm>
            <para>The &abbrev; application can dynamically create filenames, directories, or names of database tables using macros that help you organize your log messages. Macros refer to a property or a part of the log message, for example, the <parameter>${HOST}</parameter> macro refers to the name or IP address of the client that sent the log message, while <parameter>${DAY}</parameter> is the day of the month when syslog-ng has received the message. Using these macros in the path of the destination log files allows you for example to collect the logs of every host into separate files for every day.</para>
            <para>A set of macros can be defined as a template object and used in multiple destinations.</para>
            <para>Another use of macros and templates is to customize the format of the syslog message, for example, to add elements of the message header to the message text.</para>
            <xi:include href="../../common/wnt/note-formatting-messages.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <itemizedlist>
                <listitem>
                    <para>For details on using templates and macros, see <xref linkend="configuring-macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For a list and description of the macros available in &abbrev;, see <xref linkend="reference-macros"/>.</para>
                </listitem>
                <listitem>
                    <para>For details on using custom macros created with CSV parsers and pattern databases, see <xref linkend="chapter-parsers"/> and <xref linkend="patterndb-filters"/>, respectively.</para>
                </listitem>
            </itemizedlist>
        </section>
        <section xml:id="configuring-macros">
            <title>Templates and macros</title>
            <!-- FIXME the template+macro, parser and rewrite sections should be moved into a common section -->
            <indexterm significance="preferred"> <primary>templates</primary> </indexterm>
            <para>The &abbrev; application allows you to define message templates, and reference them from every object that can use a template. Templates can include strings, macros (for example date, the hostname, and so on), and template functions. For example, you can use templates to create standard message formats or filenames. For a list of macros available in &product;, see <xref linkend="reference-macros"/>.<phrase condition="pe6"> For the macros of the syslog-ng Agent for Windows application, see <olink targetdoc="syslog-ng-windows-agent-guide-admin" targetptr="chapter-format"/>.</phrase> Fields from the structured data (SD) part of messages using the new IETF-syslog standard can also be used as macros.</para>
            <formalpara>
                <title>Declaration:</title>
                <para/>
            </formalpara>
            <indexterm> <primary>templates</primary> <secondary>defining</secondary> </indexterm>
            <synopsis>template &lt;template-name&gt; {
    template("&lt;template-expression&gt;") &lt;template-escape(yes)&gt;;
};</synopsis>
            <para>Template objects have a single option called <parameter>template-escape()</parameter>, which is disabled by default (<userinput>template-escape(no)</userinput>). This behavior is useful when the messages are passed to an application that cannot handle escaped characters properly. Enabling template escaping (<userinput>template-escape(yes)</userinput>) causes syslog-ng to escape the <userinput>'</userinput>, <userinput>"</userinput>, and backslash characters from the messages.</para>
            <para>If you do not want to enable the <parameter>template-escape()</parameter> option (which is rarely needed), you can define the template without the enclosing braces.</para>
            <synopsis>template &lt;template-name&gt; "&lt;template-expression&gt;";</synopsis>
            <para>You can also refer to an existing template from within a template. The result of the referred template will be pasted into the second template.</para>
            <synopsis>template first-template "sample-text";
template second-template "The result of the first-template is: $(template first-template)";</synopsis>
            <para>If you want to use a template only once, you can define the template inline, for example:</para>
            <synopsis>destination d_file {
    file ("/var/log/messages" template("${ISODATE} ${HOST} ${MSG}\n") );
};</synopsis>
            <para>Macros can be included by prefixing the macro name with a <userinput>$</userinput> sign, just like in Bourne compatible shells. Although using braces around macro names is not mandatory, and the <userinput>"$MSG"</userinput> and <userinput>"${MSG}"</userinput> formats are equivalent, using the <userinput>"${MSG}"</userinput> format is recommended for clarity.</para>
            <indexterm> <primary>templates</primary> <secondary>literal $</secondary> </indexterm>
            <indexterm> <primary>templates</primary> <secondary>escaping</secondary> </indexterm>
            <para>To use a literal <userinput>$</userinput> character in a template, you have to escape it. In &abbrev; versions <phrase condition="pe">4.0-4.2</phrase><phrase condition="ose">3.4 and earlier</phrase>, use a backslash (<userinput>\$</userinput>). In version <phrase condition="pe">5.0</phrase><phrase condition="ose">3.5</phrase> and later, use <userinput>$$</userinput>.</para>
            <xi:include href="../../common/wnt/note-escape-at.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <indexterm> <primary>macros</primary> <secondary>default value</secondary> </indexterm>
            <para>Default values for macros can also be specified by appending the <userinput>:-</userinput> characters and the default value of the macro. If a message does not contain the field referred to by the macro, or it is empty, the default value will be used when expanding the macro. For example, if a message does not contain a hostname, the following macro can specify a default hostname.</para>
            <synopsis>${HOST:-default_hostname}</synopsis>
            <para>By default, syslog-ng sends messages using the following template: <userinput>${ISODATE} ${HOST} ${MSGHDR}${MSG}\n</userinput>. (The <userinput>${MSGHDR}${MSG}</userinput> part is written together because the <parameter>${MSGHDR}</parameter> macro includes a trailing whitespace.)</para>
            <example>
                <title>Using templates and macros</title>
                <indexterm> <primary>templates</primary> <secondary>example</secondary> </indexterm>
                <para>The following template (<userinput>t_demo_filetemplate</userinput>) adds the date of the message and the name of the host sending the message to the beginning of the message text. The template is then used in a file destination: messages sent to this destination (<userinput>d_file</userinput>) will use the message format defined in the template.</para>
                <synopsis>template t_demo_filetemplate {
    template("${ISODATE} ${HOST} ${MSG}\n"); };
destination d_file {
    file("/var/log/messages" template(t_demo_filetemplate)); };</synopsis>
                <para>If you do not want to enable the <parameter>template-escape()</parameter> option (which is rarely needed), you can define the template without the enclosing braces. The following two templates are equivalent.</para>
                <synopsis>template t_demo_template-with-braces {
    template("${ISODATE} ${HOST} ${MSG}\n");
};
template t_demo_template-without-braces "${ISODATE} ${HOST} ${MSG}\n";
</synopsis>
                <para>Templates can also be used inline, if they are used only at a single location. The following destination is equivalent with the previous example:</para>
                <synopsis>destination d_file {
    file ("/var/log/messages" template("${ISODATE} ${HOST} ${MSG}\n") );
};</synopsis>
                <indexterm> <primary>macros</primary> <secondary>in filenames</secondary> </indexterm>
                <para>The following file destination uses macros to daily create separate logfiles for every client host.</para>
                <synopsis>destination d_file {
        file("/var/log/${YEAR}.${MONTH}.${DAY}/${HOST}.log");
};</synopsis>
            </example>
            <note>
                <para>Macros can be used to format messages, and also in the name of destination files or database tables. However, they cannot be used in sources as wildcards, for example, to read messages from files or directories that include a date in their name.</para>
            </note>
        </section>
        <section xml:id="date-macros">
            <title>Date-related macros</title>
            <indexterm> <primary>macros</primary> <secondary>date-related</secondary> </indexterm>
            <para>The macros related to the date of the message (for example: <parameter>${ISODATE}</parameter>, <parameter>${HOUR}</parameter>, and so on) have three further variants each:</para>
            <itemizedlist>
                <listitem>
                    <para><userinput>S_</userinput> prefix, for example, <parameter>${S_DATE}</parameter>: The <parameter>${S_DATE}</parameter> macro represents the date found in the log message, that is, when the message was sent by the original application.</para>
                    <xi:include href="../../common/wnt/warning-keep-timestamp-s-macros.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
                </listitem>
                <listitem>
                    <para><userinput>R_</userinput> prefix, for example, <parameter>${R_DATE}</parameter>: <parameter>${R_DATE}</parameter> is the date when &abbrev; has received the message.</para>
                </listitem>
                <listitem>
                    <para><userinput>C_</userinput> prefix, for example, <parameter>${C_DATE}</parameter>: <parameter>${C_DATE}</parameter> is the current date, that is when &abbrev; processes the message and resolves the macro.</para>
                </listitem>
            </itemizedlist>
            <para>The <parameter>${DATE}</parameter> macro equals the <parameter>${S_DATE}</parameter> macro.</para>
            <para>The values of the date-related macros are calculated using the original timezone information of the message. To convert it to a different timezone, use the <parameter>time-zone()</parameter> option. You can set the <parameter>time-zone()</parameter> option as a global option, or per destination. For sources, it applies only if the original message does not contain timezone information. Converting the timezone changes the values of the following date-related macros (macros <parameter>MSEC</parameter> and <parameter>USEC</parameter> are not changed):</para>
            <itemizedlist>
                <listitem>
                    <para><parameter>AMPM</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>DATE</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>DAY</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>FULLDATE</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>HOUR</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>HOUR12</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>ISODATE</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>MIN</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>MONTH</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>MONTH_ABBREV</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>MONTH_NAME</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>MONTH_WEEK</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>SEC</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>STAMP</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>TZ</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>TZOFFSET</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>UNIXTIME</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>WEEK</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>WEEK_DAY</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>WEEK_DAY_ABBREV</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>WEEK_DAY_NAME</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>YEAR</parameter></para>
                </listitem>
                <listitem>
                    <para><parameter>YEAR_DAY</parameter></para>
                </listitem>
            </itemizedlist>
        </section>
        <section xml:id="macros-hard-vs-soft">
            <title>Hard vs. soft macros</title>
            <indexterm> <primary>macros</primary> <secondary>hard and soft macros</secondary> </indexterm>
            <indexterm> <primary>hard macros</primary> </indexterm>
            <indexterm> <primary>soft macros</primary> </indexterm>
            <para>Hard macros contain data that is directly derived from the log message, for example, the ${MONTH} macro derives its value from the timestamp. Hard macros are read-only. Soft macros (sometimes also called name-value pairs) are either built-in macros automatically generated from the log message (for example, ${HOST}), or custom user-created macros generated by using the syslog-ng pattern database or a CSV-parser. In contrast to hard macros, soft macros are writable and can be modified within &abbrev;, for example, using rewrite rules.</para>
            <para>Hard and soft macros are rather similar and often treated as equivalent. Macros are most commonly used in filters and templates, which does not modify the value of the macro, so both soft and hard macros can be used. However, it is not possible to change the values of hard macros in rewrite rules or via any other means.</para>
            <para>The following macros in &abbrev; are hard macros and cannot be modified: <parameter>BSDTAG</parameter>, <parameter>CONTEXT_ID</parameter>, <parameter>DATE</parameter>, <parameter>DAY</parameter>, <parameter>FACILITY_NUM</parameter>, <parameter>FACILITY</parameter>, <parameter>FULLDATE</parameter>, <parameter>HOUR</parameter>, <parameter>ISODATE</parameter>, <parameter>LEVEL_NUM</parameter>, <parameter>LEVEL</parameter>, <parameter>MIN</parameter>, <parameter>MONTH_ABBREV</parameter>, <parameter>MONTH_NAME</parameter>, <parameter>MONTH</parameter>, <parameter>MONTH_WEEK</parameter>, <parameter/>, <parameter>PRIORITY</parameter>, <parameter>PRI</parameter>, <parameter>RCPTID</parameter>, <parameter>SDATA</parameter>, <parameter>SEC</parameter>, <parameter>SEQNUM</parameter>, <parameter>SOURCEIP</parameter>, <parameter>STAMP</parameter>, <parameter>TAG</parameter>, <parameter>TAGS</parameter>, <parameter>TZOFFSET</parameter>, <parameter>TZ</parameter>, <parameter>UNIXTIME</parameter>, <parameter>WEEK_DAY_ABBREV</parameter>, <parameter>WEEK_DAY_NAME</parameter>, <parameter>WEEK_DAY</parameter>, <parameter>WEEK</parameter>, <parameter>YEAR_DAY</parameter>, <parameter>YEAR</parameter>.</para>
            <para>The following macros can be modified:<parameter>FULLHOST_FROM</parameter>, <parameter>FULLHOST</parameter>, <parameter>HOST_FROM</parameter>, <parameter>HOST</parameter>, <parameter>LEGACY_MSGHDR</parameter>, <parameter>MESSAGE</parameter>, <parameter>MSG</parameter>,<parameter>MSGID</parameter>, <parameter>MSGONLY</parameter>, <parameter>PID</parameter>, <parameter>PROGRAM</parameter>, <parameter>SOURCE</parameter>. Custom values created using rewrite rules or parsers can be modified as well, just like stored matches of regular expressions ($0 ... $255).</para>
        </section>
        <xi:include href="reference-macros.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="template-functions">
            <title>Using template functions</title>
            <indexterm> <primary>template functions</primary> </indexterm>
            <indexterm> <primary>templates</primary> <secondary>template functions</secondary> </indexterm>
            <para>A template function is a transformation: it modifies the way macros or name-value pairs are expanded. Template functions can be used in template definitions, or when macros are used in the configuration of &abbrev;. Template functions use the following syntax:</para>
            <synopsis>$(function-name parameter1 parameter2 parameter3 ...)</synopsis>
            <para>For example, the <parameter>$(echo)</parameter> template function simply returns the value of the macro it receives as a parameter, thus <userinput>$(echo ${HOST})</userinput> is equivalent to <parameter>${HOST}</parameter>.</para>
            <para>The parameters of template functions are separated by a whitespace character. If you want to use a longer string or multiple macros as a single parameter, enclose the parameter in double-quotes or apostrophes. For example:</para>
            <synopsis>$(echo "${HOST} ${PROGRAM} ${PID}")</synopsis>
            <para>Template functions can be nested into each other, so the parameter of a template function can be another template function, like:</para>
            <synopsis>$(echo $(echo ${HOST}))</synopsis>
            <para>For details on the available template functions, see the descriptions of the individual template functions in <xref linkend="reference-template-functions"/>.</para>
            <para>You can define your own template function as a regular configuration object (for example, to reuse the same function in different places in your configuration).</para>
            <formalpara>
                <title>Declaration:</title>
                <para/>
            </formalpara>
            <synopsis>template-function &lt;name-of-the-template-function&gt; "&lt;template-expression-using-strings-macros-template-functions&gt;";</synopsis>
            <example>
                <title>Using custom template functions</title>
                <para>The following template function can be used to reformat the message. It adds the length of the message to the message template.</para>
                <synopsis>
template-function my-template-function "${ISODATE} ${HOST} message-length=$(length "${MSG}") ${MSG}";
destination d_file {
	file("/tmp/mylogs.log" template("$(my-template-function)\n")); };</synopsis>
                <para>You can also refer to existing templates in your template function.</para>
                <synopsis>
template my-custom-header-template "${ISODATE} ${HOST_FROM} ${MSGHDR}";
template-function my-template-function "$(my-custom-header-template) message-length=$(length "${MSG}") ${MSG}";</synopsis>
            </example>
        </section>
        <xi:include href="reference-template-functions.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="on-the-wire-format">
            <title>Modifying the on-the-wire message format</title>
            <para>Macros, templates, and template functions allow you to fully customize the format of the message. This flexibility makes it possible to use &abbrev; in some unexpected way if needed, for example, to emulate simple, plain-text protocols. The following example shows you how to send LPUSH commands to a Redis server.</para>
            <note condition="ose">
                <para>The purpose of this example is to demonstrate the flexibility of &abbrev;. A dedicated Redis destination is available in &abbrev; version 3.5. For details, see <xref linkend="configuring-destinations-redis"/>.</para>
            </note>
            <para>The following template is a valid LPUSH command in accordance with the <link xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="https://redis.io/topics/protocol/">Redis protocol</link>, and puts the $MESSAGE into a separate list for every $PROGRAM:</para>
            <synopsis>template t_redis_lpush {
    template("*3\r\n$$5\r\nLPUSH\r\n$$$(length ${PROGRAM})\r\n${PROGRAM}\r\n$$$(length ${MESSAGE})\r\n${MESSAGE}\r\n");
};</synopsis>
            <para>If you use this template in a <userinput>network()</userinput> destination, &abbrev; formats the message according to the template, and sends it to the Redis server.</para>
            <synopsis>destination d_redis_tcp {
    network("127.0.0.1" port(6379) template(t_redis_lpush));
};</synopsis>
        </section>
    </section>
    <section xml:id="modifying-messages">
        <title>Modifying messages using rewrite rules</title>
        <indexterm> <primary>rewriting messages</primary> <secondary>concepts of</secondary> </indexterm>
        <indexterm> <primary>rewrite rules</primary> </indexterm>
        <indexterm> <primary>rewriting messages</primary> </indexterm>
        <indexterm> <primary>sedding messages</primary> </indexterm>
        <indexterm> <primary>replacing message text</primary> </indexterm>
        <para>The syslog-ng application can rewrite parts of the messages using rewrite rules. Rewrite rules are global objects similar to parsers and filters and can be used in log paths. The syslog-ng application has two methods to rewrite parts of the log messages: substituting (setting) a part of the message to a fix value, and a general search-and-replace mode.</para>
        <para>Substitution completely replaces a specific part of the message that is referenced using a built-in or user-defined macro.</para>
        <para>General rewriting searches for a string in the entire message (or only a part of the message specified by a macro) and replaces it with another string. Optionally, this replacement string can be a template that contains macros.</para>
        <para>Rewriting messages is often used in conjunction with message parsing <xref linkend="chapter-parsers"/>.</para>
        <para>Rewrite rules are similar to filters: they must be defined in the syslog-ng configuration file and used in the log statement. You can also define the rewrite rule inline in the log path.</para>
        <!-- FIXME options should be restructured to simplesects -->
        <xi:include href="../../common/wnt/note-element-order.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="rewrite-replace">
            <title>Replacing message parts</title>
            <indexterm type="parameter"> <primary>rewrite()</primary> </indexterm>
            <indexterm type="parameter"> <primary>subst()</primary> </indexterm>
            <para>To replace a part of the log message, you have to:</para>
            <itemizedlist>
                <listitem>
                    <para>define a string or regular expression to find the text to replace</para>
                </listitem>
                <listitem>
                    <para>define a string to replace the original text (macros can be used as well)</para>
                </listitem>
                <listitem>
                    <para>select the field of the message that the rewrite rule should process</para>
                </listitem>
            </itemizedlist>
            <para>Substitution rules can operate on any soft macros, for example MESSAGE, PROGRAM, or any user-defined macros created using parsers. Hard macros cannot be modified. For details on the hard and soft macros, see <xref linkend="macros-hard-vs-soft"/>). You can also rewrite the structured-data fields of messages complying to the RFC5424 (IETF-syslog) message format. Substitution rules use the following syntax:</para>
            <formalpara>
                <title>Declaration:</title>
                <para/>
            </formalpara>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    subst("&lt;string or regular expression to find&gt;",
        "&lt;replacement string&gt;", value(&lt;field name&gt;), flags() );
};</synopsis>
            <para>The <parameter>type()</parameter> and <parameter>flags()</parameter> options are optional. The <parameter>type()</parameter> specifies the type of regular expression to use, while the <parameter>flags()</parameter> are the flags of the regular expressions. For details on regular expressions, see <xref linkend="regular-expressions"/>.</para>
            <para>A single substitution rule can include multiple substitutions that are applied sequentially to the message. Note that rewriting rules must be included in the log statement to have any effect.</para>
            <tip>
                <para>For case-insensitive searches, add the <userinput>flags(ignore-case)</userinput> option. To replace every occurrence of the string, add <userinput>flags(global)</userinput> option. Note that the <parameter>store-matches</parameter> flag is automatically enabled in rewrite rules.</para>
            </tip>
            <example xml:id="example-rewrite-subst">
                <title>Using substitution rules</title>
                <para>The following example replaces the <userinput>IP</userinput> in the text of the message with the string <userinput>IP-Address</userinput>.</para>
                <synopsis>rewrite r_rewrite_subst{subst("IP", "IP-Address", value("MESSAGE"));};</synopsis>
                <para>To replace every occurrence, use:</para>
                <synopsis>rewrite r_rewrite_subst{
    subst("IP", "IP-Address", value("MESSAGE"), flags("global"));
};</synopsis>
                <para>Multiple substitution rules are applied sequentially. The following rules replace the first occurrence of the string <userinput>IP</userinput> with the string <userinput>IP-Addresses</userinput>.</para>
                <synopsis>rewrite r_rewrite_subst{
    subst("IP", "IP-Address", value("MESSAGE"));
    subst("Address", "Addresses", value("MESSAGE"));
};</synopsis>
            </example>
            <xi:include href="../../common/chunk/example-rewrite-hash.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        </section>
        <section xml:id="rewrite-set">
            <title>Setting message fields to specific values</title>
            <indexterm> <primary>setting message fields</primary> </indexterm>
            <indexterm type="parameter"> <primary>set()</primary> </indexterm>
            <para>To set a field of the message to a specific value, you have to:</para>
            <itemizedlist>
                <listitem>
                    <para>define the string to include in the message, and</para>
                </listitem>
                <listitem>
                    <para>select the field where it should be included.</para>
                </listitem>
            </itemizedlist>
            <para>You can set the value of available macros, for example HOST, MESSAGE, PROGRAM, or any user-defined macros created using parsers (for details, see <xref linkend="chapter-parsers"/> and <xref linkend="chapter-patterndb"/>). Hard macros cannot be modified. For details on the hard and soft macros, see <xref linkend="macros-hard-vs-soft"/>). Note that the rewrite operation completely replaces any previous value of that field. Use the following syntax:</para>
            <formalpara>
                <title>Declaration:</title>
                <para/>
            </formalpara>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    set("&lt;string to include&gt;", value(&lt;field name&gt;));
};</synopsis>
            <example xml:id="example-rewrite-set">
                <title>Setting message fields to a particular value</title>
                <para>The following example sets the HOST field of the message to <userinput>myhost</userinput>.</para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST"));};</synopsis>
                <para>The following example appends the "suffix" string to the MESSAGE field:</para>
                <synopsis>rewrite r_rewrite_set{set("$MESSAGE suffix", value("MESSAGE"));};</synopsis>
                <para>For details on rewriting SDATA fields, see <xref linkend="custom-sdata-fields"/>.</para>
            </example>
            <para>You can also use the following options in rewrite rules that use the <parameter>set()</parameter> operator.</para>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    set("&lt;string to include&gt;", value(&lt;field name&gt;), on-error("fallback-to-string");
};</synopsis>
            <simplesect>
                <xi:include href="../../common/chunk/option-destination-frac-digits.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
            <simplesect>
                <xi:include href="../../common/chunk/option-destination-local-timezone.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
            <simplesect>
                <xi:include href="../../common/chunk/option-destination-on-error.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
            <simplesect>
                <xi:include href="../../common/chunk/option-destination-send-timezone.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
            <simplesect>
                <xi:include href="../../common/chunk/option-destination-timezone.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
            <simplesect>
                <xi:include href="../../common/chunk/option-destination-ts-format.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
        </section>
        <section xml:id="rewrite-unset" condition="pe">
            <title>Unsetting message fields</title>
            <indexterm> <primary>unsetting message fields</primary> </indexterm>
            <indexterm type="parameter"> <primary>unset()</primary> </indexterm>
            <para>You can unset a macro or a field of the message, including any user-defined macros created using parsers (for details, see <xref linkend="chapter-parsers"/> and <xref linkend="chapter-patterndb"/>). Hard macros cannot be modified. For details on hard and soft macros, see <xref linkend="macros-hard-vs-soft"/>). Note that the unset operation completely deletes any previous value of the field that you apply it on. Use the following syntax:</para>
            <formalpara>
                <title>Declaration:</title>
                <para/>
            </formalpara>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    unset(value("&lt;field name&gt;"));
};</synopsis>
            <example xml:id="example-rewrite-unset">
                <title>Unsetting a message field</title>
                <para>The following example unsets the HOST field of the message.</para>
                <synopsis>rewrite r_rewrite_unset{unset(value("HOST"));};</synopsis>
            </example>
            <para>To unset a group of fields, you can use the <parameter>groupunset()</parameter> rewrite rule.</para>
            <formalpara>
                <title>Declaration:</title>
                <para/>
            </formalpara>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    groupunset(values("&lt;expression-for-field-names&gt;"));
};</synopsis>
            <example>
                <title>Unsetting a group of fields</title>
                <para>The following rule clears all SDATA fields:</para>
                <synopsis>rewrite r_rewrite_unset_SDATA{ groupunset(values(".SDATA.*"));};</synopsis>
            </example>
        </section>
        <section xml:id="custom-sdata-fields">
            <title>Creating custom SDATA fields</title>
            <indexterm> <primary>setting message fields</primary> </indexterm>
            <indexterm> <primary>creating SDATA fields</primary> </indexterm>
            <indexterm> <primary>modifying SDATA</primary> </indexterm>
            <para>If you use RFC5424-formatted (IETF-syslog) messages, you can also create custom fields in the SDATA part of the message (For details on the SDATA message part, see <xref linkend="ietfsyslog-structureddata"/>). According to RFC5424, the name of the field (its SD-ID) must not contain the <userinput>@</userinput> character for reserved SD-IDs. Custom SDATA fields must be in the following format: <userinput>.SDATA.group-name@&lt;private enterprise number>.field-name</userinput>, for example, <userinput>.SDATA.mySDATA-field-group@18372.4.mySDATA-field</userinput>. (18372.4 is the private enterprise number of &fullvendor;, the developer of &abbrev;.)</para>
            <example>
                <title>Rewriting custom SDATA fields</title>
                <para>The following example sets the sequence ID field of the RFC5424-formatted (IETF-syslog) messages to a fixed value. This field is a predefined SDATA field with a reserved SD-ID, therefore its name does not contain the <userinput>@</userinput> character.</para>
                <synopsis>rewrite r_sd {
    set("55555" value(".SDATA.meta.sequenceId"));
};</synopsis>
                <para>It is also possible to set the value of a field that does not exist yet, and create a new, custom name-value pair that is associated with the message. The following example creates the <userinput>.SDATA.groupID.fieldID@18372.4</userinput> field and sets its value to <userinput>yes</userinput>. If you use the <userinput>${.SDATA.groupID.fieldID@18372.4}</userinput> macro in a template or SQL table, its value will be <userinput>yes</userinput> for every message that was processed with this rewrite rule, and empty for every other message.</para>
                <para>The next example creates a new SDATA field-group and field called <userinput>custom</userinput> and <userinput>sourceip</userinput>, respectively:</para>
                <synopsis>rewrite r_rewrite_set {
    set("${SOURCEIP}" value(".SDATA.custom@18372.4.sourceip"));
};</synopsis>
                <para>If you use the <userinput>${.SDATA.custom@18372.4.sourceip}</userinput> macro in a template or SQL table, its value will be that of the <userinput>SOURCEIP</userinput> macro (as seen on the machine where the SDATA field was created) for every message that was processed with this rewrite rule, and empty for every other message.</para>
                <para>You can verify whether or not the format is correct by looking at the actual network traffic. The SDATA field-group will be called <userinput>custom@18372.4</userinput>, and <userinput>sourceip</userinput> will become a field within that group. If you decide to set up several fields, they will be listed in consecutive order within the field-group's SDATA block.</para>
            </example>
        </section>
        <section xml:id="rewrite-groupset">
            <title>Setting multiple message fields to specific values</title>
            <indexterm> <primary>setting message fields</primary> <secondary>setting multiple fields</secondary> </indexterm>
            <indexterm type="parameter"> <primary>groupset()</primary> </indexterm>
            <para>The <parameter>groupset()</parameter> rewrite rule allows you to modify the value of multiple message fields at once, for example, to change the value of sensitive fields extracted using patterndb, or received in a JSON format.</para>
            <itemizedlist>
                <listitem>
                    <para>The first parameter is the new value of the modified fields. This can be a simple string, a macro, or a template (which can include template functions as well).</para>
                </listitem>
                <listitem>
                    <para>The second parameter (<parameter>values()</parameter>) specifies the fields to modify. You can explicitly list the macros or fields (a space-separated list with the values enclosed in double-quotes), or use wildcards and glob expressions to select multiple fields.</para>
                </listitem>
                <listitem>
                    <para>Note that <parameter>groupset()</parameter> does not create new fields, it only modifies existing fields.</para>
                </listitem>
                <listitem>
                    <para>You can refer to the old value of the field using the <parameter>$_</parameter> macro. This is resolved to the value of the current field, and is available only in <parameter>groupset()</parameter> rules.</para>
                </listitem>
            </itemizedlist>
            <formalpara>
                <title>Declaration:</title>
                <para/>
            </formalpara>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    groupset("&lt;new-value-of-the-fields&gt;", values("&lt;field-name-or-glob&gt;" ["&lt;another-field-name-or-glob&gt;"]));
};</synopsis>
            <example xml:id="rewrite-groupset-examples">
                <title>Using groupset rewrite rules</title>
                <para>The following examples show how to change the values of multiple fields at the same time.</para>
                <itemizedlist>
                    <listitem>
                        <para>Change the value of the <parameter>HOST</parameter> field to <parameter>myhost</parameter>.</para>
                        <synopsis>groupset ("myhost" values("HOST"))</synopsis>
                    </listitem>
                    <listitem>
                        <para>Change the value of the <parameter>HOST</parameter> and <parameter>FULLHOST</parameter> fields to <parameter>myhost</parameter>.</para>
                        <synopsis>groupset ("myhost" values("HOST" "FULLHOST"))</synopsis>
                    </listitem>
                    <listitem>
                        <para>Change the value of the <parameter>HOST</parameter> <parameter>FULLHOST</parameter> and fields to lowercase.</para>
                        <synopsis>groupset ("$(lowercase "$_")" values("HOST" "FULLHOST"))</synopsis>
                    </listitem>
                    <listitem>
                        <para>Change the value of each field and macro that begins with <parameter>.USER</parameter> to <parameter>nobody</parameter>.</para>
                        <synopsis>groupset ("nobody" values(".USER.*"))</synopsis>
                    </listitem>
                    <listitem>
                        <para>Change the value of each field and macro that begins with <parameter>.USER</parameter> to its SHA-1 hash (truncated to 6 characters).</para>
                        <synopsis>groupset ("$(sha1 --length 6 $_)" values(".USER.*"))</synopsis>
                    </listitem>
                </itemizedlist>
            </example>
        </section>
        <section xml:id="conditional-rewrite">
            <title>Conditional rewrites</title>
            <indexterm type="parameter"> <primary>condition()</primary> </indexterm>
            <indexterm> <primary>conditional rewrites</primary> </indexterm>
            <indexterm> <primary>rewrite if</primary> </indexterm>
            <indexterm> <primary>rewriting messages</primary> <secondary>conditional rewrites</secondary> </indexterm>
            <indexterm> <primary>filtering rewrites</primary> </indexterm>
            <para>Starting with <phrase condition="pe">4 F1</phrase><phrase condition="ose">3.2</phrase>, it is possible to apply a rewrite rule to a message only if certain conditions are met. The <parameter>condition()</parameter> option effectively embeds a filter expression into the rewrite rule: the message is modified only if the message passes the filter. If the condition is not met, the message is passed to the next element of the log path (that is, the element following the rewrite rule in the log statement, for example, the destination). Any filter expression normally used in filters can be used as a rewrite condition. Existing filter statements can be referenced using the <parameter>filter()</parameter> function within the condition. For details on filters, see <xref linkend="filters"/>.</para>
            <tip>
                <para>Using conditions in rewrite rules can simplify your &abbrev; configuration file, as you do not need to create separate log paths to modify certain messages.</para>
            </tip>
            <procedure xml:id="procedure-conditional-rewrite">
                <title>How conditional rewriting works</title>
                <indexterm type="parameter"> <primary>condition()</primary> </indexterm>
                <indexterm> <primary>conditional rewrites</primary> </indexterm>
                <indexterm> <primary>rewrite if</primary> </indexterm>
                <indexterm> <primary>rewriting messages</primary> <secondary>conditional rewrites</secondary> </indexterm>
                <indexterm> <primary>filtering rewrites</primary> </indexterm>
                <formalpara>
                    <title>Purpose:</title>
                    <para/>
                </formalpara>
                <para>The following procedure summarizes how conditional rewrite rules (rewrite rules that have the <parameter>condition()</parameter> parameter set) work. The following configuration snippet is used to illustrate the procedure:</para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST") condition(program("myapplication")));};
log {
    source(s1);
    rewrite(r_rewrite_set);
    destination(d1);};</synopsis>
                <formalpara>
                    <title>Steps:</title>
                    <para/>
                </formalpara>
                <step>
                    <para>The log path receives a message from the source (<userinput>s1</userinput>).</para>
                </step>
                <step>
                    <para>The rewrite rule (<userinput>r_rewrite_set</userinput>) evaluates the condition. If the message matches the condition (the PROGRAM field of the message is "myapplication"), &abbrev; rewrites the log message (sets the value of the HOST field to "myhost"), otherwise it is not modified.</para>
                </step>
                <step>
                    <para>The next element of the log path processes the message (<userinput>d1</userinput>).</para>
                </step>
            </procedure>
            <example xml:id="example-conditional-rewrite">
                <title>Using conditional rewriting</title>
                <para>The following example sets the HOST field of the message to <userinput>myhost</userinput> only if the message was sent by the <userinput>myapplication</userinput> program.</para>
                <synopsis>rewrite r_rewrite_set{set("myhost", value("HOST") condition(program("myapplication")));};</synopsis>
                <para>The following example is identical to the previous one, except that the condition references an existing filter template.</para>
                <synopsis>filter f_rewritefilter {program("myapplication");};
rewrite r_rewrite_set{set("myhost", value("HOST") condition(filter(f_rewritefilter)));};</synopsis>
            </example>
        </section>
        <section xml:id="rewrite-tags" condition="ose">
            <title>Adding and deleting tags</title>
            <indexterm type="parameter"> <primary>set-tag()</primary> </indexterm>
            <indexterm type="parameter"> <primary>clear-tag()</primary> </indexterm>
            <indexterm type="parameter"> <primary>rewrite()</primary> </indexterm>
            <indexterm> <primary>manipulating tags</primary> <see>modifying tags</see> </indexterm>
            <indexterm> <primary>modifying tags</primary> </indexterm>
            <para>To add or delete a tag, you can use rewrite rules. To add a tag, use the following syntax:</para>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    set-tag("&lt;tag-to-add&gt;");
};</synopsis>
            <para>To delete a tag, use the following syntax:</para>
            <synopsis>rewrite &lt;name_of_the_rule&gt; {
    clear-tag("&lt;tag-to-delete&gt;");
};</synopsis>
            <para>You cannot use macros in the tags.</para>
        </section>
        <xi:include href="anonymizing-credit-card-numbers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </section>
    <section xml:id="regular-expressions">
        <title>Regular expressions</title>
        <indexterm significance="preferred"> <primary>regular expressions</primary> </indexterm>
        <indexterm type="parameter"> <primary>type()</primary> </indexterm>
        <para>Filters and substitution rewrite rules can use regular expressions. In regular expressions, the characters <userinput>()[].*?+^$|\</userinput> are used as special symbols. Depending on how you want to use these characters and which quotation mark you use, these characters must be used differently, as summarized below.</para>
        <itemizedlist>
            <listitem>
                <para>Strings between single quotes (<userinput>'string'</userinput>) are treated literally and are not interpreted at all, you do not have to escape special characters. For example the output of <userinput>'\x41'</userinput> is <userinput>\x41</userinput> (characters as follows: backslash, <userinput>x</userinput>(letter), <userinput>4</userinput>(number), <userinput>1</userinput>(number)). This makes writing and reading regular expressions much more simple: it is recommended to use single quotes when writing regular expressions.</para>
            </listitem>
            <listitem>
                <para>When enclosing strings between double-quotes (<userinput>"string"</userinput>), the string is interpreted and you have to escape special characters, that is, to precede them with a backslash (<userinput>\</userinput>) character if they are meant literally. For example the output of the <userinput>"\x41"</userinput> is simply the letter <userinput>a</userinput>. Therefore special characters like <userinput>\</userinput>(backslash) or <userinput>"</userinput>(quotation mark) must be escaped (<userinput>\\</userinput> and <userinput>\"</userinput>). The following expressions are interpreted: <userinput>\a</userinput>, <userinput>\n</userinput>, <userinput>\r</userinput>, <userinput>\t</userinput>, <userinput>\v</userinput>. For example, the <userinput>\$40</userinput> expression matches the <userinput>$40</userinput> string. Backslashes have to be escaped as well if they are meant literally, for example, the <userinput>\\d</userinput> expression matches the <userinput>\d</userinput> string.</para>
                <tip>
                    <para>If you use single quotes, you do not need to escape the backslash, for example <userinput>match("\\.")</userinput> is equivalent to <userinput>match('\.')</userinput>.</para>
                </tip>
            </listitem>
            <listitem>
                <para>Enclosing alphanumeric strings between double-quotes (<userinput>"string"</userinput>) is not necessary, you can just omit the double-quotes. For example when writing filters, <userinput>match("sometext")</userinput> and <userinput>match(sometext)</userinput> will both match for the <userinput>sometext</userinput> string.</para>
                <note>
                    <para>Only strings containing alphanumerical characters can be used without quotes or double quotes. If the string contains whitespace or any special characters (<userinput>()[].*?+^$|\</userinput> or <userinput>;:#</userinput>), you must use quotes or double quotes.</para>
                    <para>When using the <userinput>;:#</userinput> characters, you must use quotes or double quotes, but escaping them is not required.</para>
                </note>
            </listitem>
        </itemizedlist>
        <indexterm> <primary>regular expressions</primary> <secondary>case-insensitive</secondary> </indexterm>
        <indexterm> <primary>regular expressions</primary> <secondary>escaping</secondary> </indexterm>
        <indexterm> <primary>escaping special characters</primary> </indexterm>
        <para>By default, all regular expressions are case sensitive. To disable the case sensitivity of the expression, add the <userinput>flags(ignore-case)</userinput> option to the regular expression.</para>
        <synopsis>filter demo_regexp_insensitive { host("system" flags(ignore-case)); };</synopsis>
        <para>The regular expressions can use up to 255 regexp matches (<userinput>${1} ... ${255}</userinput>), but only from the last filter and only if the <userinput>flags("store-matches")</userinput> flag was set for the filter. For case-insensitive searches, use the <userinput>flags("ignore-case")</userinput> option.</para>
        <section xml:id="reference-regexp-types">
            <title>Types and options of regular expressions</title>
            <para>By default, syslog-ng uses PCRE-style regular expressions. To use other expression types, add the <parameter>type()</parameter> option after the regular expression.</para>
            <para>The &abbrev; application supports the following expression types:</para>
            <itemizedlist>
                <listitem>
                    <para><link linkend="reference-regexp-posix">POSIX regular expressions</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference-regexp-pcre">Perl Compatible Regular Expressions (PCRE)</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference-regexp-string">Literal string searches</link></para>
                </listitem>
                <listitem>
                    <para><link linkend="reference-regexp-glob">Glob patterns without regular expression support</link></para>
                </listitem>
            </itemizedlist>
            <simplesect xml:id="reference-regexp-posix">
                <title>posix</title>
                <indexterm type="parameter"> <primary>posix</primary> </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Use POSIX regular expressions.</para>
                <para>Posix regular expressions have the following flag options:</para>
                <formalpara>
                    <title>global:</title>
                    <indexterm type="parameter"> <primary>global</primary> </indexterm>
                    <para>Usable only in rewrite rules: match for every occurrence of the expression, not only the first one.</para>
                </formalpara>
                <formalpara>
                    <title>ignore-case:</title>
                    <indexterm type="parameter"> <primary>ignore-case</primary> </indexterm>
                    <para>Disable case-sensitivity.</para>
                </formalpara>
                <!--<row>
            <entry>newline</entry>
            <entry></entry>
            </row>-->
                <formalpara>
                    <title>store-matches:</title>
                    <indexterm type="parameter"> <primary>store-matches</primary> </indexterm>
                    <para>Store the matches of the regular expression into the <userinput>$0, ... $255</userinput> variables. The <userinput>$0</userinput> stores the entire match, <userinput>$1</userinput> is the first group of the match (parentheses), and so on. Matches from the last filter expression can be referenced in regular expressions.</para>
                </formalpara>
                <formalpara>
                    <title>utf8:</title>
                    <indexterm type="parameter"> <primary>utf8</primary> </indexterm>
                    <para>Use UTF-8 matching.</para>
                </formalpara>
                <example xml:id="example-regexp-posix">
                    <title>Using Posix regular expressions</title>
                    <synopsis>filter f_message { message("keyword" type("posix") flags("utf8" "ignore-case") ); };</synopsis>
                </example>
            </simplesect>
            <simplesect xml:id="reference-regexp-pcre">
                <title>pcre</title>
                <indexterm type="parameter"> <primary>pcre</primary> </indexterm>
                <indexterm> <primary>regular expressions</primary> <secondary>pcre</secondary> </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Use Perl Compatible Regular Expressions (PCRE).<phrase condition="pe"> Starting with &abbrev; version 3.1, PCRE expressions are supported on every platform.</phrase> If the <parameter>type()</parameter> parameter is not specified, syslog-ng uses PCRE regular expressions by default.</para>
                <para>PCRE regular expressions have the following flag options:</para>
                <formalpara>
                    <title>global:</title>
                    <indexterm type="parameter"> <primary>global</primary> </indexterm>
                    <para>Usable only in rewrite rules: match for every occurrence of the expression, not only the first one.</para>
                </formalpara>
                <formalpara>
                    <title>ignore-case:</title>
                    <indexterm type="parameter"> <primary>ignore-case</primary> </indexterm>
                    <para>Disable case-sensitivity.</para>
                </formalpara>
                <formalpara>
                    <title>store-matches:</title>
                    <indexterm type="parameter"> <primary>store-matches</primary> </indexterm>
                    <para>Store the matches of the regular expression into the <userinput>$0, ... $255</userinput> variables. The <userinput>$0</userinput> stores the entire match, <userinput>$1</userinput> is the first group of the match (parentheses), and so on. Named matches (also called named subpatterns), for example <userinput>(?&lt;name&gt;...)</userinput>, are stored as well. Matches from the last filter expression can be referenced in regular expressions.</para>
                </formalpara>
                <formalpara>
                    <title>unicode:</title>
                    <indexterm type="parameter"> <primary>unicode</primary> </indexterm>
                    <para>Use Unicode support for UTF-8 matches: UTF-8 character sequences are handled as single characters.</para>
                </formalpara>
                <formalpara>
                    <title>utf8:</title>
                    <indexterm type="parameter"> <primary>utf8</primary> </indexterm>
                    <para>An alias for the <parameter>unicode</parameter> flag.</para>
                </formalpara>
                <example xml:id="example-regexp-pcre">
                    <title>Using PCRE regular expressions</title>
                    <synopsis>rewrite r_rewrite_subst
        {subst("a*", "?", value("MESSAGE") flags("utf8" "global"));};</synopsis>
                </example>
            </simplesect>
            <simplesect xml:id="reference-regexp-string">
                <title>string</title>
                <indexterm type="parameter"> <primary>string</primary> </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Match the strings literally, without regular expression support. By default, only identical strings are matched. For partial matches, use the <userinput>flags("prefix")</userinput> or the <userinput>flags("substring")</userinput> flags.</para>
            </simplesect>
            <simplesect xml:id="reference-regexp-glob">
                <title>glob</title>
                <indexterm type="parameter"> <primary>glob</primary> </indexterm>
                <indexterm> <primary>glob patterns</primary> </indexterm>
                <para><emphasis role="bold">Description:</emphasis> Match the strings against a pattern containing '*' and '?' wildcards, without regular expression and character range support. The advantage of glob patterns to regular expressions is that globs can be processed much faster.</para>
                <variablelist>
                    <varlistentry>
                        <term><command>*</command> </term>
                        <listitem>
                            <para>matches an arbitrary string, including an empty string</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><command>?</command> </term>
                        <listitem>
                            <para>matches an arbitrary character</para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <note>
                    <itemizedlist>
                        <listitem>
                            <para>The wildcards can match the <userinput>/</userinput> character.</para>
                        </listitem>
                        <listitem>
                            <para>You cannot use the <userinput>*</userinput> and <userinput>?</userinput> literally in the pattern.</para>
                        </listitem>
                    </itemizedlist>
                </note>
            </simplesect>
        </section>
        <section xml:id="optimizing-regular-expressions">
            <title>Optimizing regular expressions</title>
            <indexterm> <primary>filters</primary> </indexterm>
            <indexterm> <primary>regular expressions</primary> </indexterm>
            <indexterm> <primary>optimizing regular expressions</primary> </indexterm>
            <indexterm> <primary>optimizing syslog-ng performance</primary> <secondary>regular expressions</secondary> </indexterm>
            <para>The <parameter>host()</parameter>, <parameter>match()</parameter>, and <parameter>program()</parameter> filter functions and some other syslog-ng objects accept regular expressions as parameters. But evaluating general regular expressions puts a high load on the CPU, which can cause problems when the message traffic is very high. Often the regular expression can be replaced with simple filter functions and logical operators. Using simple filters and logical operators, the same effect can be achieved at a much lower CPU load.</para>
            <example>
                <title>Optimizing regular expressions in filters</title>
                <para>Suppose you need a filter that matches the following error message logged by the <userinput>xntpd</userinput> NTP daemon:</para>
                <synopsis>xntpd[1567]: time error -1159.777379 is too large (set clock manually);</synopsis>
                <para>The following filter uses regular expressions and matches every instance and variant of this message.</para>
                <synopsis>filter f_demo_regexp {
    program("demo_program") and
    match("time error .* is too large .* set clock manually"); };</synopsis>
                <para>Segmenting the <parameter>match()</parameter> part of this filter into separate <parameter>match()</parameter> functions greatly improves the performance of the filter.</para>
                <synopsis>filter f_demo_optimized_regexp {
    program("demo_program") and
    match("time error") and
    match("is too large") and
    match("set clock manually"); };</synopsis>
            </example>
        </section>
    </section>
</chapter>
