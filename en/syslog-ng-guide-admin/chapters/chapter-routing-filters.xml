<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
 [  <!ENTITY % entities SYSTEM "../../shared/syslog-ng-entities.ent">
 %entities;]>
<chapter xml:id="chapter-routing-filters" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title><parameter>log</parameter>: Filter and route log messages using log paths, flags, and filters</title>
    <!-- FIXME jumplist -->
    <section xml:id="logpath">
        <title>Log paths</title>
        <indexterm significance="preferred"> <primary>log paths</primary> </indexterm>
        <para>Log paths determine what happens with the incoming log messages. Messages coming from the sources listed in the log statement and matching all the filters are sent to the listed destinations.</para>
        <para>To define a log path, add a log statement to the syslog-ng configuration file using the following syntax:</para>
        <indexterm> <primary>log paths</primary> <secondary>defining</secondary> </indexterm>
        <xi:include href="../../shared/chunk/synopsis-log-path.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <warning>
            <para>Log statements are processed in the order they appear in the configuration file, thus the order of log paths may influence what happens to a message, especially when using filters and log flags.</para>
        </warning>
        <xi:include href="../../shared/wnt/note-element-order.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <example xml:id="log-statement-example">
            <title>A simple log statement</title>
            <xi:include href="../../shared/chunk/log-statement.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        </example>
        <para>All matching log statements are processed by default, and the messages are sent to <emphasis>every</emphasis> matching destination by default. So a single log message might be sent to the same destination several times, provided the destination is listed in several log statements, and it can be also sent to several different destinations.</para>
        <indexterm> <primary>log paths</primary> <secondary>flags</secondary> </indexterm>
        <indexterm> <primary>flags</primary> </indexterm>
        <para>This default behavior can be changed using the <parameter>flags()</parameter> parameter. Flags apply to individual log paths, they are not global options. For details and examples on the available flags, see <xref linkend="reference-logflags"/>. The effect and use of the <parameter>flow-control</parameter> flag is detailed in <xref linkend="concepts-flow-control"/>.</para>
        <section xml:id="concepts-embedded-logpaths">
            <title>Embedded log statements</title>
            <indexterm> <primary>embedded log statements</primary> </indexterm>
            <indexterm> <primary>log pipes</primary> <secondary>embedded log statements</secondary> </indexterm>
            <indexterm significance="preferred"> <primary>log statements</primary> <secondary>embedded</secondary> </indexterm>
            <para>Starting from version 3.0, syslog-ng can handle embedded log statements (also called log pipes). Embedded log statements are useful for creating complex, multi-level log paths with several destinations and use filters, parsers, and rewrite rules.</para>
            <para>For example, if you want to filter your incoming messages based on the facility parameter, and then use further filters to send messages arriving from different hosts to different destinations, you would use embedded log statements.</para>
            <figure>
                <title>Embedded log statement</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="syslog-ng-embedded-log-statement-2.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/syslog-ng-embedded-log-statement-2.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Embedded log statements include sources &mdash; and usually filters, parsers, rewrite rules, or destinations &mdash; and other log statements that can include filters, parsers, rewrite rules, and destinations. The following rules apply to embedded log statements:</para>
            <itemizedlist>
                <listitem>
                    <para>Only the beginning (also called top-level) log statement can include sources.</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements can include multiple log statements on the same level (that is, a top-level log statement can include two or more log statements).</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements can include several levels of log statements (that is, a top-level log statement can include a log statement that includes another log statement, and so on).</para>
                </listitem>
                <listitem>
                    <para>After an embedded log statement, you can write either another log statement, or the <parameter>flags()</parameter> option of the original log statement. You cannot use filters or other configuration objects. This also means that flags (except for the <parameter>flow-control</parameter> flag) apply to the entire log statement, you cannot use them only for the embedded log statement.</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements that are on the same level receive the same messages from the higher-level log statement. For example, if the top-level log statement includes a filter, the lower-level log statements receive only the messages that pass the filter.</para>
                </listitem>
            </itemizedlist>
            <figure>
                <title>Embedded log statements</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="syslog-ng-embedded-log-statement.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/syslog-ng-embedded-log-statement.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Embedded log filters can be used to optimize the processing of log messages, for example, to re-use the results of filtering and rewriting operations.</para>
            <section xml:id="configuring-embedded-logpaths">
                <title>Using embedded log statements</title>
                <para>Embedded log statements (for details, see <xref linkend="concepts-embedded-logpaths"/>) re-use the results of processing messages (for example, the results of filtering or rewriting) to create complex log paths. Embedded log statements use the same syntax as regular log statements, but they cannot contain additional sources. To define embedded log statements, use the following syntax:</para>
                <synopsis xml:id="log-path-synopsis-embedded">log {
    source(s1); source(s2); ...

    optional_element(filter1|parser1|rewrite1);
    optional_element(filter2|parser2|rewrite2);
    ...
    destination(d1); destination(d2); ...

    #embedded log statement
    log {
        optional_element(filter1|parser1|rewrite1);
        optional_element(filter2|parser2|rewrite2);
        ...
        destination(d1); destination(d2); ...

        #another embedded log statement
        log {
            optional_element(filter1|parser1|rewrite1);
            optional_element(filter2|parser2|rewrite2);
            ...
            destination(d1); destination(d2); ...
        };
    };
    #set flags after the embedded log statements
    flags(flag1[, flag2...]);
};</synopsis>
                <example xml:id="example-logpath-embedded">
                    <title>Using embedded log paths</title>
                    <para>The following log path sends every message to the configured destinations: both the <userinput>d_file1</userinput> and the <userinput>d_file2</userinput> destinations receive every message of the source.</para>
                    <synopsis>log { source(s_localhost); destination(d_file1); destination(d_file2); };</synopsis>
                    <para>The next example is equivalent to the one above, but uses an embedded log statement.</para>
                    <synopsis>log { source(s_localhost); destination(d_file1);
    log { destination(d_file2); };
};</synopsis>
                    <para>The following example uses two filters:</para>
                    <itemizedlist>
                        <listitem>
                            <para>messages coming from the host <userinput>192.168.1.1</userinput> are sent to the <userinput>d_file1</userinput> destination, and</para>
                        </listitem>
                        <listitem>
                            <para>messages coming from the host <userinput>192.168.1.1</userinput> and containing the string <userinput>example</userinput> are sent to the <userinput>d_file2</userinput> destination.</para>
                        </listitem>
                    </itemizedlist>
                    <synopsis>log { source(s_localhost); filter { host(192.168.1.1); }; destination(d_file1);
    log { message("example"); destination(d_file2); };
};</synopsis>
                    <para>The following example collects logs from multiple source groups and uses the <parameter>source()</parameter> filter in the embedded log statement to select messages of the <userinput>s_network</userinput> source group.</para>
                    <synopsis>log { source(s_localhost); source(s_network); destination(d_file1);
    log {  filter { source(s_network); }; destination(d_file2); };
};</synopsis>
                </example>
            </section>
        </section>
        <xi:include href="junctions-channels.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="reference-logflags">
            <title>Log path flags</title>
            <para>Flags influence the behavior of syslog-ng, and the way it processes messages. The following flags may be used in the log paths, as described in <xref linkend="logpath"/>.</para>
            <table xml:id="logflags">
                <title>Log statement flags</title>
                <indexterm> <primary>log paths</primary> <secondary>flags</secondary> </indexterm>
                <indexterm> <primary>flags</primary> </indexterm>
                <indexterm type="parameter"> <primary>flags</primary> </indexterm>
                <tgroup cols="2">
                    <colspec colnum="1" colwidth="60pt"/>
                    <thead>
                        <row>
                            <entry>Flag</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>catchall <indexterm type="parameter"> <primary>catchall</primary> </indexterm> </entry>
                            <entry>This flag means that the source of the message is ignored, only the filters of the log path are taken into account when matching messages. A log statement using the <parameter>catchall</parameter> flag processes every message that arrives to any of the defined sources.</entry>
                        </row>
                        <row>
                            <entry>drop-unmatched <indexterm type="parameter"> <primary>drop-unmatched</primary> </indexterm> </entry>
                            <entry>This flag means that the message is dropped along a log path when it does not match a filter or is discarded by a parser. Without using the <parameter>drop-unmatched</parameter> flag, &abbrev; would continue to process the message along alternative paths.</entry>
                        </row>
                        <row>
                            <entry>fallback <indexterm type="parameter"> <primary>fallback</primary> </indexterm> </entry>
                            <!-- FIXME figure/illustration/flow charts needed -->
                            <entry> <para>This flag makes a log statement 'fallback'. Fallback log statements process messages that were not processed by other, 'non-fallback' log statements.</para> <xi:include href="../../shared/chunk/para-flags-processed.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/> </entry>
                        </row>
                        <row>
                            <entry>final <indexterm type="parameter"> <primary>final</primary> </indexterm> </entry>
                            <entry> <para>This flag means that the processing of log messages processed by the log statement ends here, other log statements appearing later in the configuration file will not process the messages processed by the log statement labeled as 'final'. Note that this does not necessarily mean that matching messages will be stored only once, as there can be matching log statements processed before the current one (&abbrev; evaluates log statements in the order they appear in the configuration file).</para> <xi:include href="../../shared/chunk/para-flags-processed.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/> </entry>
                        </row>
                        <row>
                            <entry>flow-control <indexterm type="parameter"> <primary>flow-control</primary> </indexterm> </entry>
                            <entry>Enables flow-control to the log path, meaning that syslog-ng will stop reading messages from the sources of this log statement if the destinations are not able to process the messages at the required speed. If disabled, syslog-ng will drop messages if the destination queues are full. If enabled, syslog-ng will only drop messages if the destination queues/window sizes are improperly sized. For details, see <xref linkend="concepts-flow-control"/>.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <warning xml:id="warning-embedded-log-flags">
                <para>The <parameter>final</parameter>, <parameter>fallback</parameter>, and <parameter>catchall</parameter> flags apply only for the top-level log paths, they have no effect on embedded log paths.</para>
            </warning>
            <example xml:id="example-logpath-flags">
                <title>Using log path flags</title>
                <!--<para>The following log path processes every message received to the
                    <parameter>s_localhost</parameter> source that was not processed by earlier log
                    paths. As syslog-ng processes log paths in the order they appear in the
                    configuration file, place such log paths at the end of the file. A typical situation
                    is to use filters to select the most important messages and send them to specific
                    destinations, and process the remaining messages with a fallback log path.</para>
                    <synopsis>.
                    .
                    .
                    log { source(s_localhost); destination(d_tcp); flags(fallback); };</synopsis>-->
                <para>Let's suppose that you have two hosts (<userinput>myhost_A</userinput> and <userinput>myhost_B</userinput>) that run two applications each (<userinput>application_A</userinput> and <userinput>application_B</userinput>), and you collect the log messages to a central syslog-ng server. On the server, you create two log paths:</para>
                <itemizedlist>
                    <listitem>
                        <para>one that processes only the messages sent by <userinput>myhost_A</userinput>, and</para>
                    </listitem>
                    <listitem>
                        <para>one that processes only the messages sent by <userinput>application_A</userinput>.</para>
                    </listitem>
                </itemizedlist>
                <para>This means that messages sent by <userinput>application_A</userinput> running on <userinput>myhost_A</userinput> will be processed by both log paths, and the messages of <userinput>application_B</userinput> running on <userinput>myhost_B</userinput> will not be processed at all.</para>
                <itemizedlist>
                    <listitem>
                        <para>If you add the <parameter>final</parameter> flag to the first log path, then only this log path will process the messages of <userinput>myhost_A</userinput>, so the second log path will receive only the messages of <userinput>application_A</userinput> running on <userinput>myhost_B</userinput>.</para>
                    </listitem>
                    <listitem>
                        <para>If you create a third log path that includes the <parameter>fallback</parameter> flag, it will process the messages not processed by the first two log paths, in this case, the messages of <userinput>application_B</userinput> running on <userinput>myhost_B</userinput>.</para>
                    </listitem>
                    <listitem>
                        <para>Adding a fourth log path with the <parameter>catchall</parameter> flag would process every message received by the syslog-ng server.</para>
                        <synopsis>log { source(s_localhost); destination(d_file); flags(catchall); };</synopsis>
                    </listitem>
                </itemizedlist>
                <para>The following example shows a scenario that can result in message loss. Do NOT use such a configuration, unless you know exactly what you are doing. The problem is if a message matches the filters in the first part of the first log path, &abbrev; treats the message as 'processed'. Since the first log path includes the <parameter>final</parameter> flag, &abbrev; will not pass the message to the second log path (the one with the <parameter>fallback</parameter> flag). As a result, &abbrev; drops messages that do not match the filter of the embedded log path.</para>
                <synopsis># Do not use such a configuration, unless you know exactly what you are doing.
log {
    source(s_network);
    # Filters in the external log path.
    # If a message matches this filter, it is treated as 'processed'
    filter(f_program);
    filter(f_message);
    log {
        # Filter in the embedded log path.
        # If a message does not match this filter, it is lost, it will not be processed by the 'fallback' log path
        filter(f_host);
        destination(d_file1);
    };
    flags(final);
};

log {
    source(s_network);
    destination(d_file2);
    flags(fallback);
};</synopsis>
            </example>
            <example>
                <title>Using the <parameter>drop-unmatched</parameter> flag</title>
                <para>In the following example, if a log message arrives whose <userinput>$MSG</userinput> part does not contain the string <userinput>foo</userinput>, then &oseabbrev; will discard the message and will not check compliance with the second <userinput>if</userinput> condition.</para>
                <synopsis>...
if {
    filter { message('foo') };
    <emphasis role="bold">flags(drop-unmatched)</emphasis>
};
if {
    filter { message('bar') };
};
...</synopsis>
                <para>(Without the <parameter>drop-unmatched</parameter> flag, &oseabbrev; would check if the message complies with the second <userinput>if</userinput> condition, that is, whether or not the message contains the string <userinput>bar</userinput> .)</para>
            </example>
        </section>
    </section>
    <section xml:id="concepts-flow-control">
        <title>Managing incoming and outgoing messages with flow-control</title>
        <indexterm> <primary>log paths</primary> <secondary>flow-control</secondary> </indexterm>
        <indexterm> <primary>flow-control</primary> </indexterm>
        <indexterm> <primary>preventing message loss</primary> <secondary>flow-control</secondary> </indexterm>
        <indexterm> <primary>parameters</primary> <secondary><parameter>log-fetch-limit()</parameter></secondary> </indexterm>
        <indexterm> <primary>parameters</primary> <secondary><parameter>log-fifo-size()</parameter></secondary> </indexterm>
        <para>This section describes the internal message-processing model of syslog-ng, as well as the flow-control feature that can prevent message losses. To use flow-control, the <parameter>flow-control</parameter> flag must be enabled for the particular log path.</para>
        <para>The syslog-ng application monitors (polls) the sources defined in its configuration file, periodically checking each source for messages. When a log message is found in one of the sources, syslog-ng polls every source and reads the available messages. These messages are processed and put into the output buffer of syslog-ng (also called fifo). From the output buffer, the operating system sends the messages to the appropriate destinations.</para>
        <para>In large-traffic environments many messages can arrive during a single poll loop, therefore syslog-ng reads only a fixed number of messages from each source. The <parameter>log-fetch-limit()</parameter> option specifies the number of messages read during a poll loop from a single source.</para>
        <figure>
            <title>Managing log messages in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="io1.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io1.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <indexterm> <primary>output buffer</primary> </indexterm>
        <para>Every destination has its own output buffer. The output buffer is needed because the destination might not be able to accept all messages immediately. The <parameter>log-fifo-size()</parameter> parameter sets the size of the output buffer. The output buffer must be larger than the <parameter>log-fetch-limit()</parameter> of the sources, to ensure that every message read during the poll loop fits into the output buffer. If the log path sends messages to a destination from multiple sources, the output buffer must be large enough to store the incoming messages of every source.</para>
        <para>TCP and unix-stream sources can receive the logs from several incoming connections (for example many different clients or applications). For such sources, syslog-ng reads messages from every connection, thus the <parameter>log-fetch-limit()</parameter> parameter applies individually to every connection of the source.</para>
        <indexterm> <primary>parameters</primary> <secondary><parameter>log-iw-size()</parameter></secondary> </indexterm>
        <indexterm> <primary>parameters</primary> <secondary><parameter>max-connections()</parameter></secondary> </indexterm>
        <figure>
            <title>Managing log messages of TCP sources in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="io2.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io2.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>The flow-control of syslog-ng introduces a control window to the source that tracks how many messages can syslog-ng accept from the source. Every message that syslog-ng reads from the source lowers the window size by one, every message that syslog-ng successfully sends from the output buffer increases the window size by one. If the window is full (that is, its size decreases to zero), syslog-ng stops reading messages from the source. The initial size of the control window is by default <userinput>100</userinput>: the <parameter>log-fifo-size()</parameter> must be larger than this value in order for flow-control to have any effect. If a source accepts messages from multiple connections, all messages use the same control window.</para>
        <note>
            <para>If the source can handle multiple connections (for example, <parameter>network()</parameter>), the size of the control window is divided by the value of the <parameter>max-connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
        </note>
        <para>When flow-control is used, every source has its own control window. As a worst-case situation, the output buffer of the destination must be set to accommodate all messages of every control window, that is, the <parameter>log-fifo-size()</parameter> of the destination must be greater than <userinput>number_of_sources</userinput>*<parameter>log-iw-size()</parameter>. This applies to every source that sends logs to the particular destination. Thus if two sources having several connections and heavy traffic send logs to the same destination, the control window of both sources must fit into the output buffer of the destination. Otherwise, syslog-ng does not activate the flow-control, and messages may be lost.</para>
        <para>The syslog-ng application handles outgoing messages the following way:</para>
        <figure>
            <title>Handling outgoing messages in &abbrev;</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="syslog-ng-message-output.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" scale="60" fileref="&imgroot;/syslog-ng-message-output.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <indexterm> <primary>output queue</primary> </indexterm>
                <para><emphasis>Output queue</emphasis>: Messages from the output queue are sent to the target syslog-ng server. The syslog-ng application puts the outgoing messages directly into the output queue, unless the output queue is full. The output queue can hold 64 messages, this is a fixed value and cannot be modified.</para>
            </listitem>
            <listitem>
                <indexterm> <primary>disk queue</primary> <secondary>disk buffer</secondary> </indexterm>
                <para><emphasis>Disk buffer</emphasis>: If the output queue is full and disk-buffering is enabled, syslog-ng puts the outgoing messages into the disk buffer of the destination.</para>
            </listitem>
            <listitem>
                <indexterm> <primary>overflow queue</primary> <secondary>output buffer</secondary> </indexterm>
                <para><emphasis>Overflow queue</emphasis>: If the output queue is full and the disk buffer is disabled or full, syslog-ng puts the outgoing messages into the overflow queue of the destination. (The overflow queue is identical to the output buffer used by other destinations.) The <parameter>log-fifo-size()</parameter> parameter specifies the number of messages stored in the overflow queue. For details on sizing the <parameter>log-fifo-size()</parameter> parameter, see <xref linkend="concepts-flow-control"/>.</para>
            </listitem>
        </itemizedlist>
        <para>There are two types of flow-control: Hard flow-control and soft flow-control.</para>
        <itemizedlist>
            <listitem>
                <indexterm> <primary>flow-control</primary> <secondary>soft</secondary> </indexterm>
                <para><emphasis>Soft flow-control:</emphasis> In case of soft flow-control there is no message lost if the destination can accept messages, but it is possible to lose messages if it cannot accept messages (for example non-writeable file destination, or the disk becomes full), and all buffers are full. Soft flow-control cannot be configured, it is automatically available for file <phrase condition="pe"> and logstore </phrase>destinations.</para>
                <example>
                    <title>Soft flow-control</title>
                    <synopsis>source s_file { file("/tmp/input_file.log"); };
destination d_file { file("/tmp/output_file.log"); };
destination d_tcp { network("127.0.0.1" port(2222) log-fifo-size(1000)); };
log { source(s_file); destination(d_file); destination(d_tcp); };
</synopsis>
                </example>
                <warning>
                    <para>Hazard of data loss! For destinations other than file<phrase condition="pe"> and logstore</phrase>, soft flow-control is not available. Thus, it is possible to lose log messages on those destinations. To avoid data loss on those destinations, use hard flow-control.</para>
                </warning>
            </listitem>
            <listitem>
                <indexterm> <primary>flow-control</primary> <secondary>hard</secondary> </indexterm>
                <para><emphasis>Hard flow-control:</emphasis> In case of hard flow-control there is no message lost. To use hard flow-control, enable the <parameter>flow-control</parameter> flag in the log path. Hard flow-control is available for all destinations.</para>
                <example>
                    <title>Hard flow-control</title>
                    <synopsis>source s_file { file("/tmp/input_file.log"); };
destination d_file { file("/tmp/output_file.log"); };
destination d_tcp { network("127.0.0.1" port(2222) log-fifo-size(1000)); };
log { source(s_file); destination(d_file); destination(d_tcp); flags(flow-control); };
</synopsis>
                </example>
            </listitem>
        </itemizedlist>
        <xi:include href="../../shared/chunk/flow-control-multiple-destinations.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="configuring-flow-control">
            <title>Configuring flow-control</title>
            <indexterm> <primary>log paths</primary> <secondary>flow-control</secondary> </indexterm>
            <indexterm> <primary>flow-control</primary> </indexterm>
            <indexterm> <primary>preventing message loss</primary> <secondary>flow-control</secondary> </indexterm>
            <indexterm> <primary>parameters</primary> <secondary><parameter>log-fetch-limit()</parameter></secondary> </indexterm>
            <indexterm> <primary>parameters</primary> <secondary><parameter>log-fifo-size()</parameter></secondary> </indexterm>
            <indexterm> <primary>parameters</primary> <secondary><parameter>log-iw-size()</parameter></secondary> </indexterm>
            <indexterm> <primary>parameters</primary> <secondary><parameter>max-connections()</parameter></secondary> </indexterm>
            <indexterm> <primary>output buffer</primary> </indexterm>
            <para>For details on how flow-control works, see <xref linkend="concepts-flow-control"/>. The summary of the main points is as follows:</para>
            <itemizedlist>
                <listitem>
                    <para>The syslog-ng application normally reads a maximum of <parameter>log-fetch-limit()</parameter> number of messages from a source.</para>
                </listitem>
                <listitem>
                    <para>From TCP and unix-stream sources, syslog-ng reads a maximum of <parameter>log-fetch-limit()</parameter> from every connection of the source. The number of connections to the source is set using the <parameter>max-connections()</parameter> parameter.</para>
                </listitem>
                <listitem>
                    <para>Every destination has an output buffer (<parameter>log-fifo-size()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>Flow-control uses a control window to determine if there is free space in the output buffer for new messages. Every source has its own control window, the <parameter>log-iw-size()</parameter> parameter sets the size of the control window.</para>
                </listitem>
                <listitem>
                    <para>When a source accepts multiple connections, the size of the control window is divided by the value of the <parameter>max-connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
                </listitem>
                <listitem>
                    <para>The output buffer must be larger than the control window of every source that logs to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the control window is full, syslog-ng stops reading messages from the source until some messages are successfully sent to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the output buffer becomes full, and <phrase condition="pe">neither disk-buffering nor flow-control is</phrase> <phrase condition="ose">flow-control is not</phrase> used, messages may be lost.</para>
                </listitem>
            </itemizedlist>
            <warning>
                <para>If you modify the <parameter>max-connections()</parameter> or the <parameter>log-fetch-limit()</parameter> parameter, do not forget to adjust the <parameter>log-iw-size()</parameter> and <parameter>log-fifo-size()</parameter> parameters accordingly.</para>
            </warning>
            <example>
                <title>Sizing parameters for flow-control</title>
                <indexterm> <primary>log paths</primary> <secondary>flow-control</secondary> </indexterm>
                <indexterm> <primary>flow-control</primary> <secondary>example</secondary> </indexterm>
                <para>Suppose that syslog-ng has a source that must accept up to 300 parallel connections. Such situation can arise when a network source receives connections from many clients, or if many applications log to the same socket. Therefore, set the <parameter>max-connections()</parameter> parameter of the source to <userinput>300</userinput>. However, the <parameter>log-fetch-limit()</parameter> (default value: 10) parameter applies to every connection of the source individually, while the <parameter>log-iw-size()</parameter> (default value: 1000) parameter applies to the source. In a worst-case scenario, the destination does not accept any messages, while all 300 connections send at least <parameter>log-fetch-limit()</parameter> number of messages to the source during every poll loop. Therefore, the control window must accommodate at least <parameter>max-connections()</parameter>*<parameter>log-fetch-limit()</parameter> messages to be able to read every incoming message of a poll loop. In the current example this means that (<parameter>log-iw-size()</parameter> should be greater than <userinput>300*10=3000</userinput>. If the control window is smaller than this value, the control window might fill up with messages from the first connections &mdash; causing syslog-ng to read only one message of the last connections in every poll loop.</para>
                <para>The output buffer of the destination must accommodate at least <parameter>log-iw-size()</parameter> messages, but use a greater value: in the current example <userinput>3000*10=30000</userinput> messages. That way all incoming messages of ten poll loops fit in the output buffer. If the output buffer is full, syslog-ng does not read any messages from the source until some messages are successfully sent to the destination.</para>
                <synopsis>source s_localhost {
            network(ip(127.0.0.1) port(1999) max-connections(300)); };
destination d_tcp {
            network("10.1.2.3" port(1999) localport(999) log-fifo-size(30000)); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
                <para>If other sources send messages to this destination, then the output buffer must be further increased. For example, if a network host with maximum <userinput>100</userinput> connections also logs into the destination, then increase the <parameter>log-fifo-size()</parameter> by <userinput>10000</userinput>.</para>
                <synopsis>source s_localhost {
            network(ip(127.0.0.1) port(1999) max-connections(300)); };
source s_tcp {
            network(ip(192.168.1.5) port(1999) max-connections(100)); };
destination d_tcp {
            network("10.1.2.3" port(1999) localport(999) log-fifo-size(40000)); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
            </example>
        </section>
    </section>
    <section xml:id="concepts-diskbuffer">
        <title>Using disk-based and memory buffering</title>
        <indexterm significance="preferred"> <primary>disk buffer</primary> </indexterm>
        <indexterm> <primary>disk-based buffering</primary> </indexterm>
        <indexterm> <primary>parameters</primary> <secondary>log-disk-fifo-size()</secondary> </indexterm>
        <!-- FIXME should be merged/streamlined with the flow control section -->
        <para>The &product; application can store messages on the local hard disk if the destination (for example, the central log server) or the network connection to the destination becomes unavailable. The &abbrev; application automatically sends the stored messages to the destination when the connection is reestablished. The disk buffer is used as a queue: when the connection to the destination is reestablished, &abbrev; sends the messages to the destination in the order they were received.</para>
        <note>
            <para>Disk-based buffering can be used in conjunction with flow-control. For details on flow-control, see <xref linkend="concepts-flow-control"/>.</para>
        </note>
        <xi:include href="../../shared/chunk/p-disk-buffer-drivers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <para>Every such destination uses a separate disk buffer (similarly to the output buffers controlled by <parameter>log-fifo-size()</parameter>). The hard disk space is not pre-allocated, so ensure that there is always enough free space to store the disk buffers even when the disk buffers are full.</para>
        <para>If &abbrev; is restarted (using the <command>/etc/init.d/syslog-ng restart</command> command, or another appropriate command on your platform), it automatically saves any unsent messages from the disk buffer and the output queue. After the restart, &abbrev; sends the saved messages to the destination. In other words, the disk buffer is persistent. The disk buffer is also resistant to &abbrev; crashes.</para>
        <para>The &abbrev; application supports two types of disk buffering: reliable and normal. For details, see <xref linkend="configuring-diskbuffer-reliable"/> and <xref linkend="configuring-diskbuffer-normal"/>, respectively.</para>
        <formalpara>
            <title>Message handling and normal disk-based buffering</title>
            <para>When you use disk-based buffering, and the <parameter>reliable()</parameter> option is set to <userinput>no</userinput>, &abbrev; handles outgoing messages the following way:</para>
        </formalpara>
        <figure>
            <title>Handling outgoing messages in &abbrev;</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="syslog-ng-message-output.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" scale="60" fileref="&imgroot;/syslog-ng-message-output.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <indexterm> <primary>output queue</primary> </indexterm>
                <para><emphasis>Output queue</emphasis>: Messages from the output queue are sent to the destination (for example, your central log server). The &abbrev; application puts the outgoing messages directly into the output queue, unless the output queue is full. By default, the output queue can hold 64 messages (you can adjust it using the <parameter>quot-size()</parameter> option).</para>
            </listitem>
            <listitem>
                <indexterm> <primary>disk queue</primary> <see>disk buffer</see> </indexterm>
                <para><emphasis>Disk buffer</emphasis>: If the output queue is full, disk-buffering is enabled, and <parameter>reliable()</parameter> is set to <userinput>no</userinput>, &abbrev; puts the outgoing messages into the disk buffer of the destination. (The disk buffer is enabled if the <parameter>disk-buffer()</parameter> option is configured.)</para>
            </listitem>
            <listitem>
                <indexterm> <primary>overflow queue</primary> <see>output buffer</see> </indexterm>
                <para><emphasis>Overflow queue</emphasis>: If the output queue is full and the disk buffer is disabled or full, &abbrev; puts the outgoing messages into the overflow queue of the destination. (The overflow queue is identical to the output buffer used by other destinations.) The <parameter>log-fifo-size()</parameter> parameter specifies the number of messages stored in the overflow queue. For details on sizing the <parameter>log-fifo-size()</parameter> parameter, see also <xref linkend="concepts-flow-control"/>.</para>
            </listitem>
        </itemizedlist>
        <note>
            <para>Using disk buffer can significantly decrease performance.</para>
        </note>
        <formalpara>
            <title>Message handling and reliable disk-based buffering</title>
            <para>When you use disk-based buffering, and the <parameter>reliable()</parameter> option is set to <userinput>yes</userinput>, &abbrev; handles outgoing messages the following way.</para>
        </formalpara>
        <!-- FIXME figure/low-chart needed -->
        <para>The <parameter>mem-buf-size()</parameter> option determines when flow-control is triggered. All messages arriving to the log path that includes the destination using the disk-buffer are written into the disk-buffer, until the size of the disk-buffer reaches (<parameter>disk-buf-size()</parameter> minus <parameter>mem-buf-size()</parameter>). Above that size, messages are written into both the disk-buffer and the memory-buffer, indicating that flow-control needs to slow down the message source. These messages are not taken out from the control window (governed by <parameter>log-iw-size()</parameter>), causing the control window to fill up. If the control window is full, the flow-control completely stops reading incoming messages from the source. (As a result, <parameter>mem-buf-size()</parameter> must be at least as large as <parameter>log-iw-size()</parameter>.)</para>
        <section xml:id="configuring-diskbuffer-reliable">
            <title>Enabling reliable disk-based buffering</title>
            <xi:include href="../../shared/chunk/p-disk-buffer-drivers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <para>To enable reliable disk-based buffering, use the <userinput>disk-buffer(reliable(yes))</userinput> parameter in the destination. Use reliable disk-based buffering if you do not want to lose logs in case of reload/restart, unreachable destination or &abbrev; crash. This solution provides a slower, but reliable disk-buffer option. It is created and initialized at startup and gradually grows as new messages arrive. The filename of the reliable disk buffer file is the following: <filename>&lt;syslog-ng path&gt;/var/syslog-ng-00000.rqf</filename>.</para>
            <example>
                <title>Example for using reliable disk-based buffering</title>
                <synopsis>destination d_BSD {
    network(
            "127.0.0.1"
            port(3333)
            disk-buffer(
                mem-buf-size(10000)
                disk-buf-size(2000000)
                reliable(yes)
            )
        );
}; </synopsis>
            </example>
            <para>For details on the differences between normal and reliable disk-based buffering, see also <xref linkend="about-disk-buffer-files"/>.</para>
        </section>
        <section xml:id="configuring-diskbuffer-normal">
            <title>Enabling normal disk-based buffering</title>
            <xi:include href="../../shared/chunk/p-disk-buffer-drivers.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <para>To enable normal disk-based buffering, use the <userinput>disk-buffer(reliable(no))</userinput> parameter in the destination. Use normal disk-based buffering if you want a solution that is faster than the reliable disk-based buffering. In this case, disk buffering will be less reliable and it is possible to lose logs in case of &abbrev; crash. The filename of the normal disk buffer file is the following: <filename>&lt;syslog-ng path&gt;/var/syslog-ng-00000.qf</filename>.</para>
            <example>
                <title>Example for using normal disk-based buffering</title>
                <para>When using the disk-buffer plugin:</para>
                <synopsis>destination d_BSD {
    network(
            "127.0.0.1"
            port(3333)
            disk-buffer(
                mem-buf-length(10000)
                disk-buf-size(2000000)
                reliable(no)
            )
        );
        }; </synopsis>
            </example>
            <para>For details on the differences between normal and reliable disk-based buffering, see also <xref linkend="about-disk-buffer-files"/>.</para>
        </section>
        <section xml:id="configuring-diskbuffer-memory">
            <title>Enabling memory buffering</title>
            <para>To enable memory buffering, use the <parameter>log-fifo-size()</parameter> parameter in the destination. All destination drivers can use memory buffering. Use memory buffering if you want to send logs to destinations where disk-based buffering is not available. Or if you want the fastest solution, and if &abbrev; crash or network downtime is never expected. In these cases, losing logs is possible. This solution does not use disk-based buffering, logs are stored only in the memory.</para>
            <example>
                <title>Example for using memory buffering</title>
                <synopsis>destination d_BSD {
    network(
            "127.0.0.1"
            port(3333)
            log-fifo-size(10000)
        );
};</synopsis>
            </example>
        </section>
        <section xml:id="about-disk-buffer-files">
            <title>About disk queue files</title>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../shared/chunk/topic-about-disk-queue-files.xml"/>
        </section>
    </section>
    <section xml:id="filters">
        <title>Filters</title>
        <indexterm significance="preferred"> <primary>filters</primary> </indexterm>
        <indexterm significance="preferred"> <primary>regular expressions</primary> </indexterm>
        <para>The following sections describe how to select and filter log messages.</para>
        <itemizedlist>
            <listitem>
                <para><xref linkend="configuring-filters"/> describes how to configure and use filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-boolean"/> shows how to create complex filters using boolean operators.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-comparing"/> explains how to evaluate macros in filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="regular-expr"/> provides tips on using regular expressions.</para>
            </listitem>
            <listitem>
                <para><xref linkend="tagging-messages"/> explains how to tag messages and how to filter on the tags.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-filters"/> is a detailed description of the filter functions available in &abbrev;.</para>
            </listitem>
        </itemizedlist>
        <section xml:id="configuring-filters">
            <title>Using filters</title>
            <para>Filters perform log routing within syslog-ng: a message passes the filter if the filter expression is true for the particular message. If a log statement includes filters, the messages are sent to the destinations only if they pass all filters of the log path. For example, a filter can select only the messages originating from a particular host. Complex filters can be created using filter functions and logical boolean expressions.</para>
            <para>To define a filter, add a filter statement to the syslog-ng configuration file using the following syntax:</para>
            <indexterm> <primary>filters</primary> <secondary>defining</secondary> </indexterm>
            <synopsis>filter &lt;identifier&gt; { &lt;filter_type&gt;("&lt;filter_expression&gt;"); };</synopsis>
            <para>Then use the filter in a log path, for example:</para>
            <synopsis>log {
    source(s1);
    filter(&lt;identifier&gt;);
    destination(d1); };</synopsis>
            <para>You can also define the filter inline. For details, see <xref linkend="inline-objects"/>.</para>
            <example>
                <title>A simple filter statement</title>
                <para>The following filter statement selects the messages that contain the word <userinput>deny</userinput> and come from the host <userinput>example</userinput>.</para>
                <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")) };
log {
    source(s1);
    filter(demo_filter);
    destination(d1); };</synopsis>
                <para>The following example does the same, but defines the filter inline.</para>
                <synopsis>log {
    source(s1);
    filter { host("example") and match("deny" value("MESSAGE")) };
    destination(d1); };</synopsis>
            </example>
        </section>
        <section xml:id="filters-boolean">
            <title>Combining filters with boolean operators</title>
            <indexterm> <primary>filters</primary> <secondary>boolean operators</secondary> </indexterm>
            <indexterm> <primary>filters</primary> <secondary>AND, OR, NOT</secondary> </indexterm>
            <indexterm> <primary>boolean operators</primary> </indexterm>
            <indexterm type="parameter"> <primary>AND</primary> </indexterm>
            <indexterm type="parameter"> <primary>OR</primary> </indexterm>
            <indexterm type="parameter"> <primary>NOT</primary> </indexterm>
            <para>When a log statement includes multiple filter statements, syslog-ng sends a message to the destination only if all filters are true for the message. In other words, the filters are connected with the logical <userinput>AND</userinput> operator. In the following example, no message arrives to the destination, because the filters are exclusive (the hostname of a client cannot be <userinput>example1</userinput> and <userinput>example2</userinput> at the same time):</para>
            <synopsis>filter demo_filter1 { host("example1"); };
filter demo_filter2 { host("example2"); };
log {
    source(s1); source(s2);
    filter(demo_filter1); filter(demo_filter2);
    destination(d1); destination(d2); };</synopsis>
            <para>To select the messages that come from either host <userinput>example1</userinput> or <userinput>example2</userinput>, use a single filter expression:</para>
            <synopsis>filter demo_filter { host("example1") or host("example2"); };
log {
    source(s1); source(s2);
    filter(demo_filter);
    destination(d1); destination(d2); };</synopsis>
            <para>Use the <userinput>not</userinput> operator to invert filters, for example, to select the messages that were not sent by host <userinput>example1</userinput>:</para>
            <synopsis>filter demo_filter { not host("example1"); };</synopsis>
            <para>However, to select the messages that were not sent by host <userinput>example1</userinput> or <userinput>example2</userinput>, you have to use the <userinput>and</userinput> operator (that's how boolean logic works):</para>
            <synopsis>filter demo_filter { not host("example1") and not host("example2"); };</synopsis>
            <para>Alternatively, you can use parentheses to avoid this confusion:</para>
            <synopsis>filter demo_filter { not (host("example1") or host("example2")); };</synopsis>
            <para>For a complete description on filter functions, see <xref linkend="reference-filters"/>.</para>
            <para>The following filter statement selects the messages that contain the word <userinput>deny</userinput> and come from the host <userinput>example</userinput>.</para>
            <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")); };</synopsis>
            <para>The <parameter>value()</parameter> parameter of the <parameter>match</parameter> function limits the scope of the function to the text part of the message (that is, the part returned by the <parameter>${MESSAGE}</parameter> macro). For details on using the <parameter>match()</parameter> filter function, see <xref linkend="reference-filters-match"/>.</para>
            <tip>
                <para>Filters are often used together with log path flags. For details, see <xref linkend="reference-logflags"/>.</para>
            </tip>
        </section>
        <section xml:id="filters-comparing">
            <title>Comparing macro values in filters</title>
            <indexterm> <primary>filters</primary> <secondary>comparing values</secondary> </indexterm>
            <indexterm type="parameter"> <primary>ge</primary> </indexterm>
            <indexterm type="parameter"> <primary>gt</primary> </indexterm>
            <indexterm type="parameter"> <primary>eq</primary> </indexterm>
            <indexterm type="parameter"> <primary>ne</primary> </indexterm>
            <indexterm type="parameter"> <primary>le</primary> </indexterm>
            <indexterm type="parameter"> <primary>lt</primary> </indexterm>
            <indexterm> <primary>string comparison</primary> </indexterm>
            <indexterm> <primary>value comparison</primary> </indexterm>
            <indexterm> <primary>comparing values</primary> </indexterm>
            <indexterm> <primary>filters</primary> <secondary>comparing values</secondary> </indexterm>
            <para>Starting with &abbrev; version <phrase condition="ose">3.2</phrase><phrase condition="pe">4 F1</phrase>, it is also possible to compare macro values and templates as numerical and string values. String comparison is alphabetical: it determines if a string is alphabetically greater or equal to another string. Use the following syntax to compare macro values or templates. For details on macros and templates, see <xref linkend="customizing-message-format"/>.</para>
            <synopsis>filter &lt;filter-id&gt;
        {"&lt;macro-or-template&gt;" operator "&lt;value-or-macro-or-template&gt;"};</synopsis>
            <example xml:id="example-comparison">
                <title>Comparing macro values in filters</title>
                <para>The following expression selects log messages containing a PID (that is, <parameter>${PID}</parameter> macro is not empty):</para>
                <synopsis>filter f_pid {"${PID}" !=""};</synopsis>
                <para>The following expression selects log messages that do not contain a PID. Also, it uses a template as the left argument of the operator and compares the values as strings:</para>
                <synopsis>filter f_pid {"${HOST}${PID}" eq "${HOST}"};</synopsis>
                <para>The following example selects messages with priority level higher than 5.</para>
                <synopsis>filter f_level {"${LEVEL_NUM}" &gt; "5"};</synopsis>
            </example>
            <para>Note that:</para>
            <itemizedlist>
                <listitem>
                    <para>The macro or template must be enclosed in double-quotes.</para>
                </listitem>
                <listitem>
                    <para>The <userinput>$</userinput> character must be used before macros.</para>
                </listitem>
                <listitem>
                    <para>Using comparator operators can be equivalent to using filter functions, but is somewhat slower. For example, using <userinput>"${HOST}" eq "myhost"</userinput> is equivalent to using <userinput>host("myhost" type(string))</userinput>.</para>
                </listitem>
                <listitem>
                    <para>You can use any macro in the expression, including user-defined macros from parsers and results of pattern database classifications.</para>
                </listitem>
                <listitem>
                    <para>The results of filter functions are boolean values, so they cannot be compared to other values.</para>
                </listitem>
                <listitem>
                    <para>You can use boolean operators to combine comparison expressions.</para>
                    <!-- FIXME add a working example-->
                </listitem>
            </itemizedlist>
            <para>The following operators are available:</para>
            <table>
                <title>Numerical and string comparison operators</title>
                <?dbfo keep-together="auto" ?>
                <tgroup cols="3">
                    <thead>
                        <row>
                            <entry>Numerical operator</entry>
                            <entry>String operator</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>==</entry>
                            <entry>eq</entry>
                            <entry>Equals</entry>
                        </row>
                        <row>
                            <entry>!=</entry>
                            <entry>ne</entry>
                            <entry>Not equal to</entry>
                        </row>
                        <row>
                            <entry>&gt;</entry>
                            <entry>gt</entry>
                            <entry>Greater than</entry>
                        </row>
                        <row>
                            <entry>&lt;</entry>
                            <entry>lt</entry>
                            <entry>Less than</entry>
                        </row>
                        <row>
                            <entry>&gt;=</entry>
                            <entry>ge</entry>
                            <entry>Greater than or equal</entry>
                        </row>
                        <row>
                            <entry>=&lt;</entry>
                            <entry>le</entry>
                            <entry>Less than or equal</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section xml:id="regular-expr">
            <title>Using wildcards, special characters, and regular expressions in filters</title>
            <indexterm> <primary>regular expressions</primary> </indexterm>
            <para>The <parameter>host()</parameter>, <parameter>match()</parameter>, and <parameter>program()</parameter> filter functions accept regular expressions as parameters. The exact type of the regular expression to use can be specified with the <parameter>type()</parameter> option. By default, &abbrev; uses PCRE regular expressions.</para>
            <indexterm> <primary>filters</primary> <secondary>wildcards</secondary> </indexterm>
            <para>In regular expressions, the asterisk (<userinput>*</userinput>) character means 0, 1, or any number of the previous expression. For example, in the <userinput>f*ilter</userinput> expression the asterisk means 0 or more f letters. This expression matches for the following strings: <userinput>ilter</userinput>, <userinput>filter</userinput>, <userinput>ffilter</userinput>, and so on. To achieve the wildcard functionality commonly represented by the asterisk character in other applications, use <userinput>.*</userinput> in your expressions, for example <userinput>f.*ilter</userinput>.</para>
            <para>Alternatively, if you do not need regular expressions, only wildcards, use <userinput>type(glob)</userinput> in your filter:</para>
            <example xml:id="example-wildcard-filter">
                <title>Filtering with widcards</title>
                <para>The following filter matches on hostnames starting with the <userinput>myhost</userinput> string, for example, on <userinput>myhost-1</userinput>, <userinput>myhost-2</userinput>, and so on.</para>
                <synopsis>filter f_wildcard {host("myhost*" type(glob));};</synopsis>
            </example>
            <para>For details on using regular expressions in &abbrev;, see <xref linkend="regular-expr"/>.</para>
            <indexterm> <primary>filters</primary> <secondary>control characters</secondary> </indexterm>
            <para>To filter for special control characters like the carriage return (CR), use the <userinput>\r</userinput> escape prefix in &abbrev; version 3.0 and 3.1. In &abbrev; 3.2 and later, you can also use the <userinput>\x</userinput> escape prefix and the ASCII code of the character. For example, to filter on carriage returns, use the following filter:</para>
            <synopsis>filter f_carriage_return {match("\x0d" value ("MESSAGE"));};</synopsis>
        </section>
        <section xml:id="tagging-messages">
            <title>Tagging messages</title>
            <indexterm> <primary>filters</primary> <secondary>tags</secondary> </indexterm>
            <indexterm> <primary>tagging messages</primary> </indexterm>
            <indexterm> <primary>tags</primary> </indexterm>
            <para>You can label the messages with custom tags. Tags are simple labels, identified by their names, which must be unique. Currently &abbrev; can tag a message at two different places:</para>
            <itemizedlist>
                <listitem>
                    <para>at the source when the message is received, and</para>
                </listitem>
                <listitem>
                    <para>when the message matches a pattern in the pattern database. For details on using the pattern database, see <xref linkend="configuring-pattern-databases"/>, for details on creating tags in the pattern database, see <xref linkend="reference-patterndb-schemes"/>.</para>
                </listitem>
                <listitem>
                    <para>Tags can be also added and deleted using rewrite rules. For details, see <xref linkend="rewrite-tags"/>.</para>
                </listitem>
            </itemizedlist>
            <para>When syslog-ng receives a message, it automatically adds the <userinput>.source.&lt;id_of_the_source_statement&gt;</userinput> tag to the message. Use the <parameter>tags()</parameter> option of the source to add custom tags, and the <parameter>tags()</parameter> option of the filters to select only specific messages.</para>
            <note>
                <itemizedlist>
                    <listitem>
                        <para>Tagging messages and also filtering on the tags is very fast, much faster than other types of filters.</para>
                    </listitem>
                    <listitem>
                        <para>Tags are available locally, that is, if you add tags to a message on the client, these tags will not be available on the server.</para>
                    </listitem>
                    <listitem>
                        <para>To include the tags in the message, use the <parameter>${TAGS}</parameter> macro in a template. Alternatively, if you are using the IETF-syslog message format, you can include the <parameter>${TAGS}</parameter> macro in the <parameter>.SDATA.meta</parameter> part of the message. Note that the <parameter>${TAGS}</parameter> macro is available only in &abbrev; 3.1.1 and later.</para>
                    </listitem>
                </itemizedlist>
            </note>
            <para>For an example on tagging, see <xref linkend="example-tags-filtering"/>.</para>
        </section>
        <section xml:id="reference-filters">
            <title>Filter functions</title>
            <indexterm> <primary>filters</primary> <secondary>reference</secondary> </indexterm>
            <para>The following functions may be used in the filter statement, as described in <xref linkend="filters"/>.</para>
            <xi:include href="../../shared/chunk/table-filter-functions.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <simplesect xml:id="filter-facility">
                <title>facility()</title>
                <indexterm type="parameter"> <primary>facility()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>facility(&lt;facility-name&gt;) or facility(&lt;facility-code&gt;) or facility(&lt;facility-name&gt;..&lt;facility-name&gt;)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match messages having one of the listed facility codes.</para>
                <indexterm> <primary>filters</primary> <secondary>facilities, </secondary> </indexterm>
                <para>The <parameter>facility()</parameter> filter accepts both the name and the numerical code of the facility or the importance level. Facility codes 0-23 are predefined and can be referenced by their usual name. Facility codes above 24 are not defined.</para>
                <para>You can use the facility filter the following ways:</para>
                <itemizedlist>
                    <listitem>
                        <para>Use a single facility name, for example, <userinput>facility(user)</userinput></para>
                    </listitem>
                    <listitem>
                        <para>Use a single facility code, for example, <userinput>facility(1)</userinput></para>
                    </listitem>
                    <listitem>
                        <para>Use a facility range (works only with facility names), for example, <userinput>facility(local0..local5)</userinput></para>
                    </listitem>
                </itemizedlist>
                <para>The syslog-ng application recognizes the following facilities: (Note that some of these facilities are available only on specific platforms.)</para>
                <!-- FIXME authpriv -->
                <table>
                    <title>syslog Message Facilities recognized by the facility() filter</title>
                    <?dbfo keep-together="auto" ?>
                    <indexterm> <primary>facilities</primary> </indexterm>
                    <indexterm> <primary>message facilities</primary> </indexterm>
                    <tgroup cols="3">
                        <thead>
                            <row>
                                <entry>Numerical Code</entry>
                                <entry>Facility name</entry>
                                <entry>Facility</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>0</entry>
                                <entry>kern</entry>
                                <entry>kernel messages</entry>
                            </row>
                            <row>
                                <entry>1</entry>
                                <entry>user</entry>
                                <entry>user-level messages</entry>
                            </row>
                            <row>
                                <entry>2</entry>
                                <entry>mail</entry>
                                <entry>mail system</entry>
                            </row>
                            <row>
                                <entry>3</entry>
                                <entry>daemon</entry>
                                <entry>system daemons</entry>
                            </row>
                            <row>
                                <entry>4</entry>
                                <entry>auth</entry>
                                <entry>security/authorization messages</entry>
                            </row>
                            <row>
                                <entry>5</entry>
                                <entry>syslog</entry>
                                <entry>messages generated internally by syslogd</entry>
                            </row>
                            <row>
                                <entry>6</entry>
                                <entry>lpr</entry>
                                <entry>line printer subsystem</entry>
                            </row>
                            <row>
                                <entry>7</entry>
                                <entry>news</entry>
                                <entry>network news subsystem</entry>
                            </row>
                            <row>
                                <entry>8</entry>
                                <entry>uucp</entry>
                                <entry>UUCP subsystem</entry>
                            </row>
                            <row>
                                <entry>9</entry>
                                <entry>cron</entry>
                                <entry>clock daemon</entry>
                            </row>
                            <row>
                                <entry>10</entry>
                                <entry>authpriv</entry>
                                <entry>security/authorization messages</entry>
                            </row>
                            <row>
                                <entry>11</entry>
                                <entry>ftp</entry>
                                <entry>FTP daemon</entry>
                            </row>
                            <row>
                                <entry>12</entry>
                                <entry>ntp</entry>
                                <entry>NTP subsystem</entry>
                            </row>
                            <row>
                                <entry>13</entry>
                                <entry>security</entry>
                                <entry>log audit</entry>
                            </row>
                            <row>
                                <entry>14</entry>
                                <entry>console</entry>
                                <entry>log alert</entry>
                            </row>
                            <row>
                                <entry>15</entry>
                                <entry>solaris-cron</entry>
                                <entry>clock daemon</entry>
                            </row>
                            <row>
                                <entry>16-23</entry>
                                <entry>local0..local7</entry>
                                <entry>locally used facilities (local0-local7)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </simplesect>
            <simplesect xml:id="filter-filter">
                <title>filter()</title>
                <indexterm type="parameter"> <primary>filter()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>filter(filtername)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Call another filter rule and evaluate its value. For example:</para>
                <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")) };
filter inverted_demo_filter { NOT filter(demo_filter) }</synopsis>
            </simplesect>
            <simplesect xml:id="filter-host">
                <title>host()</title>
                <indexterm type="parameter"> <primary>host()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>host(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match messages by using a regular expression against the hostname field of log messages. Note that you can filter only on the actual content of the HOST field of the message (or what it was rewritten to). That is, &abbrev; will compare the filter expression to the content of the ${HOST} macro. This means that for the IP address of a host will not match, even if the IP address and the hostname field refers to the same host. To filter on IP addresses, use the <link xmlns:ns1="http://www.w3.org/1999/xlink" linkend="filter-netmask"><parameter>netmask()</parameter></link> filter.</para>
                <synopsis>filter demo_filter { host("example") };</synopsis>
            </simplesect>
            <simplesect xml:id="filter-inlist">
                <title>inlist()</title>
                <indexterm type="parameter"> <primary>inlist()</primary> </indexterm>
                <indexterm> <primary>filters</primary> <secondary>blacklisting</secondary> </indexterm>
                <indexterm> <primary>filters</primary> <secondary>whitelisting</secondary> </indexterm>
                <indexterm> <primary>filters</primary> <secondary>in-list()</secondary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>in-list("&lt;/path/to/file.list&gt;", value("&lt;field-to-filter&gt;"))</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Matches the value of the specified field to a list stored in a file, allowing you to do simple, file-based black- and whitelisting. The file must be a plain-text file, containing one entry per line. The &abbrev; application loads the entire file, and compares the value of the specified field (for example, ${PROGRAM}) to entries in the file. When you use the <parameter>in-list filter</parameter>, note the following points:</para>
                <itemizedlist>
                    <listitem>
                        <para>Comparing the values is case-sensitive.</para>
                    </listitem>
                    <listitem>
                        <para>Only exact matches are supported, partial and substring matches are not.</para>
                    </listitem>
                    <listitem>
                        <para>If you modify the list file, reload the configuration of &abbrev; for the changes to take effect.</para>
                    </listitem>
                </itemizedlist>
                <para>Available in &abbrev; <phrase condition="ose">3.5</phrase> and later.</para>
                <example xml:id="example-whitelist-filter">
                    <title>Selecting messages using the in-list filter</title>
                    <para>Create a text file that contains the programs (as in the ${PROGRAM} field of their log messages) you want to select. For example, you want to forward only the logs of a few applications from a host: kernel, sshd, and sudo. Create the <filename>/etc/syslog-ng/programlist.list</filename> file with the following contents:</para>
                    <synopsis>kernel
sshd
sudo</synopsis>
                    <para>The following filter selects only the messages of the listed applications:</para>
                    <synopsis>filter f_whitelist { in-list("/etc/syslog-ng/programlist.list", value("PROGRAM")); };</synopsis>
                    <para>Create the appropriate sources and destinations for your environment, then create a log path that uses the previous filter to select only the log messages of the applications you need:</para>
                    <synopsis>log {
    source(s_all);
    filter(f_whitelist);
    destination(d_logserver); };</synopsis>
                    <para>To create a blacklist filter, simply negate the <parameter>in-list</parameter> filter:</para>
                    <synopsis>filter f_blacklist { not in-list("/etc/syslog-ng/programlist.list", value("PROGRAM")); };</synopsis>
                </example>
            </simplesect>
            <simplesect xml:id="filter-priority">
                <title>level() or priority()</title>
                <indexterm type="parameter"> <primary>level() or priority()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>level(&lt;priority-level&gt;) or level(&lt;priority-level&gt;..&lt;priority-level&gt;)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> The <parameter>level()</parameter> filter selects messages corresponding to a single importance level, or a level-range. To select messages of a specific level, use the name of the level as a filter parameter, for example use the following to select warning messages:</para>
                <synopsis>level(warning)</synopsis>
                <indexterm> <primary>filters</primary> <secondary>facility and priority (level) ranges</secondary> </indexterm>
                <para>To select a range of levels, include the beginning and the ending level in the filter, separated with two dots (<userinput>..</userinput>). For example, to select every message of error or higher level, use the following filter:</para>
                <synopsis>level(err..emerg)</synopsis>
                <indexterm> <primary>filters</primary> <secondary>priorities</secondary> </indexterm>
                <para>The <parameter>level()</parameter> filter accepts the following levels: <parameter>emerg</parameter>, <parameter>alert</parameter>, <parameter>crit</parameter>, <parameter>err</parameter>, <parameter>warning</parameter>, <parameter>notice</parameter>, <parameter>info</parameter>, <parameter>debug</parameter>.</para>
            </simplesect>
            <simplesect xml:id="reference-filters-match">
                <title>match()</title>
                <indexterm type="parameter"> <primary>match()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>match(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match a regular expression to the headers and the message itself (that is, the values returned by the <parameter>MSGHDR</parameter> and <parameter>MSG</parameter> macros). Note that in syslog-ng version 2.1 and earlier, the <parameter>match()</parameter> filter was applied only to the text of the message, excluding the headers. This functionality has been moved to the <parameter>message()</parameter> filter.</para>
                <indexterm type="parameter"> <primary>value()</primary> </indexterm>
                <para>To limit the scope of the match to a specific part of the message (identified with a macro), use the <userinput>match(regexp value("MACRO"))</userinput> syntax. Do not include the $ sign in the parameter of the <parameter>value()</parameter> option.</para>
                <para>The <parameter>value()</parameter> parameter accepts both built-in macros and user-defined ones created with a parser or using a pattern database. For details on macros and parsers, see <xref linkend="configuring-macros"/>, <xref linkend="csv-parser"/>, and <xref linkend="patterndb-filters"/>.</para>
            </simplesect>
            <simplesect xml:id="filter-message">
                <title>message()</title>
                <indexterm type="parameter"> <primary>message()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>message(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match a regular expression to the text of the log message, excluding the headers (that is, the value returned by the <parameter>MSG</parameter> macros). Note that in syslog-ng version 2.1 and earlier, this functionality was performed by the <parameter>match()</parameter> filter.</para>
            </simplesect>
            <simplesect xml:id="filter-netmask">
                <title>netmask()</title>
                <indexterm type="parameter"> <primary>netmask()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>netmask(ipv4/mask)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select only messages sent by a host whose IP address belongs to the specified IPv4 subnet. Note that this filter checks the IP address of the last-hop relay (the host that actually sent the message to &abbrev;), not the contents of the <parameter>HOST</parameter> field of the message. You can use both the dot-decimal and the CIDR notation to specify the netmask. For example, <userinput>192.168.5.0/255.255.255.0</userinput> or <userinput>192.168.5.0/24</userinput>. To filter IPv6 addresses, see <xref linkend="filter-netmask6"/>.</para>
            </simplesect>
            <simplesect xml:id="filter-netmask6">
                <title>netmask6()</title>
                <indexterm> <primary>netmask6()</primary> </indexterm>
                <indexterm> <primary>IPv6</primary> <secondary>filtering</secondary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>netmask6(ipv6/mask)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select only messages sent by a host whose IP address belongs to the specified IPv6 subnet. Note that this filter checks the IP address of the last-hop relay (the host that actually sent the message to &abbrev;), not the contents of the <parameter>HOST</parameter> field of the message. You can use both the regular and the compressed format to specify the IP address, for example, <userinput>1080:0:0:0:8:800:200C:417A</userinput> or <userinput>1080::8:800:200C:417A</userinput>. If you do not specify the address, <userinput>localhost</userinput> is used. Use the netmask (also called prefix) to specify how many of the leftmost bits of the address comprise the netmask (values 1-128 are valid). For example, the following specify a 60-bit prefix: <userinput>12AB:0000:0000:CD30:0000:0000:0000:0000/60</userinput> or <userinput>12AB::CD30:0:0:0:0/60</userinput>. Note that if you set an IP address and a prefix, &abbrev; will ignore the bits of the address after the prefix. To filter IPv4 addresses, see <xref linkend="filter-netmask"/>.</para>
                <para>The <parameter>netmask6()</parameter> filter is available in &abbrev; <phrase condition="pe">5.0.8 and 5.2.2</phrase><phrase condition="ose">3.7</phrase> and later.</para>
                <warning>
                    <para>If the IP address is not syntactically correct, the filter will never match. The &abbrev; application currently does not send a warning for such configuration errors.</para>
                </warning>
            </simplesect>
            <simplesect xml:id="filter-program">
                <title>program()</title>
                <indexterm type="parameter"> <primary>program()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>program(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match messages by using a regular expression against the program name field of log messages.</para>
            </simplesect>
            <simplesect xml:id="filter-source">
                <title>source()</title>
                <indexterm type="parameter"> <primary>source()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>source id</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select messages of a source statement. This filter can be used in embedded log statements if the parent statement contains multiple source groups &mdash; only messages originating from the selected source group are sent to the destination of the embedded log statement.</para>
            </simplesect>
            <simplesect xml:id="filter-tags">
                <title>tags()</title>
                <indexterm type="parameter"> <primary>tags()</primary> </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
                                    <?dbfo bgcolor="#D4D6EB" ?> </entry>
                                <entry>tag</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select messages labeled with the specified tag. Every message automatically has the tag of its source in <userinput>.source.&lt;id_of_the_source_statement&gt;</userinput> format. This option is available only in syslog-ng 3.1 and later.</para>
                <example xml:id="example-tags-filtering">
                    <title>Adding tags and filtering messages with tags</title>
                    <synopsis>source s_tcp {
    network(ip(192.168.1.1) port(1514) tags("tcp", "router"));
};</synopsis>
                    <para>Use the <parameter>tags()</parameter> option of the filters to select only specific messages:</para>
                    <synopsis>filter f_tcp {
    tags(".source.s_tcp");
};

filter f_router {
    tags("router");
};</synopsis>
                </example>
                <xi:include href="../../shared/wnt/note-patterndb-class-tag.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
        </section>
    </section>
    <section xml:id="example-dropping-messages">
        <title>Dropping messages</title>
        <indexterm> <primary>skipping messages</primary> </indexterm>
        <indexterm> <primary>dropping messages</primary> </indexterm>
        <indexterm> <primary>discarding messages</primary> </indexterm>
        <para>To skip the processing of a message without sending it to a destination, create a log statement with the appropriate filters, but do not include any destination in the statement, and use the <parameter>final</parameter> flag.</para>
        <example>
            <title>Skipping messages</title>
            <para>The following log statement drops all <parameter>debug</parameter> level messages without any further processing.</para>
            <synopsis>filter demo_debugfilter { level(debug); };
log { source(s_all); filter(demo_debugfilter); flags(final); };</synopsis>
        </example>
    </section>
</chapter>
