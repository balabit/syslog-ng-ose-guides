<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
 [  <!ENTITY % entities SYSTEM "../../common/syslog-ng-entities.ent">
 %entities;]>
<chapter xml:id="chapter-routing-filters" xmlns="http://docbook.org/ns/docbook" version="5.0">
    <title>Routing messages: log paths<phrase condition="pe">, reliability,</phrase> and filters</title>
<!-- FIXME jumplist -->
    <section xml:id="logpath">
        <title>Log paths</title>
        <indexterm significance="preferred">
            <primary>log paths</primary>
        </indexterm>
        <para>Log paths determine what happens with the incoming log messages. Messages coming from the sources listed in the log statement and matching all the filters are sent to the listed destinations.</para>
        <para>To define a log path, add a log statement to the syslog-ng configuration file using the following syntax:</para>
        <indexterm>
            <primary>log paths</primary>
            <secondary>defining</secondary>
        </indexterm>
        <xi:include href="../../common/chunk/synopsis-log-path.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <warning>
            <para>Log statements are processed in the order they appear in the configuration file, thus the order of log paths may influence what happens to a message, especially when using filters and log flags.</para>
        </warning>
        <xi:include href="../../common/wnt/note-element-order.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <example xml:id="log-statement-example">
            <title>A simple log statement</title>
            <xi:include href="../../common/chunk/log-statement.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        </example>
        <para>All matching log statements are processed by default, and the messages are sent to <emphasis>every</emphasis> matching destination by default. So a single log message might be sent to the same destination several times, provided the destination is listed in several log statements, and it can be also sent to several different destinations.</para>
        <indexterm>
            <primary>log paths</primary>
            <secondary>flags</secondary>
        </indexterm>
        <indexterm>
            <primary>flags</primary>
        </indexterm>
        <para>This default behavior can be changed using the <parameter>flags()</parameter> parameter. Flags apply to individual log paths; they are not global options. The following flags available in syslog-ng:</para>
        <itemizedlist>
            <listitem>
                <para><emphasis>final</emphasis>: Do not send the messages processed by this log path to any further destination.</para>
            </listitem>
            <listitem>
                <para><emphasis>fallback</emphasis>: Process messages that were not processed by other log paths.</para>
            </listitem>
            <listitem>
                <para><emphasis>catchall</emphasis>: Process every message, regardless of its source or if it was already processed by other log paths.</para>
            </listitem>
            <listitem>
                <para><emphasis>flow-control</emphasis>: Stop reading messages from the source if the destination cannot accept them. For details, see <xref linkend="concepts-flow-control"/>.</para>
            </listitem>
        </itemizedlist>
        <para>For details on the individual flags, see <xref linkend="reference-logflags"/>. The effect and use of the <parameter>flow-control</parameter> flag is detailed in <xref linkend="concepts-flow-control"/>.</para>
        <section xml:id="concepts-embedded-logpaths">
            <title>Embedded log statements</title>
            <indexterm>
                <primary>embedded log statements</primary>
            </indexterm>
            <indexterm>
                <primary>log pipes</primary>
                <secondary>embedded log statements</secondary>
            </indexterm>
            <indexterm significance="preferred">
                <primary>log statements</primary>
                <secondary>embedded</secondary>
            </indexterm>
            <para>Starting from version 3.0, syslog-ng can handle embedded log statements (also called log pipes). Embedded log statements are useful for creating complex, multi-level log paths with several destinations and use filters, parsers, and rewrite rules.</para>
            <para>For example, if you want to filter your incoming messages based on the facility parameter, and then use further filters to send messages arriving from different hosts to different destinations, you would use embedded log statements.</para>
            <figure>
                <title>Embedded log statement</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="syslog-ng-embedded-log-statement-2.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/syslog-ng-embedded-log-statement-2.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Embedded log statements include sources &mdash; and usually filters, parsers, rewrite rules, or destinations &mdash; and other log statements that can include filters, parsers, rewrite rules, and destinations. The following rules apply to embedded log statements:</para>
            <itemizedlist>
                <listitem>
                    <para>Only the beginning (also called top-level) log statement can include sources.</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements can include multiple log statements on the same level (that is, a top-level log statement can include two or more log statements).</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements can include several levels of log statements (that is, a top-level log statement can include a log statement that includes another log statement, and so on).</para>
                </listitem>
                <listitem>
                    <para>After an embedded log statement, you can write either another log statement, or the <parameter>flags()</parameter> option of the original log statement. You cannot use filters or other configuration objects.</para>
                </listitem>
                <listitem>
                    <para>Embedded log statements that are on the same level receive the same messages from the higher-level log statement. For example, if the top-level log statement includes a filter, the lower-level log statements receive only the messages that pass the filter.</para>
                </listitem>
            </itemizedlist>
            <figure>
                <title>Embedded log statements</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata format="PNG" fileref="syslog-ng-embedded-log-statement.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata format="PNG" fileref="&imgroot;/syslog-ng-embedded-log-statement.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Embedded log filters can be used to optimize the processing of log messages, for example, to re-use the results of filtering and rewriting operations.</para>
            <section xml:id="configuring-embedded-logpaths">
                <title>Using embedded log statements</title>
                <para>Embedded log statements (for details, see <xref linkend="concepts-embedded-logpaths"/>) re-use the results of processing messages (for example the results of filtering or rewriting) to create complex log paths. Embedded log statements use the same syntax as regular log statements, but they cannot contain additional sources. To define embedded log statements, use the following syntax:</para>
                <synopsis xml:id="log-path-synopsis-embedded">log {
    source(s1); source(s2); ...

    optional_element(filter1|parser1|rewrite1);
    optional_element(filter2|parser2|rewrite2);
    ...
    destination(d1); destination(d2); ...

    #embedded log statement
    log {
        optional_element(filter1|parser1|rewrite1);
        optional_element(filter2|parser2|rewrite2);
        ...
        destination(d1); destination(d2); ...

        #another embedded log statement
        log {
            optional_element(filter1|parser1|rewrite1);
            optional_element(filter2|parser2|rewrite2);
            ...
            destination(d1); destination(d2); ...
        };
    };
    #set flags after the embedded log statements
    flags(flag1[, flag2...]);
};</synopsis>
                <example xml:id="example-logpath-embedded">
                    <title>Using embedded log paths</title>
                    <para>The following log path sends every message to the configured destinations: both the <userinput>d_file1</userinput> and the <userinput>d_file2</userinput> destinations receive every message of the source.</para>
                    <synopsis>log { source(s_localhost); destination(d_file1); destination(d_file2); };</synopsis>
                    <para>The next example is equivalent with the one above, but uses an embedded log statement.</para>
                    <synopsis>log { source(s_localhost); destination(d_file1);
    log { destination(d_file2); };
};</synopsis>
                    <para>The following example uses two filters:</para>
                    <itemizedlist>
                        <listitem>
                            <para>messages coming from the host <userinput>192.168.1.1</userinput> are sent to the <userinput>d_file1</userinput> destination; and</para>
                        </listitem>
                        <listitem>
                            <para>messages coming from the host <userinput>192.168.1.1</userinput> and containing the string <userinput>example</userinput> are sent to the <userinput>d_file2</userinput> destination.</para>
                        </listitem>
                    </itemizedlist>
                    <synopsis>log { source(s_localhost); host(192.168.1.1); destination(d_file1);
    log { message("example"); destination(d_file2); };
};</synopsis>
                    <para>The following example collects logs from multiple source groups and uses the <parameter>source()</parameter> filter in the embedded log statement to select messages of the <userinput>s_network</userinput> source group.</para>
                    <synopsis>log { source(s_localhost); source(s_network); destination(d_file1);
    log { source(s_network); destination(d_file2); };
};</synopsis>
                </example>
            </section>
        </section>
        <xi:include href="junctions-channels.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="reference-logflags">
            <title>Log path flags</title>
            <para>Flags influence the behavior of syslog-ng, and the way it processes messages. The following flags may be used in the log paths, as described in <xref linkend="logpath"/>.</para>
            <table xml:id="logflags">
                <title>Log statement flags</title>
                <indexterm>
                    <primary>log paths</primary>
                    <secondary>flags</secondary>
                </indexterm>
                <indexterm>
                    <primary>flags</primary>
                </indexterm>
                <indexterm type="parameter">
                    <primary>flags</primary>
                </indexterm>
                <tgroup cols="2">
                    <colspec colnum="1" colwidth="60pt"/>
                    <thead>
                        <row>
                            <entry>Flag</entry>
                            <entry>Description</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>catchall
                                <indexterm type="parameter">
                                    <primary>catchall</primary>
                                </indexterm>
                            </entry>
                            <entry>This flag means that the source of the message is ignored, only the filters are taken into account when matching messages. A log statement using the <parameter>catchall</parameter> flag processes every message that arrives to any of the defined sources.</entry>
                        </row>
                        <row>
                            <entry>fallback
                                <indexterm type="parameter">
                                    <primary>fallback</primary>
                                </indexterm>
                            </entry>
                            <entry>This flag makes a log statement 'fallback'. Fallback log statements process messages that were not processed by other, 'non-fallback' log statements. </entry>
                        </row>
                        <row>
                            <entry>final
                                <indexterm type="parameter">
                                    <primary>final</primary>
                                </indexterm>
                            </entry>
                            <entry>This flag means that the processing of log messages processed by the log statement ends here, other log statements appearing later in the configuration file will not process the messages processed by the log statement labeled as 'final'. Note that this does not necessarily mean that matching messages will be stored only once, as there can be matching log statements processed prior the current one. </entry>
                        </row>
                        <row>
                            <entry>flow-control
                                <indexterm type="parameter">
                                    <primary>flow-control</primary>
                                </indexterm>
                            </entry>
                            <entry>Enables flow-control to the log path, meaning that syslog-ng will stop reading messages from the sources of this log statement if the destinations are not able to process the messages at the required speed. If disabled, syslog-ng will drop messages if the destination queues are full. If enabled, syslog-ng will only drop messages if the destination queues/window sizes are improperly sized. For details, see <xref linkend="concepts-flow-control"/>.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <warning xml:id="warning-embedded-log-flags">
                <para>The <parameter>final</parameter>, <parameter>fallback</parameter>, and <parameter>catchall</parameter> flags apply only for the top-level log paths, they have no effect on embedded log paths.</para>
            </warning>
            <example xml:id="example-logpath-flags">
                <title>Using log path flags</title>
<!--<para>The following log path processes every message received to the
                    <parameter>s_localhost</parameter> source that was not processed by earlier log
                    paths. As syslog-ng processes log paths in the order they appear in the
                    configuration file, place such log paths at the end of the file. A typical situation
                    is to use filters to select the most important messages and send them to specific
                    destinations, and process the remaining messages with a fallback log path.</para>
                    <synopsis>.
                    .
                    .
                    log { source(s_localhost); destination(d_tcp); flags(fallback); };</synopsis>-->
                <para>Let's suppose that you have two hosts (<userinput>myhost_A</userinput> and <userinput>myhost_B</userinput>) that run two applications each (<userinput>application_A</userinput> and <userinput>application_B</userinput>), and you collect the log messages to a central syslog-ng server. On the server, you create two log paths:</para>
                <itemizedlist>
                    <listitem>
                        <para>one that processes only the messages sent by <userinput>myhost_A</userinput>; and</para>
                    </listitem>
                    <listitem>
                        <para>one that processes only the messages sent by <userinput>application_A</userinput>.</para>
                    </listitem>
                </itemizedlist>
                <para>This means that messages sent by <userinput>application_A</userinput> running on <userinput>myhost_A</userinput> will be processed by both log paths, and the messages of <userinput>application_B</userinput> running on <userinput>myhost_B</userinput> will not be processed at all.</para>
                <itemizedlist>
                    <listitem>
                        <para>If you add the <parameter>final</parameter> flag to the first log path, then only this log path will process the messages of <userinput>myhost_A</userinput>, so the second log path will receive only the messages of <userinput>application_A</userinput> running on <userinput>myhost_B</userinput>.</para>
                    </listitem>
                    <listitem>
                        <para>If you create a third log path that includes the <parameter>fallback</parameter> flag, it will process the messages not processed by the first two log paths, in this case, the messages of <userinput>application_B</userinput> running on <userinput>myhost_B</userinput>.</para>
                    </listitem>
                    <listitem>
                        <para>Adding a fourth log path with the <parameter>catchall</parameter> flag would process every message received by the syslog-ng server.</para>
                        <synopsis>log { source(s_localhost); destination(d_file); flags(catchall); };</synopsis>
                    </listitem>
                </itemizedlist>
            </example>
        </section>
    </section>
    <section xml:id="concepts-flow-control">
        <title>Managing incoming and outgoing messages with flow-control</title>
        <indexterm>
            <primary>log paths</primary>
            <secondary>flow-control</secondary>
        </indexterm>
        <indexterm>
            <primary>flow-control</primary>
        </indexterm>
        <indexterm>
            <primary>preventing message loss</primary>
            <secondary>flow-control</secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>log-fetch-limit()</parameter></secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>log-fifo-size()</parameter></secondary>
        </indexterm>
        <para>This section describes the internal message-processing model of syslog-ng, as well as the flow-control feature that can prevent message losses. To use flow-control, the <parameter>flow-control</parameter> flag must be enabled for the particular log path.</para>
        <para>The syslog-ng application monitors (polls) the sources defined in its configuration file, periodically checking each source for messages. When a log message is found in one of the sources, syslog-ng polls every source and reads the available messages. These messages are processed and put into the output buffer of syslog-ng (also called fifo). From the output buffer, the operating system sends the messages to the appropriate destinations.</para>
        <para>In large-traffic environments many messages can arrive during a single poll loop, therefore syslog-ng reads only a fixed number of messages from each source. The <parameter>log-fetch-limit()</parameter> option specifies the number of messages read during a poll loop from a single source.</para>
        <figure>
            <title>Managing log messages in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="io1.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io1.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <indexterm>
            <primary>output buffer</primary>
        </indexterm>
        <para>Every destination has its own output buffer. The output buffer is needed because the destination might not be able to accept all messages immediately. The <parameter>log-fifo-size()</parameter> parameter sets the size of the output buffer. The output buffer must be larger than the <parameter>log-fetch-limit()</parameter> of the sources, to ensure that every message read during the poll loop fits into the output buffer. If the log path sends messages to a destination from multiple sources, the output buffer must be large enough to store the incoming messages of every source.</para>
        <para>TCP and unix-stream sources can receive the logs from several incoming connections (for example many different clients or applications). For such sources, syslog-ng reads messages from every connection, thus the <parameter>log-fetch-limit()</parameter> parameter applies individually to every connection of the source.</para>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>log-iw-size()</parameter></secondary>
        </indexterm>
        <indexterm>
            <primary>parameters</primary>
            <secondary><parameter>max-connections()</parameter></secondary>
        </indexterm>
        <figure>
            <title>Managing log messages of TCP sources in syslog-ng</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="io2.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" fileref="&imgroot;/io2.png" scale="80"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>The flow-control of syslog-ng introduces a control window to the source that tracks how many messages can syslog-ng accept from the source. Every message that syslog-ng reads from the source lowers the window size by one; every message that syslog-ng successfully sends from the output buffer increases the window size by one. If the window is full (that is, its size decreases to zero), syslog-ng stops reading messages from the source. The initial size of the control window is by default <userinput>1000</userinput>: the <parameter>log-fifo-size()</parameter> must be larger than this value in order for flow-control to have any effect. If a source accepts messages from multiple connections, all messages use the same control window.</para>
        <note>
            <para>If the source can handle multiple connections (for example, <parameter>network()</parameter>), the size of the control window is divided by the value of the <parameter>max-connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
        </note>
        <para>When flow-control is used, every source has its own control window. As a worst-case situation, the output buffer of the destination must be set to accommodate all messages of every control window, that is, the <parameter>log-fifo-size()</parameter> of the destination must be greater than <userinput>number_of_sources</userinput>*<parameter>log-iw-size()</parameter>. This applies to every source that sends logs to the particular destination. Thus if two sources having several connections and heavy traffic send logs to the same destination, the control window of both sources must fit into the output buffer of the destination. Otherwise, syslog-ng does not activate the flow-control, and messages may be lost.</para>
        <para>The syslog-ng application handles outgoing messages the following way:</para>
        <figure>
            <title>Handling outgoing messages in &abbrev;</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata format="PNG" fileref="syslog-ng-message-output.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata format="PNG" scale="60" fileref="&imgroot;/syslog-ng-message-output.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>output queue</primary>
                </indexterm>
                <para><emphasis>Output queue</emphasis>: Messages from the output queue are sent to the target syslog-ng server. The syslog-ng application puts the outgoing messages directly into the output queue, unless the output queue is full. The output queue can hold 64 messages, this is a fixed value and cannot be modified.</para>
            </listitem>
            <listitem condition="pe">
                <indexterm>
                    <primary>disk queue</primary>
                    <secondary>disk buffer</secondary>
                </indexterm>
                <para><emphasis>Disk buffer</emphasis>: If the output queue is full and disk-buffering is enabled, syslog-ng Premium Edition puts the outgoing messages into the disk buffer of the destination.</para>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>overflow queue</primary>
                    <secondary>output buffer</secondary>
                </indexterm>
                <para><emphasis>Overflow queue</emphasis>: If the output queue is full<phrase condition="pe"> and the disk buffer is disabled or full</phrase>, syslog-ng puts the outgoing messages into the overflow queue of the destination. (The overflow queue is identical to the output buffer used by other destinations.) The <parameter>log-fifo-size()</parameter> parameter specifies the number of messages stored in the overflow queue. For details on sizing the <parameter>log-fifo-size()</parameter> parameter, see <xref linkend="concepts-flow-control"/>.</para>
            </listitem>
        </itemizedlist>
        <para>There are two types of flow-control: Hard flow-control and soft flow-control.</para>
        <itemizedlist>
            <listitem>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>soft</secondary>
                </indexterm>
                <para><emphasis>Soft flow-control:</emphasis> In case of soft flow-control there is no message lost if the destination can accept messages, but it is possible to lose messages if it cannot accept messages (for example non-writeable file destination, or the disk becomes full), and all buffers are full. Soft flow-control cannot be configured, it is automatically available for file <phrase condition="pe"> and logstore </phrase>destinations.</para>
                <example>
                    <title>Soft flow-control</title>
                    <synopsis>source s_file { file("/tmp/input_file.log"); };
destination d_file { file("/tmp/output_file.log"); };
destination d_tcp { network("127.0.0.1" port(2222) log-fifo-size(1000)); };
log { source(s_file); destination(d_file); destination(d_tcp); };
</synopsis>
                </example>
                <warning>
                    <para>Hazard of data loss! For destinations other than file<phrase condition="pe"> and logstore</phrase>, soft flow-control is not available. Thus, it is possible to lose log messages on those destinations. To avoid data loss on those destinations, use hard flow-control.</para>
                </warning>
            </listitem>
            <listitem>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>hard</secondary>
                </indexterm>
                <para><emphasis>Hard flow-control:</emphasis> In case of hard flow-control there is no message lost. To use hard flow-control, enable the <parameter>flow-control</parameter> flag in the log path. Hard flow-control is available for all destinations.</para>
                <example>
                    <title>Hard flow-control</title>
                    <synopsis>source s_file { file("/tmp/input_file.log"); };
destination d_file { file("/tmp/output_file.log"); };
destination d_tcp { network("127.0.0.1" port(2222) log-fifo-size(1000)); };
log { source(s_file); destination(d_file); destination(d_tcp); flags(flow-control); };
</synopsis>
                </example>
            </listitem>
        </itemizedlist>
        <xi:include href="../../common/chunk/flow-control-multiple-destinations.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
        <section xml:id="configuring-flow-control">
            <title>Configuring flow-control</title>
            <indexterm>
                <primary>log paths</primary>
                <secondary>flow-control</secondary>
            </indexterm>
            <indexterm>
                <primary>flow-control</primary>
            </indexterm>
            <indexterm>
                <primary>preventing message loss</primary>
                <secondary>flow-control</secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>log-fetch-limit()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>log-fifo-size()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>log-iw-size()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>parameters</primary>
                <secondary><parameter>max-connections()</parameter></secondary>
            </indexterm>
            <indexterm>
                <primary>output buffer</primary>
            </indexterm>
            <para>For details on how flow-control works, see <xref linkend="concepts-flow-control"/>. The summary of the main points is as follows:</para>
            <itemizedlist>
                <listitem>
                    <para>The syslog-ng application normally reads a maximum of <parameter>log-fetch-limit()</parameter> number of messages from a source.</para>
                </listitem>
                <listitem>
                    <para>From TCP and unix-stream sources, syslog-ng reads a maximum of <parameter>log-fetch-limit()</parameter> from every connection of the source. The number of connections to the source is set using the <parameter>max-connections()</parameter> parameter.</para>
                </listitem>
                <listitem>
                    <para>Every destination has an output buffer (<parameter>log-fifo-size()</parameter>).</para>
                </listitem>
                <listitem>
                    <para>Flow-control uses a control window to determine if there is free space in the output buffer for new messages. Every source has its own control window; <parameter>log-iw-size()</parameter> parameter sets the size of the control window.</para>
                </listitem>
                <listitem>
                    <para>When a source accepts multiple connections, the size of the control window is divided by the value of the <parameter>max-connections()</parameter> parameter and this smaller control window is applied to each connection of the source.</para>
                </listitem>
                <listitem>
                    <para>The output buffer must be larger than the control window of every source that logs to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the control window is full, syslog-ng stops reading messages from the source until some messages are successfully sent to the destination.</para>
                </listitem>
                <listitem>
                    <para>If the output buffer becomes full, and <phrase condition="pe">neither disk-buffering nor flow-control is</phrase> <phrase condition="ose">flow-control is not</phrase> used, messages may be lost.</para>
                </listitem>
            </itemizedlist>
            <warning>
                <para>If you modify the <parameter>max-connections()</parameter> or the <parameter>log-fetch-limit()</parameter> parameter, do not forget to adjust the <parameter>log-iw-size()</parameter> and <parameter>log-fifo-size()</parameter> parameters accordingly.</para>
            </warning>
            <example>
                <title>Sizing parameters for flow-control</title>
                <indexterm>
                    <primary>log paths</primary>
                    <secondary>flow-control</secondary>
                </indexterm>
                <indexterm>
                    <primary>flow-control</primary>
                    <secondary>example</secondary>
                </indexterm>
                <para>Suppose that syslog-ng has a source that must accept up to 300 parallel connections. Such situation can arise when a network source receives connections from many clients, or if many applications log to the same socket. Therefore, set the <parameter>max-connections()</parameter> parameter of the source to <userinput>300</userinput>. However, the <parameter>log-fetch-limit()</parameter> (default value: 10) parameter applies to every connection of the source individually, while the <parameter>log-iw-size()</parameter> (default value: 1000) parameter applies to the source. In a worst-case scenario, the destination does not accept any messages, while all 300 connections send at least <parameter>log-fetch-limit()</parameter> number of messages to the source during every poll loop. Therefore, the control window must accommodate at least <parameter>max-connections()</parameter>*<parameter>log-fetch-limit()</parameter> messages to be able to read every incoming message of a poll loop. In the current example this means that (<parameter>log-iw-size()</parameter> should be greater than <userinput>300*10=3000</userinput>. If the control window is smaller than this value, the control window might fill up with messages from the first connections &mdash; causing syslog-ng to read only one message of the last connections in every poll loop.</para>
                <para>The output buffer of the destination must accommodate at least <parameter>log-iw-size()</parameter> messages, but use a greater value: in the current example <userinput>3000*10=30000</userinput> messages. That way all incoming messages of ten poll loops fit in the output buffer. If the output buffer is full, syslog-ng does not read any messages from the source until some messages are successfully sent to the destination.</para>
                <synopsis>source s_localhost {
            network(ip(127.0.0.1) port(1999) max-connections(300)); };
destination d_tcp {
            network("10.1.2.3" port(1999) localport(999) log-fifo-size(30000)); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
                <para>If other sources send messages to this destination, than the output buffer must be further increased. For example, if a network host with maximum <userinput>100</userinput> connections also logs into the destination, than increase the <parameter>log-fifo-size()</parameter> by <userinput>10000</userinput>.</para>
                <synopsis>source s_localhost {
            network(ip(127.0.0.1) port(1999) max-connections(300)); };
source s_tcp {
            network(ip(192.168.1.5) port(1999) max-connections(100)); };
destination d_tcp {
            network("10.1.2.3" port(1999) localport(999) log-fifo-size(40000)); };
log { source(s_localhost); destination(d_tcp); flags(flow-control); };</synopsis>
            </example>
        </section>
    </section>
    <section xml:id="filters">
        <title>Filters</title>
        <indexterm significance="preferred">
            <primary>filters</primary>
        </indexterm>
        <indexterm significance="preferred">
            <primary>regular expressions</primary>
        </indexterm>
        <para>The following sections describe how to select and filter log messages.</para>
        <itemizedlist>
            <listitem>
                <para><xref linkend="configuring-filters"/> describes how to configure and use filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-boolean"/> shows how to create complex filters using boolean operators.</para>
            </listitem>
            <listitem>
                <para><xref linkend="filters-comparing"/> explains how to evaluate macros in filters.</para>
            </listitem>
            <listitem>
                <para><xref linkend="regular-expr"/> provides tips on using regular expressions.</para>
            </listitem>
            <listitem>
                <para><xref linkend="tagging-messages"/> explains how to tag messages and how to filter on the tags.</para>
            </listitem>
            <listitem>
                <para><xref linkend="reference-filters"/> is a detailed description of the filter functions available in &abbrev;.</para>
            </listitem>
        </itemizedlist>
        <section xml:id="configuring-filters">
            <title>Using filters</title>
            <para>Filters perform log routing within syslog-ng: a message passes the filter if the filter expression is true for the particular message. If a log statement includes filters, the messages are sent to the destinations only if they pass all filters of the log path. For example, a filter can select only the messages originating from a particular host. Complex filters can be created using filter functions and logical boolean expressions.</para>
            <para>To define a filter, add a filter statement to the syslog-ng configuration file using the following syntax:</para>
            <indexterm>
                <primary>filters</primary>
                <secondary>defining</secondary>
            </indexterm>
            <synopsis>filter &lt;identifier&gt; { &lt;filter_type&gt;("&lt;filter_expression&gt;"); };</synopsis>
            <example>
                <title>A simple filter statement</title>
                <para>The following filter statement selects the messages that contain the word <userinput>deny</userinput> and come from the host <userinput>example</userinput>.</para>
                <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")) };</synopsis>
                <para>For the filter to have effect, include it in a log statement:</para>
                <synopsis>log {
    source(s1);
    filter(demo_filter);
    destination(d1); };</synopsis>
            </example>
        </section>
        <section xml:id="filters-boolean">
            <title>Combining filters with boolean operators</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>boolean operators</secondary>
            </indexterm>
            <indexterm>
                <primary>filters</primary>
                <secondary>AND, OR, NOT</secondary>
            </indexterm>
            <indexterm>
                <primary>boolean operators</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>AND</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>OR</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>NOT</primary>
            </indexterm>
            <para>When a log statement includes multiple filter statements, syslog-ng sends a message to the destination only if all filters are true for the message. In other words, the filters are connected with the logical <userinput>AND</userinput> operator. In the following example, no message arrives to the destination, because the filters are exclusive (the hostname of a client cannot be <userinput>example1</userinput> and <userinput>example2</userinput> at the same time):</para>
            <synopsis>filter demo_filter1 { host("example1"); };
filter demo_filter2 { host("example2"); };
log {
    source(s1); source(s2);
    filter(demo_filter1); filter(demo_filter2);
    destination(d1); destination(d2); };</synopsis>
            <para>To select the messages that come from either host <userinput>example1</userinput> or <userinput>example2</userinput>, use a single filter expression:</para>
            <synopsis>filter demo_filter { host("example1") or host("example2"); };
log {
    source(s1); source(s2);
    filter(demo_filter);
    destination(d1); destination(d2); };</synopsis>
            <para>Use the <userinput>not</userinput> operator to invert filters, for example, to select the messages that were not sent by host <userinput>example1</userinput>:</para>
            <synopsis>filter demo_filter { not host("example1"); };</synopsis>
            <para>However, to select the messages that were not sent by host <userinput>example1</userinput> or <userinput>example2</userinput>, you have to use the <userinput>and</userinput> operator (that's how boolean logic works):</para>
            <synopsis>filter demo_filter { not host("example1") and not host("example2"); };</synopsis>
            <para>Alternatively, you can use parentheses to avoid this confusion:</para>
            <synopsis>filter demo_filter { not (host("example1") or host("example2")); };</synopsis>
            <para>For a complete description on filter functions, see <xref linkend="reference-filters"/>.</para>
            <para>The following filter statement selects the messages that contain the word <userinput>deny</userinput> and come from the host <userinput>example</userinput>.</para>
            <synopsis>filter demo_filter { host("example") and match("deny" value("MESSAGE")); };</synopsis>
            <para>The <parameter>value()</parameter> parameter of the <parameter>match</parameter> function limits the scope of the function to the text part of the message (that is, the part returned by the <parameter>${MESSAGE}</parameter> macro). For details on using the <parameter>match()</parameter> filter function, see <xref linkend="reference-filters-match"/>.</para>
            <tip>
                <para>Filters are often used together with log path flags. For details, see <xref linkend="reference-logflags"/>.</para>
            </tip>
        </section>
        <section xml:id="filters-comparing">
            <title>Comparing macro values in filters</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>comparing values</secondary>
            </indexterm>
            <indexterm type="parameter">
                <primary>ge</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>gt</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>eq</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>ne</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>le</primary>
            </indexterm>
            <indexterm type="parameter">
                <primary>lt</primary>
            </indexterm>
            <indexterm>
                <primary>string comparison</primary>
            </indexterm>
            <indexterm>
                <primary>value comparison</primary>
            </indexterm>
            <indexterm>
                <primary>comparing values</primary>
            </indexterm>
            <indexterm>
                <primary>filters</primary>
                <secondary>comparing values</secondary>
            </indexterm>
            <para>Starting with &abbrev; version <phrase condition="ose">3.2</phrase><phrase condition="pe">4 F1</phrase>, it is also possible to compare macro values and templates as numerical and string values. String comparison is alphabetical: it determines if a string is alphabetically greater or equal to another string. Use the following syntax to compare macro values or templates. For details on macros and templates, see <xref linkend="customizing-message-format"/>.</para>
            <synopsis>filter &lt;filter-id&gt;
        {"&lt;macro-or-template&gt;" operator "&lt;value-or-macro-or-template&gt;"};</synopsis>
            <example xml:id="example-comparison">
                <title>Comparing macro values in filters</title>
                <para>The following expression selects log messages containing a PID (that is, <parameter>${PID}</parameter> macro is not empty):</para>
                <synopsis>filter f_pid {"${PID}" !=""};</synopsis>
                <para>The following expression selects log messages that do not contain a PID. Also, it uses a template as the left argument of the operator and compares the values as strings:</para>
                <synopsis>filter f_pid {"${HOST}${PID}" eq "${HOST}"};</synopsis>
                <para>The following example selects messages with priority level 4 or higher.</para>
                <synopsis>filter f_level {"${LEVEL_NUM}" &gt; "5"};</synopsis>
            </example>
            <para>Note that:</para>
            <itemizedlist>
                <listitem>
                    <para>The macro or template must be enclosed in double-quotes.</para>
                </listitem>
                <listitem>
                    <para>The <userinput>$</userinput> character must be used before macros.</para>
                </listitem>
                <listitem>
                    <para>Using comparator operators can be equivalent to using filter functions, but is somewhat slower. For example, using <userinput>"${HOST}" eq "myhost"</userinput> is equivalent to using <userinput>host("myhost" type(string))</userinput>.</para>
                </listitem>
                <listitem>
                    <para>You can use any macro in the expression, including user-defined macros from parsers and results of pattern database classifications.</para>
                </listitem>
                <listitem>
                    <para>The results of filter functions are boolean values, so they cannot be compared to other values.</para>
                </listitem>
                <listitem>
                    <para>You can use boolean operators to combine comparison expressions.</para>
<!-- FIXME add a working example-->
                </listitem>
            </itemizedlist>
            <para>The following operators are available:</para>
            <table>
                <title>Numerical and string comparison operators</title>
<?dbfo keep-together="auto" ?>
                <tgroup cols="3">
                    <thead>
                        <row>
                            <entry>Numerical operator</entry>
                            <entry>String operator</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>==</entry>
                            <entry>eq</entry>
                            <entry>Equals</entry>
                        </row>
                        <row>
                            <entry>!=</entry>
                            <entry>ne</entry>
                            <entry>Not equal to</entry>
                        </row>
                        <row>
                            <entry>&gt;</entry>
                            <entry>gt</entry>
                            <entry>Greater than</entry>
                        </row>
                        <row>
                            <entry>&lt;</entry>
                            <entry>lt</entry>
                            <entry>Less than</entry>
                        </row>
                        <row>
                            <entry>&gt;=</entry>
                            <entry>ge</entry>
                            <entry>Greater than or equal</entry>
                        </row>
                        <row>
                            <entry>=&lt;</entry>
                            <entry>le</entry>
                            <entry>Less than or equal</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section xml:id="regular-expr">
            <title>Using wildcards, special characters, and regular expressions in filters</title>
            <indexterm>
                <primary>regular expressions</primary>
                <secondary>posix</secondary>
            </indexterm>
            <para>The <parameter>host()</parameter>, <parameter>match()</parameter>, and <parameter>program()</parameter> filter functions accept regular expressions as parameters. The exact type of the regular expression to use can be specified with the <parameter>type()</parameter> option. By default, &abbrev; uses PCRE regular expressions.</para>
            <indexterm>
                <primary>filters</primary>
                <secondary>wildcards</secondary>
            </indexterm>
            <para>In regular expressions, the asterisk (<userinput>*</userinput>) character means 0, 1 or any number of the previous expression. For example, in the <userinput>f*ilter</userinput> expression the asterisk means 0 or more f letters. This expression matches for the following strings: <userinput>ilter</userinput>, <userinput>filter</userinput>, <userinput>ffilter</userinput>, and so on. To achieve the wildcard functionality commonly represented by the asterisk character in other applications, use <userinput>.*</userinput> in your expressions, for example <userinput>f.*ilter</userinput>.</para>
            <para>Alternatively, if you do not need regular expressions, only wildcards, use <userinput>type(glob)</userinput> in your filter:</para>
            <example xml:id="example-wildcard-filter">
                <title>Filtering with widcards</title>
                <para>The following filter matches on hostnames starting with the <userinput>myhost</userinput> string, for example, on <userinput>myhost-1</userinput>, <userinput>myhost-2</userinput>, and so on.</para>
                <synopsis>filter f_wildcard {host("myhost*" type(glob));};</synopsis>
            </example>
            <para>For details on using regular expressions in &abbrev;, see <xref linkend="regular-expr"/>.</para>
            <indexterm>
                <primary>filters</primary>
                <secondary>control characters</secondary>
            </indexterm>
            <para>To filter for special control characters like the carriage return (CR), use the <userinput>\r</userinput> escape prefix in &abbrev; version 3.0 and 3.1. In &abbrev; 3.2 and later, you can also use the <userinput>\x</userinput> escape prefix and the ASCII code of the character. For example, to filter on carriage returns, use the following filter:</para>
            <synopsis>filter f_carriage_return {match("\x0d" value ("MESSAGE"));};</synopsis>
        </section>
        <section xml:id="tagging-messages">
            <title>Tagging messages</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>tags</secondary>
            </indexterm>
            <indexterm>
                <primary>tagging messages</primary>
            </indexterm>
            <indexterm>
                <primary>tags</primary>
            </indexterm>
            <para>You can label the messages with custom tags. Tags are simple labels, identified by their names, which must be unique. Currently &abbrev; can tag a message at two different places:</para>
            <itemizedlist>
                <listitem>
                    <para>at the source when the message is received; and</para>
                </listitem>
                <listitem>
                    <para>when the message matches a pattern in the pattern database. For details on using the pattern database, see <xref linkend="configuring-pattern-databases"/>, for details on creating tags in the pattern database, see <xref linkend="reference-patterndb-schemes"/>.</para>
                </listitem>
                <listitem>
                    <para>Tags can be also added and deleted using rewrite rules. For details, see <xref linkend="rewrite-tags"/>.</para>
                </listitem>
            </itemizedlist>
            <para>When syslog-ng receives a message, it automatically adds the <userinput>.source.&lt;id_of_the_source_statement&gt;</userinput> tag to the message. Use the <parameter>tags()</parameter> option of the source to add custom tags, and the <parameter>tags()</parameter> option of the filters to select only specific messages.</para>
            <note>
                <itemizedlist>
                    <listitem>
                        <para>Tagging messages and also filtering on the tags is very fast, much faster than other types of filters.</para>
                    </listitem>
                    <listitem>
                        <para>Tags are available locally, that is, if you add tags to a message on the client, these tags will not be available on the server.</para>
                    </listitem>
                    <listitem>
                        <para>To include the tags in the message, use the <parameter>${TAGS}</parameter> macro in a template. Alternatively, if you are using the IETF-syslog message format, you can include the <parameter>${TAGS}</parameter> macro in the <parameter>.SDATA.meta</parameter> part of the message. Note that the <parameter>${TAGS}</parameter> macro is available only in &abbrev; 3.1.1 and later.</para>
                    </listitem>
                </itemizedlist>
            </note>
            <para>For an example on tagging, see <xref linkend="example-tags-filtering"/>.</para>
        </section>
        <section xml:id="reference-filters">
            <title>Filter functions</title>
            <indexterm>
                <primary>filters</primary>
                <secondary>reference</secondary>
            </indexterm>
            <para>The following functions may be used in the filter statement, as described in <xref linkend="filters"/>.</para>
            <xi:include href="../../common/chunk/table-filter-functions.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            <simplesect xml:id="filter-facility">
                <title>facility()</title>
                <indexterm type="parameter">
                    <primary>facility()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>facility(&lt;facility-name&gt;) or facility(&lt;facility-code&gt;) or facility(&lt;facility-name&gt;..&lt;facility-name&gt;)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match messages having one of the listed facility codes.</para>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>facilities, </secondary>
                </indexterm>
                <para>The <parameter>facility()</parameter> filter accepts both the name and the numerical code of the facility or the importance level. Facility codes 0-23 are predefined and can be referenced by their usual name. Facility codes above 24 are not defined.</para>
                <para>You can use the facility filter the following ways:</para>
                <itemizedlist>
                    <listitem>
                        <para>Use a single facility name, for example, <userinput>facility(user)</userinput></para>
                    </listitem>
                    <listitem>
                        <para>Use a single facility code, for example, <userinput>facility(1)</userinput></para>
                    </listitem>
                    <listitem>
                        <para>Use a facility range (works only with facility names), for example, <userinput>facility(local0..local5)</userinput></para>
                    </listitem>
                </itemizedlist>
                <para>The syslog-ng application recognizes the following facilities: (Note that some of these facilities are available only on specific platforms.)</para>
<!-- FIXME authpriv -->
                <table>
                    <title>syslog Message Facilities recognized by the facility() filter</title>
<?dbfo keep-together="auto" ?>
                    <indexterm>
                        <primary>facilities</primary>
                    </indexterm>
                    <indexterm>
                        <primary>message facilities</primary>
                    </indexterm>
                    <tgroup cols="3">
                        <thead>
                            <row>
                                <entry>Numerical Code</entry>
                                <entry>Facility name</entry>
                                <entry>Facility</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>0</entry>
                                <entry>kern</entry>
                                <entry>kernel messages</entry>
                            </row>
                            <row>
                                <entry>1</entry>
                                <entry>user</entry>
                                <entry>user-level messages</entry>
                            </row>
                            <row>
                                <entry>2</entry>
                                <entry>mail</entry>
                                <entry>mail system</entry>
                            </row>
                            <row>
                                <entry>3</entry>
                                <entry>daemon</entry>
                                <entry>system daemons</entry>
                            </row>
                            <row>
                                <entry>4</entry>
                                <entry>auth</entry>
                                <entry>security/authorization messages</entry>
                            </row>
                            <row>
                                <entry>5</entry>
                                <entry>syslog</entry>
                                <entry>messages generated internally by syslogd</entry>
                            </row>
                            <row>
                                <entry>6</entry>
                                <entry>lpr</entry>
                                <entry>line printer subsystem</entry>
                            </row>
                            <row>
                                <entry>7</entry>
                                <entry>news</entry>
                                <entry>network news subsystem</entry>
                            </row>
                            <row>
                                <entry>8</entry>
                                <entry>uucp</entry>
                                <entry>UUCP subsystem</entry>
                            </row>
                            <row>
                                <entry>9</entry>
                                <entry>cron</entry>
                                <entry>clock daemon</entry>
                            </row>
                            <row>
                                <entry>10</entry>
                                <entry>authpriv</entry>
                                <entry>security/authorization messages</entry>
                            </row>
                            <row>
                                <entry>11</entry>
                                <entry>ftp</entry>
                                <entry>FTP daemon</entry>
                            </row>
                            <row>
                                <entry>12</entry>
                                <entry>ntp</entry>
                                <entry>NTP subsystem</entry>
                            </row>
                            <row>
                                <entry>13</entry>
                                <entry>security</entry>
                                <entry>log audit</entry>
                            </row>
                            <row>
                                <entry>14</entry>
                                <entry>console</entry>
                                <entry>log alert</entry>
                            </row>
                            <row>
                                <entry>15</entry>
                                <entry>solaris-cron</entry>
                                <entry>clock daemon</entry>
                            </row>
                            <row>
                                <entry>16-23</entry>
                                <entry>local0..local7</entry>
                                <entry>locally used facilities (local0-local7)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </simplesect>
            <simplesect xml:id="filter-filter">
                <title>filter()</title>
                <indexterm type="parameter">
                    <primary>filter()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>filter(filtername)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Call another filter rule and evaluate its value.</para>
            </simplesect>
            <simplesect xml:id="filter-host">
                <title>host()</title>
                <indexterm type="parameter">
                    <primary>host()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>host(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match messages by using a regular expression against the hostname field of log messages.</para>
            </simplesect>
            <simplesect xml:id="filter-inlist">
                <title>inlist()</title>
                <indexterm type="parameter">
                    <primary>inlist()</primary>
                </indexterm>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>blacklisting</secondary>
                </indexterm>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>whitelisting</secondary>
                </indexterm>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>in-list()</secondary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis:
                                    <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>in-list("&lt;/path/to/file.list&gt;", value("&lt;field-to-filter&gt;"))</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Matches the value of the specified field to a list stored in a file, allowing you to do simple, file-based black- and whitelisting. The file must be a plain-text file, containing one entry per line. The &abbrev; application loads the entire file, and compares the value of the specified field (for example, ${PROGRAM}) to entries in the file. When you use the <parameter>in-list filter</parameter>, note the following points:</para>
                <itemizedlist>
                    <listitem>
                        <para>Comparing the values is case-sensitive.</para>
                    </listitem>
                    <listitem>
                        <para>Only exact matches are supported, partial and substring matches are not.</para>
                    </listitem>
                    <listitem>
                        <para>If you modify the list file, reload the configuration of &abbrev; for the changes to take effect.</para>
                    </listitem>
                </itemizedlist>
                <para>Available in &abbrev; <phrase condition="ose">3.5</phrase> and later.</para>
                <example xml:id="example-whitelist-filter">
                    <title>Selecting messages using the in-list filter</title>
                    <para>Create a text file that contains the programs (as in the ${PROGRAM} field of their log messages) you want to select. For example, you want to forward only the logs of a few applications from a host: kernel, sshd, and sudo. Create the <filename>/etc/syslog-ng/programlist.list</filename> file with the following contents:</para>
                    <synopsis>kernel
sshd
sudo</synopsis>
                    <para>The following filter selects only the messages of the listed applications:</para>
                    <synopsis>filter f_whitelist { in-list("/etc/syslog-ng/programlist.list", value("PROGRAM")); };</synopsis>
                    <para>Create the appropriate sources and destinations for your environment, then create a log path that uses the previous filter to select only the log messages of the applications you need:</para>
                    <synopsis>log {
    source(s_all);
    filter(f_whitelist);
    destination(d_logserver); };</synopsis>
                    <para>To create a blacklist filter, simply negate the <parameter>in-list</parameter> filter:</para>
                    <synopsis>filter f_blacklist { not in-list("/etc/syslog-ng/programlist.list", value("PROGRAM")); };</synopsis>
                </example>
            </simplesect>
            <simplesect xml:id="filter-priority">
                <title>level() or priority()</title>
                <indexterm type="parameter">
                    <primary>level() or priority()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>level(&lt;priority-level&gt;) or level(&lt;priority-level&gt;..&lt;priority-level&gt;)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> The <parameter>level()</parameter> filter selects messages corresponding to a single importance level, or a level-range. To select messages of a specific level, use the name of the level as a filter parameter, for example use the following to select warning messages:</para>
                <synopsis>level(warning)</synopsis>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>facility and priority (level) ranges</secondary>
                </indexterm>
                <para>To select a range of levels, include the beginning and the ending level in the filter, separated with two dots (<userinput>..</userinput>). For example, to select every message of error or higher level, use the following filter:</para>
                <synopsis>level(err..emerg)</synopsis>
                <indexterm>
                    <primary>filters</primary>
                    <secondary>priorities</secondary>
                </indexterm>
                <para>The <parameter>level()</parameter> filter accepts the following levels: <parameter>emerg</parameter>, <parameter>alert</parameter>, <parameter>crit</parameter>, <parameter>err</parameter>, <parameter>warning</parameter>, <parameter>notice</parameter>, <parameter>info</parameter>, <parameter>debug</parameter>.</para>
            </simplesect>
            <simplesect xml:id="reference-filters-match">
                <title>match()</title>
                <indexterm type="parameter">
                    <primary>match()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>match(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match a regular expression to the headers and the message itself (that is, the values returned by the <parameter>MSGHDR</parameter> and <parameter>MSG</parameter> macros). Note that in syslog-ng version 2.1 and earlier, the <parameter>match()</parameter> filter was applied only to the text of the message, excluding the headers. This functionality has been moved to the <parameter>message()</parameter> filter.</para>
                <indexterm type="parameter">
                    <primary>value()</primary>
                </indexterm>
                <para>To limit the scope of the match to a specific part of the message (identified with a macro), use the <userinput>match(regexp value("MACRO"))</userinput> syntax. Do not include the $ sign in the parameter of the <parameter>value()</parameter> option.</para>
                <para>The <parameter>value()</parameter> parameter accepts both built-in macros and user-defined ones created with a parser or using a pattern database. For details on macros and parsers, see <xref linkend="configuring-macros"/>, <xref linkend="csv-parser"/>, and <xref linkend="patterndb-filters"/>.</para>
            </simplesect>
            <simplesect xml:id="filter-message">
                <title>message()</title>
                <indexterm type="parameter">
                    <primary>message()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>message(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match a regular expression to the text of the log message, excluding the headers (that is, the value returned by the <parameter>MSG</parameter> macros). Note that in syslog-ng version 2.1 and earlier, this functionality was performed by the <parameter>match()</parameter> filter.</para>
            </simplesect>
            <simplesect xml:id="filter-netmask">
                <title>netmask()</title>
                <indexterm type="parameter">
                    <primary>netmask()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>netmask(ipv4/mask)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select only messages sent by a host whose IP address belongs to the specified IPv4 subnet. Note that this filter checks the IP address of the last-hop relay (the host that actually sent the message to &abbrev;), not the contents of the <parameter>HOST</parameter> field of the message. You can use both the dot-decimal and the CIDR notation to specify the netmask. For example, <userinput>192.168.5.0/255.255.255.0</userinput> or <userinput>192.168.5.0/24</userinput>. To filter IPv6 addresses, see <xref linkend="filter-netmask6"/>.</para>
            </simplesect>
            <simplesect xml:id="filter-netmask6">
                <title>netmask6()</title>
                <indexterm>
                    <primary>netmask6()</primary>
                </indexterm>
                <indexterm>
                    <primary>IPv6</primary>
                    <secondary>filtering</secondary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>netmask6(ipv6/mask)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select only messages sent by a host whose IP address belongs to the specified IPv6 subnet. Note that this filter checks the IP address of the last-hop relay (the host that actually sent the message to &abbrev;), not the contents of the <parameter>HOST</parameter> field of the message. You can use both the regular and the compressed format to specify the IP address, for example, <userinput>1080:0:0:0:8:800:200C:417A</userinput> or <userinput>1080::8:800:200C:417A</userinput>. If you do not specify the address, <userinput>localhost</userinput> is used. Use the netmask (also called prefix) to specify how many of the leftmost bits of the address comprise the netmask (values 1-128 are valid). For example, the following specify a 60-bit prefix: <userinput>12AB:0000:0000:CD30:0000:0000:0000:0000/60</userinput> or <userinput>12AB::CD30:0:0:0:0/60</userinput>. Note that if you set an IP address and a prefix, &abbrev; will ignore the bits of the address after the prefix. To filter IPv4 addresses, see <xref linkend="filter-netmask"/>.</para>
                <para>The <parameter>netmask6()</parameter> filter is available in &abbrev; <phrase condition="pe">5.0.8 and 5.2.2</phrase><phrase condition="ose">3.7</phrase> and later.</para>
                <warning>
                    <para>If the IP address is not syntactically correct, the filter will never match. The &abbrev; application currently does not send a warning for such configuration errors.</para>
                </warning>
            </simplesect>
            <simplesect xml:id="filter-program">
                <title>program()</title>
                <indexterm type="parameter">
                    <primary>program()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>program(regexp)</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Match messages by using a regular expression against the program name field of log messages.</para>
            </simplesect>
            <simplesect xml:id="filter-source">
                <title>source()</title>
                <indexterm type="parameter">
                    <primary>source()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>source id</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select messages of a source statement. This filter can be used in embedded log statements if the parent statement contains multiple source groups &mdash; only messages originating from the selected source group are sent to the destination of the embedded log statement.</para>
            </simplesect>
            <simplesect xml:id="filter-tags">
                <title>tags()</title>
                <indexterm type="parameter">
                    <primary>tags()</primary>
                </indexterm>
                <informaltable frame="topbot" colsep="0" rowsep="0">
                    <tgroup cols="2">
                        <colspec colnum="1" colwidth="50pt"/>
                        <tbody>
                            <row>
                                <entry>Synopsis: <?dbhtml bgcolor="#D4D6EB" ?>
<?dbfo bgcolor="#D4D6EB" ?>
                                </entry>
                                <entry>tag</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
                <para><emphasis role="bold">Description:</emphasis> Select messages labeled with the specified tag. Every message automatically has the tag of its source in <userinput>.source.&lt;id_of_the_source_statement&gt;</userinput> format. This option is available only in syslog-ng 3.1 and later.</para>
                <example xml:id="example-tags-filtering">
                    <title>Adding tags and filtering messages with tags</title>
                    <synopsis>source s_tcp {
    network(ip(192.168.1.1) port(1514) tags("tcp", "router"));
};</synopsis>
                    <para>Use the <parameter>tags()</parameter> option of the filters to select only specific messages:</para>
                    <synopsis>filter f_tcp {
    tags(".source.s_tcp");
};

filter f_router {
    tags("router");
};</synopsis>
                </example>
                <xi:include href="../../common/wnt/note-patterndb-class-tag.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
            </simplesect>
        </section>
    </section>
    <section xml:id="example-dropping-messages">
        <title>Dropping messages</title>
        <indexterm>
            <primary>skipping messages</primary>
        </indexterm>
        <indexterm>
            <primary>dropping messages</primary>
        </indexterm>
        <indexterm>
            <primary>discarding messages</primary>
        </indexterm>
        <para>To skip the processing of a message without sending it to a destination, create a log statement with the appropriate filters, but do not include any destination in the statement, and use the <parameter>final</parameter> flag.</para>
        <example>
            <title>Skipping messages</title>
            <para>The following log statement drops all <parameter>debug</parameter> level messages without any further processing.</para>
            <synopsis>filter demo_debugfilter { level(debug); };
log { source(s_all); filter(demo_debugfilter); flags(final); };</synopsis>
        </example>
    </section>
</chapter>
